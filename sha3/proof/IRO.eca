(* Infinite random oracle, mapping values of type [from] to infinite
   sequences of values of type [to], each sampled uniformly and
   independently. We obviously make it lazy. Inputs not satisfying
   a validity predicate are mapped to the empty list *)

require import Option Int Bool List FSet NewFMap.

type to, from.

op valid : from -> bool.
op dto   : to distr.

module type IRO = {
  proc init() : unit

  (* f x, returning the first n elements of the result *)
  proc f(x : from, n : int) : to list
}.

pred prefix_closed (m : (from * int,to) fmap) =
  forall x n,
    mem (dom m) (x,n) =>
    (forall i, 0 <= i < n =>
      mem (dom m) (x,i)).

pred prefix_closed' (m : (from * int,to) fmap) =
  forall x n i,
    mem (dom m) (x,n) =>
    0 <= i < n =>
    mem (dom m) (x,i).

lemma prefix_closed_equiv m: prefix_closed m <=> prefix_closed' m.
proof. smt(). qed.

(* official version: *)

module IRO : IRO = {
  var mp : (from * int, to) fmap

  proc init() = {
    mp <- map0;
  }

  proc fill_in(x, n) = {
    if (!mem (dom mp) (x, n)) {
      mp.[(x,n)] <$ dto;
    }
    return oget mp.[(x,n)];
  }

  proc f(x, n) = {
    var b, bs;
    var i <- 0;

    bs <- [];
    if (valid x) {
      while (i < n) {
        b <@ fill_in(x, i);
        bs <- rcons bs b;
        i <- i + 1;
      }
    }

    return bs;
  }
}.

(* version for AbsorbToBlocks.ec attempt *)

module IRO' : IRO = {
  var mp : (from * int, to)  fmap
  var visible : (from * int) fset

  proc resample_invisible() = {
    var work, x;

    work <- dom mp `\` visible;
    while (work <> fset0) {
      x <- pick work;
      mp.[x] <$ dto;
      work <- work `\` fset1 x;
    }
  }

  proc init() = {
    mp <- map0;
    visible <- fset0;
  }

  proc fill_in(x,n) = {
    if (!mem (dom mp) (x,n)) {
      mp.[(x,n)] <$ dto;
    }
    return oget mp.[(x,n)];
  }

  proc f(x, n) = {
    var b, bs;
    var i <- 0;

    bs <- [];
    if (valid x) {
      visible <- visible `|` fset1 (x,n);
      while (i < n) {
        b <@ fill_in(x,i);
        bs <- rcons bs b;
        i <- i + 1;
      }
    }

    return bs;
  }

  proc f_lazy(x, i) = {
    var b <- witness;

    if (valid x /\ 0 <= i) {
      visible <- visible `|` fset1 (x,i);
      b <@ fill_in(x,i);
    }
    return b;
  }
}.

(*
another implementation, but probably not useful

module IRO : IRO = {
  var mp : (from, to list) fmap

  proc init() = { mp = map0; }

  proc choose(n) = {
    var b, bs;

    bs <- [];
    while (0 < n) {
      b  <$ dto;
      bs <- rcons bs b;
      n  <- n - 1;
    }
    return bs;
  }

  proc f(x, n) = {
    var ys, zs, aout;

    aout <- [];
    if (valid x) {
      ys     <- odflt [] mp.[x];
      zs     <@ choose (max 0 (n - size ys));
      mp.[x] <- ys ++ zs;
      aout   <- take n (oget mp.[x]);
    }

    return aout;
  }
}.
*)
