require import Option Real FSet NewFMap Distr.
require import Dexcepted.
require (*..*) RP.

type D.
op d: D distr.

clone include RP with
  type from <- D,
  type to   <- D.

module P : RP, RP_ = {
  var m : (D, D) fmap
  var mi: (D, D) fmap

  proc init() = { m = map0; mi = map0; }

  proc f(x) = {
    var y;

    if (!mem (dom m) x) {
      y      <$ d \ (mem (rng m));
      m.[x]  <- y;
      mi.[y] <- x;
    }
    return oget m.[x];
  }

  proc fi(x) = {
    var y;

    if (!mem (dom mi) x) {
      y      <$ d \ (mem (rng mi));
      mi.[x] <- y;
      m.[y]  <- x;
    }
    return oget mi.[x];
  }
}.

lemma P_init_ll: islossless P.init.
proof. by proc; auto. qed.

lemma P_f_ll: is_lossless d => support d = predT => islossless P.f.
proof.
move=> d_ll d_fu; proc; if=> //=; auto=> &m /= x_notin_m.
have h:= endo_dom_rng P.m{m} _; first by exists x{m}.
apply/dexcepted_ll=> //; smt. (* needs help *)
qed.

lemma P_fi_ll: is_lossless d => support d = predT => islossless P.fi.
proof.
move=> d_ll d_fu; proc; if=> //=; auto=> &m /= x_notin_m.
have h:= endo_dom_rng P.mi{m} _; first by exists x{m}.
apply/dexcepted_ll=> //; smt. (* needs help *)
qed.
