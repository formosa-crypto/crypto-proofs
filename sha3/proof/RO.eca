require import NewFMap.
(* TODO move this in NewFMap *)
lemma dom_set (m:('a,'b) fmap) a b : dom m.[a<-b] = dom m `|` fset1 a.
proof. by apply fsetP=> x;smt. qed.

type from, to.

module type RO = {
  proc init()     : unit
  proc oracle(x : from): to
}.

module type RO_ = {
  proc oracle(x : from): to
}.

module type Distinguisher(G : RO_) = {
  proc distinguish(): bool
}.

module IND(G:RO, D:Distinguisher) = {
  proc main(): bool = {
    var b;

         G.init();
    b <@ D(G).distinguish();
    return b;
  }  
}.

abstract theory Ideal.

  op sample : from -> to distr.

  module RO = {
    var m : (from, to) fmap
  
    proc init() : unit = {
      m <- map0;
    }
  
    proc oracle(x : from) : to = {
      var rd;
      rd <$ sample x;
      if (! mem (dom m) x) m.[x] <- rd;
      return oget m.[x];
    }
  }.

  section LL. 

    axiom sample_ll : forall x, Distr.weight (sample x) = 1%r.

    lemma oracle_ll : phoare[RO.oracle : true ==> true] = 1%r. 
    proof. proc;auto;progress;apply sample_ll. qed.
  
  end section LL.
 
end Ideal.


abstract theory GenIdeal.

  clone include Ideal. 
  axiom sample_ll : forall x, Distr.weight (sample x) = 1%r.

  op RO_dom : from fset.

  module ERO = {
    proc sample() = {
      var work;
      work <- RO_dom;
      while (work <> fset0) {
        RO.oracle(pick work);
        work = work `\` fset1 (pick work);
      }
    }

    proc init() = {
      RO.m <- map0;
      sample();
    }

    proc oracle = RO.oracle
  }.

  module IND_S(D:Distinguisher) = {
    proc main(): bool = {
      var b;
      RO.init();
      b <@ D(RO).distinguish();
      ERO.sample();
      return b;
    }  
  }.

  section EAGER.

    local lemma eager_query:
       eager [ERO.sample(); , RO.oracle ~ ERO.oracle, ERO.sample(); :
                 ={x,RO.m} ==> ={res,RO.m} ].
    proof.
      eager proc.
      inline ERO.sample;swap{2} 4 -3.
      seq 1 1: (={x,work,RO.m});first by sim.
      wp;case ((mem (dom RO.m) x){1}).
      + rnd{1}.
        alias{1} 1 mx = oget RO.m.[x].
        while (={work,RO.m} /\ (RO.m.[x] = Some mx){1}). 
        + by inline *;auto;progress;smt.
        auto;progress [- split]; rewrite sample_ll H /=;smt. 
      case ((!mem work x){1}).
      + swap{1} 2 -1;while (={work,x} /\ eq_except RO.m{1} RO.m{2} (fset1 x{1}) /\ 
                             (!mem work x){1} /\ (RO.m.[x] = Some rd){2} /\ (!mem (dom RO.m) x){1}). 
        + inline *;auto;progress [-split].
          cut -> : mem (dom RO.m{2}) (pick work{2}) = mem (dom RO.m{1}) (pick work{2}) by rewrite !in_dom;smt.
          smt. 
        auto;progress [-split];rewrite !getP_eq;smt. 
      inline RO.oracle.
      transitivity{1} { rd <$ sample x;
                        while (work <> fset0) {
                          x0  <- pick work;
                          rd0 <$ sample x0;
                          if (!mem (dom RO.m) x0)
                            RO.m.[x0] <- if x0 = x then rd else rd0;
                          work <- work `\` fset1 (pick work);
                        } }
         (={x,work,RO.m} ==> ={x,RO.m})
         ((={x,work,RO.m} /\ mem work{1} x{1}) /\ ! mem (dom RO.m{2}) x{2} ==>
               ={x,RO.m} /\ (result = oget RO.m.[x]){2} /\ mem (dom RO.m{1}) x{1}) => //.
      + by move=> &1 &2 H; exists RO.m{2}, x{2}, work{2}; generalize H.
      + transitivity{1} { while (work <> fset0) {
                            x0  <- pick work;
                            rd0 <$ sample x0;
                            if (!mem (dom RO.m) x0) RO.m.[x0] <- rd0;
                            work <- work `\` fset1 (pick work);
                          }
                          rd <$ sample x; }
            (={x,work,RO.m} ==> ={x,RO.m})
            (={x,work,RO.m} ==> ={x,RO.m})=> //.
        + by move=> &1 &2 H; exists RO.m{2}, x{2}, work{2}; generalize H.
        + by sim; rnd{2}; sim : (={x,IND_Eager.H.m}); smt.
        symmetry; eager while (H: rd <$ sample x; ~ rd <$ sample x; : ={x} ==> ={rd})=> //; sim. 
        swap{2} 5 -4; swap [2..3] -1; case ((x = pick work){1}).
        + by wp; rnd{2}; rnd; rnd{1}; wp; skip; smt.
        by auto; smt.
      + while (={x, work} /\
               (!mem work x => mem (dom RO.m) x){1} /\
                RO.m.[x]{2} = Some rd{1} /\
                if (mem (dom RO.m) x){1} then ={RO.m}
                else eq_except RO.m{1} RO.m{2} (fset1 x{1})).
        + auto;progress; 1..9,12:smt.
          + case ((pick work = x){2})=> pick_x; last smt.
            subst x{2}; generalize H7 H1; rewrite -neqF /eq_except=> -> /= eq_exc.
            by apply fmapP=> x0; case (pick work{2} = x0); smt.
        by auto; smt.
      by auto;progress [-split];rewrite H0 /= getP_eq;smt. 
    qed.

    equiv Eager_S (D <: Distinguisher{RO}): IND_S(D).main ~ IND(ERO,D).main: ={glob D} ==> ={res,RO.m,glob D}.
    proof.
      proc; inline ERO.init RO.init.
      seq 1 1: (={glob D, RO.m});first by wp. 
      symmetry; eager (H: ERO.sample(); ~ ERO.sample();: ={RO.m} ==> ={RO.m}): 
            (={glob D, RO.m}) => //; first by sim.
      eager proc H (={RO.m}) => //; [by apply eager_query | by sim].
    qed.

    equiv Eager (D <: Distinguisher{RO}): IND(RO,D).main ~ IND(ERO,D).main: ={glob D} ==> ={res,glob D}.
    proof.
      transitivity IND_S(D).main
          (={glob D} ==> ={res,glob D})
          (={glob D} ==> ={res,RO.m,glob D}) => //.
      + by progress;exists (glob D){2}.
      + proc;inline{2} ERO.sample.
        while{2} true (card work{2}). 
        + move=> &m1 z;wp;call (oracle_ll sample_ll);auto;smt.
        conseq (_: _ ==> ={b,glob D}) => //;[smt | by sim].
      apply (Eager_S D).
    qed.

  end section EAGER.

end GenIdeal.

abstract theory FiniteIdeal.

   clone include Ideal.
   axiom sample_ll (x : from): Distr.weight (sample x) = 1%r.

   op univ : from fset. 
   axiom univP (x:from) : mem univ x.

   module ERO = {
     proc sample() = {
       var work;
       work <- univ;
       while (work <> fset0) {
         RO.oracle(pick work);
         work = work `\` fset1 (pick work);
       }
     }

     proc init() = {
       RO.m <- map0;
       sample();
     }

     proc oracle(x:from):to = { return oget RO.m.[x]; }
  }.

  module IND_S(D:Distinguisher) = {
    proc main(): bool = {
      var b;
      RO.init();
      b <@ D(RO).distinguish();
      ERO.sample();
      return b;
    }  
  }.

  section EAGER.

    declare module D: Distinguisher { RO }.

    local clone GenIdeal as GI with 
      op sample <- sample, 
      op RO_dom <- univ
      proof sample_ll by apply sample_ll.

    local equiv ERO_main: 
      IND(GI.ERO, D).main ~ IND(ERO, D).main : ={glob D} ==> ={res, glob D} /\ GI.RO.m{1} = RO.m{2}.
    proof.
      proc.
      call (_:GI.RO.m{1} = RO.m{2} /\ dom RO.m{2} = univ).
      + proc; rcondf{1} 2;auto;progress;[ by rewrite H univP | by apply sample_ll].    
      inline *.
      while (={work} /\ GI.RO.m{1} = RO.m{2} /\ dom RO.m{2} = univ `\` work{2});auto;smt. 
    qed.

    equiv Eager_S : IND_S(D).main ~ IND(ERO,D).main: ={glob D} ==> ={res,RO.m,glob D}.
    proof.
      transitivity GI.IND_S(D).main 
          (={glob D} ==> ={res,glob D} /\ RO.m{1} = GI.RO.m{2})
          (={glob D} ==> ={res,glob D} /\ GI.RO.m{1} = RO.m{2}) => //.
      + by progress;exists (glob D){2}.
      + by sim. 
      transitivity IND(GI.ERO,D).main 
        (={glob D} ==> ={res,glob D, GI.RO.m}) 
        (={glob D} ==> ={res,glob D} /\ GI.RO.m{1} = RO.m{2}) => //.
      + by progress;exists (glob D){2}.
      + by conseq (GI.Eager_S D).
      by apply ERO_main.     
    qed.

    equiv Eager : IND(RO, D).main ~ IND(ERO,D).main: ={glob D} ==> ={res,glob D}.
    proof.
      transitivity IND(GI.RO,D).main 
          (={glob D} ==> ={res,glob D} /\ RO.m{1} = GI.RO.m{2})
          (={glob D} ==> ={res,glob D}) => //.
      + by progress;exists (glob D){2}.
      + by sim. 
      transitivity IND(GI.ERO,D).main 
        (={glob D} ==> ={res,glob D}) 
        (={glob D} ==> ={res,glob D}) => //.
      + by progress;exists (glob D){2}.
      + by conseq (GI.Eager D).
      by conseq ERO_main.
    qed.

  end section EAGER.

end FiniteIdeal.


abstract theory RestrIdeal.

  clone include Ideal.
  axiom sample_ll (x : from): Distr.weight (sample x) = 1%r.

  op test : from -> bool.
  op univ : from fset. 
  op dfl  : to.

  axiom testP x : test x <=> mem univ x. 

  module Restr (O:RO) = {
    proc init = RO.init
    proc oracle (x:from) : to = {
      var r <- dfl;
      if (test x) r <@ RO.oracle(x);
      return r;
    }
  }.

  module ERO = {
     proc sample() = {
       var work;
       work <- univ;
       while (work <> fset0) {
         RO.oracle(pick work);
         work = work `\` fset1 (pick work);
       }
     }

     proc init() = {
       RO.m <- map0;
       sample();
     }

     proc oracle(x:from):to = { 
       return (if test x then oget RO.m.[x] else dfl);
     }
  }.

  module IND_S(D:Distinguisher) = {
    proc main(): bool = {
      var b;
      RO.init();
      b <@ D(Restr(RO)).distinguish();
      ERO.sample();
      return b;
    }  
  }.

  section EAGER.

    declare module D: Distinguisher { RO }.

    local clone GenIdeal as GI with 
      op sample <- sample, 
      op RO_dom <- univ.

    local module Restr' (O:RO_) = {
      proc init() = { }
      proc oracle(x:from) = {  
        var r <- dfl;
        if (test x) r <@ O.oracle(x);
        return r;
      }
    }.  
        
    local module RD (O:RO_) = D(Restr'(O)).  

    local equiv ERO_main: 
      IND(GI.ERO, RD).main ~ IND(ERO, D).main : ={glob D} ==> ={res, glob D} /\ GI.RO.m{1} = RO.m{2}.
    proof.
      proc.
      call (_:GI.RO.m{1} = RO.m{2} /\ dom RO.m{2} = univ).
      + proc. 
        case (test x{1});[ rcondt{1} 2 | rcondf{1} 2];auto;last smt ml=0.
        by inline *;rcondf{1} 4;auto;progress;2:(by apply sample_ll);rewrite ?H0 ?H -?testP. 
      inline *.
      while (={work} /\ GI.RO.m{1} = RO.m{2} /\ dom RO.m{2} `|` work{2} = univ);auto;1:progress; smt.
    qed.

    equiv Eager_S : IND_S(D).main ~ IND(ERO,D).main: ={glob D} ==> ={res,RO.m,glob D}.
    proof.
      transitivity GI.IND_S(RD).main 
          (={glob D} ==> ={res,glob D} /\ RO.m{1} = GI.RO.m{2})
          (={glob D} ==> ={res,glob D} /\ GI.RO.m{1} = RO.m{2}) => //.
      + by progress;exists (glob D){2}.
      + by sim. 
      transitivity IND(GI.ERO,RD).main 
        (={glob D} ==> ={res,glob D, GI.RO.m}) 
        (={glob D} ==> ={res,glob D} /\ GI.RO.m{1} = RO.m{2}) => //.
      + by progress;exists (glob D){2}.
      + by conseq (GI.Eager_S RD).
      by apply ERO_main.     
    qed.

    equiv Eager : IND(Restr(RO), D).main ~ IND(ERO,D).main: ={glob D} ==> ={res,glob D}.
    proof.
      transitivity IND(GI.RO,RD).main 
          (={glob D} ==> ={res,glob D} /\ RO.m{1} = GI.RO.m{2})
          (={glob D} ==> ={res,glob D}) => //.
      + by progress;exists (glob D){2}.
      + by sim. 
      transitivity IND(GI.ERO,RD).main 
        (={glob D} ==> ={res,glob D}) 
        (={glob D} ==> ={res,glob D}) => //.
      + by progress;exists (glob D){2}.
      + by conseq (GI.Eager RD).
      by conseq ERO_main.
    qed.

  end section EAGER.

end RestrIdeal.