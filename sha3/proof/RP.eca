(*************************- Random Permutation -*************************)

require import Option Real FSet NewFMap Distr.
require import Dexcepted StdOrder. import RealOrder.
require import Ring StdRing. import RField.

type t.
op dt : t distr.

module type RP = {
  proc init() : unit
  proc f(x : t) : t
  proc fi(x : t) : t
}.

module type DRP = {
  proc f(x : t) : t
  proc fi(x : t) : t
}.

module P : RP, DRP = {
  var m : (t, t) fmap
  var mi : (t, t) fmap

  proc init() = { m = map0; mi = map0; }

  proc f(x) = {
    var y;

    if (! mem (dom m) x) {
      y      <$ dt \ (mem (rng m));
      m.[x]  <- y;
      mi.[y] <- x;
    }
    return oget m.[x];
  }

  proc fi(x) = {
    var y;

    if (! mem (dom mi) x) {
      y      <$ dt \ (mem (rng mi));
      mi.[x] <- y;
      m.[y]  <- x;
    }
    return oget mi.[x];
  }
}.

lemma P_init_ll: islossless P.init.
proof. by proc; auto. qed.

(* maybe a useful standard lemma? *)

lemma mu_except ['a] (d : 'a distr, y : 'a, P : 'a -> bool) :
  is_lossless d => support d = predT => ! P y => mu d P < 1%r.
proof.
move=> d_ll supp_d_all notP_y.
have -> : mu d P = 1%r - mu d (predC P)
  by rewrite -d_ll (mu_split d predT P) mu_not mu_and #ring.
rewrite ltr_subl_addl addrC -(ltr_add2l (-1%r)) addrA /=.
rewrite (ltr_le_trans (mu d (pred1 y))) 1:witness_support.
exists y; split=> //; by rewrite -/(support d y) supp_d_all.
by rewrite mu_sub=> z @/pred1.
qed.

lemma P_f_ll: is_lossless dt => support dt = predT => islossless P.f.
proof.
move=> d_ll d_fu; proc; if=> //=; auto=> &m /= x_notin_m.
have [y not_mem_y_rng_m] := endo_dom_rng P.m{m} _; first by exists x{m}.
by apply /dexcepted_ll /(mu_except dt y (mem (rng P.m{m}))).
qed.

lemma P_fi_ll: is_lossless dt => support dt = predT => islossless P.fi.
proof.
move=> d_ll d_fu; proc; if=> //=; auto=> &m /= x_notin_m.
have [y not_mem_y_rng_mi] := endo_dom_rng P.mi{m} _; first by exists x{m}.
by apply /dexcepted_ll /(mu_except dt y (mem (rng P.mi{m}))).
qed.
