require import Core Logic Distr.
require import Int IntExtra Real List NewFMap FSet.
require (*--*) StdBigop.
(*---*) import StdBigop.Bigint.
require import StdOrder.
(*---*) import IntOrder.

require import NewCommon Gconcl.
(*---*) import Block DBlock Capacity DCapacity SLCommon.

(*** THEORY PARAMETERS ***)
(** Validity of Functionality Queries **)
op valid: block list -> bool.
axiom valid_spec p: valid p => p <> [].

(** Validity and Parsing/Formatting of Functionality Queries **)
op format (p : block list) (n : int) = p ++ nseq (n - 1) b0.
op parse: block list -> (block list * int).

axiom formatK bs: format (parse bs).`1 (parse bs).`2 = bs.
axiom parseK p n: 0 < n => valid p => parse (format p n) = (p,n).

lemma parse_injective: injective parse.
proof. by move=> bs1 bs2 eq_format; rewrite -formatK eq_format (@formatK bs2). qed.

lemma parse_valid p: valid p => parse p = (p,1).
proof.
move=>h;cut{1}->:p=format p 1;2:smt(parseK).
by rewrite/format/=nseq0 cats0.
qed.

(******************* Useful lemmas ******************)
lemma take_nseq (b:block) i j : take i (nseq j b) = nseq (min i j) b.
proof.
move:i;elim/natind=>//=.
+ smt(take_le0 nseq0_le).
move=>i hi0 hind.
case(i + 1 <= j)=>hi1j.
+ rewrite (take_nth b);1:smt(size_nseq).
  rewrite hind nth_nseq 1:/# //=-nseqSr/#.
rewrite take_oversize;smt(size_nseq).
qed.

lemma sumid_leq (n m p : int) : 0 <= n => m <= p => sumid n m <= sumid n p.
proof.
move=>Hn0 Hmp.
case(m<=n)=>Hmn. search BIA.big 0 (<=).
+ rewrite BIA.big_geq//.
  by apply sumr_ge0_seq=>//=;smt(mem_iota size_ge0).
rewrite(BIA.big_cat_int m n p) 1:/# //.
cut/#:0<=sumid m p.
by apply sumr_ge0_seq=>//=;smt(mem_iota size_ge0).
qed.

(*** DEFINITIONS ***)
(** Low-Level Definitions **)
require (*--*) NewCore.

clone import NewCore as Low with
  op valid bs <- let (b,s) = bs in valid b /\ 0 < s
proof * by done.

(** High-Level Definitions **)
(* Indifferentiability *)
clone import Indifferentiability as BS_Ind with
  type p     <- block * capacity,
  type f_in  <- block list,
  type f_out <- block
proof * by done.

(* BlockSponge Construction *)
module (BlockSponge : CONSTRUCTION) (P : DPRIMITIVE) : FUNCTIONALITY = {
  proc init() = {}

  proc f(p : block list) : block = {
    var (sa,sc) <- (b0,c0);
    var i <- 0;
    var (x,n) <- parse p;

    if (valid x /\ 0 < n) {
      while (i < size p) {
        (sa,sc) <@ P.f((sa +^ nth witness p i,sc));
        i <- i + 1;
      }
    }
    return sa;
  }
}.

(* Ideal Block Sponge Functionality *)
module IBlockSponge : FUNCTIONALITY = {
  var m : (block list,block) fmap

  proc init() = {
    m <- map0;
  }

  proc fill_in(x) = {
    if (!mem (dom m) x) {
      m.[x] <$ bdistr;
    }
    return oget m.[x];
  }

  proc f(x : block list) = {
    var bs <- b0;
    var i <- 1;

    var (p,n) <- parse x;
    if (valid p /\ 0 < n) {
      while (i < n) {
        fill_in(format p i);
        i <- i + 1;
      }
      bs <@ fill_in(x);
    }

    return bs;
  }
}.


(* Parametric Simulator *) 
module (LowSim (S : SIMULATOR) : Low.SIMULATOR) (F : Low.DFUNCTIONALITY) = {
  module LoF = {
    proc f(x : block list) = {
      var r <- [];
      var b <- b0;
      var i <- 1;

      if (let (p,n) = parse x in valid p /\ 0 < n)
      {
        r <@ F.f(parse x);
        b <- last b0 r;
      }
      return b;
    }
  }

  proc init = S(LoF).init
  proc f    = S(LoF).f
  proc fi   = S(LoF).fi
}.

pred INV (mc : (block list,block) fmap) (mb : (block list * int,block) fmap) =
  forall p, mc.[p] = mb.[parse p].

(* Constructed Distinguisher *)
module (HiDist (D : Low.DISTINGUISHER) : DISTINGUISHER)
           (F : DFUNCTIONALITY) (P : DPRIMITIVE) = {
  var c : int
  module HiF = {
    proc f(p : block list, n : int) = {
      var r <- [];
      var b <- b0;
      var i <- 1;
    
      if (valid p /\ 0 < n /\ c + sumid (size p) (size p + n) <= max_size) {
        while(i <= n) {
          b <@ F.f(format p i);
          c <- c + size p + i - 1;
          r <- rcons r b;
          i <- i + 1;
        }
      }
      return r;
    }
  }
  module C = {
    proc f (x) = {
      var y <- (b0,c0);
      if (c + 1 <= max_size) {
        c <- c + 1;
        y <@ P.f(x);
      }
      return y;
    }
    proc fi (x) = {
      var y <- (b0,c0);
      if (c + 1 <= max_size) {
        c <- c + 1;
        y <@ P.fi(x);
      }
      return y;
    }
  }

  proc distinguish() = {
    var a;
    c <- 0;
    a <@ D(HiF,C).distinguish();
    return a;
  }
}.

module DFCn (F : Low.FUNCTIONALITY) : Low.FUNCTIONALITY = {
  proc init = F.init
  proc f(p : block list, n : int) = {
    var r : block list <- [];
    if(C.c + sumid (size p) (size p + n) <= max_size /\ valid p /\ 0 < n) {
      r <@ F.f(p,n);
      C.c <- C.c + sumid (size p) (size p + n);
    }
    return r;
  }
}.

module DPC (P : PRIMITIVE) : PRIMITIVE = {
  proc init () = {
    C.init();
    P.init();
  }
  proc f(x) = {
    var y <- (b0,c0);
    if (C.c + 1 <= max_size) {
      y <@ P.f(x);
      C.c <- C.c + 1;
    }
    return y;
  }
  proc fi(x) = {
    var y <- (b0,c0);
    if (C.c + 1 <= max_size) {
      y <@ P.fi(x);
      C.c <- C.c + 1;
    }
    return y;
  }
}.

module DFC1 (F : FUNCTIONALITY) : FUNCTIONALITY = {
  proc init = F.init
  proc f(x : block list) = {
    var b : block <- b0;
    if (C.c + size x <= max_size) {
      C.c <- C.c + size x;
      b <@ F.f(x);
    }
    return b;
  }
}.

(*** PROOF
     forall P D S,
         HiDist(D)^{BlockSponge(P),P} ~ HiDist(D)^{IBlockSponge,S(IBlockSponge)}
       => D^{Core(P),P} ~ D^{ICore,LowSim(S,ICore)} ***)
section PROOF.
  declare module P : PRIMITIVE         { Low.ICORE, IBlockSponge, HiDist, C }.
  declare module S : SIMULATOR         { Low.ICORE, IBlockSponge, HiDist, C, P }.
  declare module D : Low.DISTINGUISHER { Low.ICORE, IBlockSponge, HiDist, C, P, S }.



  (* FIXME : is this the eager we want ? *)
  local module EagerCORE (P : Low.PRIMITIVE) = {
    var order : block list
    var capa  : capacity
    var blo   : block
    proc init() = {
      order <- [];
      capa <- c0;
      blo <- b0;
      CORE(P).init();
    }
    proc f (p : block list, n : int) = {
      var r  : block list;
      var i  : int;

      (blo,capa) <- (b0,c0);
      r <- [];
      i <- 0;
      if (valid p /\ 0 < n) {
        while(i < size p) {
          (blo,capa) <@ P.f(blo +^ nth witness p i, capa);
          i <- i + 1;
        }
        i <- 1;
        order <- p;
        r <- rcons r blo;
        while (i < n) {
          order <- rcons order b0;
          (blo,capa) <@ P.f(blo,capa);
          r <- rcons r blo;
          i <- i + 1;
        }
      }
      return r;
    }
    proc ewhile() = {
      var i : int <- 0;
      blo <- b0;
      capa <- c0;
      while(i < size order) {
        (blo,capa) <@ P.f(blo +^ nth witness order i,capa);
        i <- i + 1;
      } 
    }
  }.

  local module EagCORE (P : Low.PRIMITIVE) : Low.FUNCTIONALITY = {
    proc init = EagerCORE(P).init


    proc f (p : block list, n : int) = {
      var r  : block list;
      var i  : int;

      (EagerCORE.blo,EagerCORE.capa) <- (b0,c0);
      r <- [];
      i <- 0;
      if (valid p /\ 0 < n) {
        i <- 1;
        EagerCORE.order <- p;
        EagerCORE(P).ewhile();
        r <- rcons r EagerCORE.blo;
        while (i < n) {
          EagerCORE.order <- rcons EagerCORE.order b0;
          EagerCORE(P).ewhile();
          r <- rcons r EagerCORE.blo;
          i <- i + 1;
        }
      }
      return r;
    }
  }.


  equiv core_blocksponge :
      Low.Indif(DFCn(CORE(P)),DPC(P),D).main ~
      Indif(DFC1(BlockSponge(P)),DPC(P),HiDist(D)).main :
      ={glob D, glob P} ==> ={res, C.c} /\ ={c}(C,HiDist).
  proof.
  transitivity Low.Indif(DFCn(EagerCORE(P)),DPC(P),D).main
    (={glob D, glob P} ==> ={res, C.c})
    (={glob D, glob P} ==> ={res, C.c} /\ ={c}(C,HiDist));progress;1:rewrite/#.
  + proc=>/=;call (_: ={glob P, C.c}); first 2 by sim.
    + proc=> /=;inline*;sp;if;auto;sp;if;auto;sim.
      conseq(:_==> sc{1} = EagerCORE.capa{2} /\ sa{1} = EagerCORE.blo{2}
                /\ ={glob P});progress.
      by while( ={i,p0,glob P} /\ sc{1} = EagerCORE.capa{2}
          /\ sa{1} = EagerCORE.blo{2});auto;call(:true);auto.

    by inline*;auto;call(:true);auto. 

  transitivity Low.Indif(DFCn(EagCORE(P)),DPC(P),D).main
    (={glob D, glob P} ==> ={res, C.c})
    (={glob D, glob P} ==> ={res, C.c} /\ ={c}(C,HiDist));progress;1:rewrite/#.
  + proc.
    call (_: ={glob P, C.c}); first 2 by sim.
    + proc=> /=; sp. 
      if=>//=;auto;inline{1}1;inline{2}1;sp;if;auto;swap{1}3-2;swap{2}2.
      conseq(:_==> ={r0,glob P});progress;sp.
      replace{1} { while ; rest } by {
          EagerCORE(P).ewhile();
          rest;
        }
        (={glob P, EagerCORE.order, r0, n0} /\ i{1} = 0
          /\ (EagerCORE.blo,EagerCORE.capa,EagerCORE.order){1} = (b0,c0,p0{1})
          ==> ={r0, glob P})
        (={glob P,glob EagerCORE, n0,r0} ==> ={r0, glob P});
        progress;1:rewrite/#;first inline*;sim;auto;progress.
    
      (* eager part *)
      admit.

    by inline*;auto;call(:true);auto.


  + proc;inline{2}3;wp;call (_: ={glob P, C.c} /\ ={c}(C,HiDist)). 
    + by proc;inline*;sp;auto;if;auto;sp;rcondt{2}1;auto;call(:true);auto.
    + by proc;inline*;sp;auto;if;auto;sp;rcondt{2}1;auto;call(:true);auto.
    proc;inline*;sp;auto.
    if;1:progress=>/#;sp;wp.
    rcondt{1}1;1:auto=>/#;sp.
    rcondt{2}1;1:auto=>/#;sp.
    rcondt{2}1;1:auto;progress.
    + rewrite size_cat nseq0/=. 
      cut/#:size p{hr} <= sumid (size p{hr}) (size p{hr} + n{hr}).
      rewrite  BIA.big_ltn 1:/# /=. 
      cut/#:=sumr_ge0_seq predT(fun n=>n)(range (size p{hr} + 1) (size p{hr} + n{hr})) _. 
      smt(mem_iota size_ge0).
    sp;rcondt{2}1;1:(auto;smt(parseK formatK));sp.
    conseq(:_==> r0{1} = r{2} /\ ={glob P} /\ C.c{2} = HiDist.c{2}
          /\ i{1} = n{1}
          /\ C.c{1} + sumid (size p{1}) (size p{1} + i{1}) = C.c{2});progress.
    while(   r0{1} = r{2} /\ ={glob P,p} /\ C.c{2} = HiDist.c{2}
          /\ C.c{1} + sumid (size p{1}) (size p{1} + n{2}) <= max_size
          /\ C.c{1} + sumid (size p{1}) (size p{1} + i{1}) = C.c{2}
          /\ (n0, EagerCORE.blo, EagerCORE.capa){1} = (n, sa, sc){2}
          /\ EagerCORE.order{1} = format p{2} i{1}
          /\ i{2} = i{1} + 1
          /\ 0 < i{1} <= n0{1}
          /\ valid p{2}).
    + sp;rcondt{2}1;auto;progress.
      + cut/#:sumid (size p{hr}) (size p{hr} + i{m}) + 
              size (format p{hr} (i{m} + 1)) <=
              sumid (size p{hr}) (size p{hr} + n{hr}).
        rewrite size_cat size_nseq-addzA/=/max H0/=.
        cut/=<-:=BIA.big_int_recr (size p{hr} + i{m})(size p{hr})(fun n=>n)_;1:rewrite/#. 
        smt(sumid_leq size_ge0).
      swap{2}5;sp;auto.
      rcondt{2}1;1:(auto;smt(formatK parseK)).
      conseq(:_==> ={glob P} /\
          (EagerCORE.blo, EagerCORE.capa){1} = (sa, sc){2});progress.
      + rewrite size_cat-(addzA _ 1)/=size_nseq/max H1/=/#.
      + rewrite size_cat-(addzA _ 1)/=size_nseq/max H1/=. search BIA.big (+) 1.
        by cut/#:=BIA.big_int_recr_cond(size p{2} + i{1})(size p{2})predT(fun n=>n)_;rewrite/#.
      + by rewrite rcons_cat-nseqSr 1:/# -addzA/=/format-addzA/=.
      + rewrite/#.
      + rewrite/#.
      + rewrite/#.
      while(={glob P} /\
          (i1,EagerCORE.order,EagerCORE.blo,EagerCORE.capa){1} = (i0,p0,sa,sc){2});auto.
      + by call(:true);auto.
      progress.
      + by rewrite rcons_cat-nseqSr 1:/# -addzA/=/format-addzA/=.
      + by move:H6;rewrite rcons_cat-nseqSr 1:/# -addzA/=/format-addzA/=.
      by move:H6;rewrite rcons_cat-nseqSr 1:/# -addzA/=/format-addzA/=.
    wp;conseq(:_==> ={glob P} /\
          (EagerCORE.blo, EagerCORE.capa){1} = (sa, sc){2});progress.
    + by rewrite size_cat nseq0/#.
    + by rewrite size_cat nseq0/= BIA.big_int1.
    + by rewrite/format nseq0 cats0/#.
    + rewrite/#.
    + rewrite/#.
    + rewrite/#.
    + rewrite/#.
    while(={glob P} /\
        (i0,EagerCORE.order,EagerCORE.blo,EagerCORE.capa){1} = (i0,p0,sa,sc){2});auto.
    + by call(:true);auto.
    progress.
    + by rewrite/format nseq0 cats0/#.
    + by rewrite size_cat nseq0/#.
    + by move:H3;rewrite size_cat nseq0/#.
    by auto;progress.
  by inline*;auto;call(:true);auto.
  qed.
  
  equiv icore_iblocksponge :
      Low.Indif(DFCn(ICORE),DPC(LowSim(S,ICORE)),D).main ~
      Indif(DFC1(IBlockSponge),DPC(S(IBlockSponge)),HiDist(D)).main :
      ={glob S, glob D} ==> ={res, C.c} /\ ={c}(C,HiDist).
  proof.
  proc;inline{2}3;wp;call (_:
      ={glob S,C.c} /\ ={c}(C,HiDist)
  /\ INV IBlockSponge.m{2} ICORE.m{1}).
  + proc;inline*;sp;if;auto.
    swap{2}3;sp;rcondt{2}1;auto.
    call(: ={C.c} /\ ={c}(C,HiDist) /\ INV IBlockSponge.m{2} ICORE.m{1})=>/=;auto.
    proc=> /=; sp;if;1:progress=>/#;inline*;sp;auto.
    rcondt{1}1;1:auto=>/#.
    wp.
    splitwhile{1}1:i0<n.
    rcondt{1}2;progress.
    + by while(i0<=n);2:auto=>/#;sp;if;auto=>/#.
    rcondf{1}8;progress.
    + wp;seq 1:(i0=n);2:(sp;if;auto=>/#).
      by while(i0<=n);2:auto=>/#;sp;if;auto=>/#.
    wp. 
    conseq(:_==> INV IBlockSponge.m{2} ICORE.m{1} /\
      ICORE.m{1}.[(p0{1}, n0{1})] = IBlockSponge.m{2}.[x1{2}]);progress.
    + smt(last_rcons).
    seq 3 2 : (INV IBlockSponge.m{2} ICORE.m{1} /\ 
      parse x1{2} = (p0{1}, n0{1}) /\ valid p0{1} /\ 0 < n0{1});
      last if;1:smt(in_dom);auto;smt(getP formatK parseK).
    wp;conseq(:_==> INV IBlockSponge.m{2} ICORE.m{1} /\ i0{1} = n{1});1:progress=>/#.
    while( ={n,p} /\ INV IBlockSponge.m{2} ICORE.m{1}
        /\ i0{1} = i{2} /\ valid p{1} /\ 0 < n{2} /\ 0 < i0{1} <= n{1}).
    + sp;if;auto;smt(in_dom formatK parseK getP).
    by auto;smt(in_dom formatK parseK getP).
   
  + proc;sp;if;auto;swap{2}1;inline{2}1;sp;rcondt{2}1;auto.
    call(: ={C.c} /\  C.c{1} = HiDist.c{2}/\ INV IBlockSponge.m{2} ICORE.m{1})=> //.
    proc=> /=; sp;if;1:progress=>/#;inline*;sp;auto.
    rcondt{1}1;1:auto=>/#.
    wp.
    splitwhile{1}1:i0<n.
    rcondt{1}2;progress.
    + by while(i0<=n);2:auto=>/#;sp;if;auto=>/#.
    rcondf{1}8;progress.
    + wp;seq 1:(i0=n);2:(sp;if;auto=>/#).
      by while(i0<=n);2:auto=>/#;sp;if;auto=>/#.
    wp. 
    conseq(:_==> INV IBlockSponge.m{2} ICORE.m{1} /\
      ICORE.m{1}.[(p0{1}, n0{1})] = IBlockSponge.m{2}.[x1{2}]);progress.
    + smt(last_rcons).
    seq 3 2 : (INV IBlockSponge.m{2} ICORE.m{1} /\ 
      parse x1{2} = (p0{1}, n0{1}) /\ valid p0{1} /\ 0 < n0{1});
      last if;1:smt(in_dom);auto;smt(getP formatK parseK).
    wp;conseq(:_==> INV IBlockSponge.m{2} ICORE.m{1} /\ i0{1} = n{1});1:progress=>/#.
    while( ={n,p} /\ INV IBlockSponge.m{2} ICORE.m{1}
        /\ i0{1} = i{2} /\ valid p{1} /\ 0 < n{2} /\ 0 < i0{1} <= n{1}).
    + sp;if;auto;smt(in_dom formatK parseK getP).
    by auto;smt(in_dom formatK parseK getP).

  + proc=> /=; sp;if;1:progress=>/#;inline*;sp;auto.
    rcondt{1}1;1:auto=>/#;wp.
    conseq(:_==> INV IBlockSponge.m{2} ICORE.m{1}
              /\ C.c{1} + sumid (size p{1}) (size p{1} + n{1}) =  C.c{2}
              /\ HiDist.c{2} = C.c{2} /\ r0{1} = r{2});progress.
    while( INV IBlockSponge.m{2} ICORE.m{1}
        /\ ={i,p,n} /\ n0{1} = n{2} /\ p0{1} = p{1}
        /\ valid p{1} /\ 0 < n{1} /\ 0 < i{1} <= n0{1} + 1
        /\ C.c{1} + sumid (size p{1}) (size (format p{1} i{1})) =  C.c{2}
        /\ C.c{1} + sumid (size p{1}) (size p{1} + n{1}) <= max_size
        /\ (forall j, 0 < j < i{1} => 
              format p{2} j \in dom IBlockSponge.m{2})
        /\ HiDist.c{2} = C.c{2} /\ r0{1} = r{2});last first.
    + auto;progress.
      + rewrite/#.
      + by rewrite size_cat nseq0/= BIA.big_geq/=. 
      + smt(in_dom).
      by rewrite size_cat size_nseq max_ler /#.
    sp.
    rcondt{2}1;1:auto;progress.
    + rewrite-addzA. 
      cut/=<-:=BIA.big_int_recr_cond(size (format p{hr} i{hr}))(size p{hr})predT(fun n=>n)_.
      + by rewrite size_cat size_nseq max_ler/#.
      cut/#:=sumid_leq(size p{hr})(size (format p{hr} i{hr}) + 1)(size p{hr} + n{hr})_ _;1:smt(size_ge0).
      by rewrite size_cat size_nseq max_ler/#.
    swap{2}1 7;sp.
    wp=>/=.
    conseq(:_==> INV IBlockSponge.m{2} ICORE.m{1}
              /\ (forall (j : int),
                   0 < j < i{1} + 1 => format p{2} j \in dom IBlockSponge.m{2})
              /\ oget ICORE.m{1}.[(p1{1}, n1{1})] = bs{2});progress.
    + rewrite/#.
    + rewrite/#.
    + rewrite -addzA;congr=>//. 
      rewrite 2!size_cat-addzA/=2!size_nseq{1}/max H3/=max_ler 1:/#.
      cut/#:=BIA.big_int_recr_cond(size p{2} + (i{2} -1))(size p{2})predT(fun n=>n)_;rewrite/#.
    + rewrite -4!addzA;congr=>//;congr. 
      by rewrite size_cat/=size_nseq max_ler 1:/#.
    rcondt{2}1;1:(auto;smt(parseK formatK)).
    alias{2}1 m = IBlockSponge.m;sp;wp=>/=;swap{2}2-1;sp.
    if{1};2:rcondf{2}2;1:rcondt{2}2;progress.
    + while(!(format p0 n0) \in dom IBlockSponge.m /\ 0 < i0 );auto.
      + sp;if;auto;progress. 
        + by rewrite dom_set in_fsetU1 H/=/format;smt(catsI size_nseq).
        + by rewrite/#.
        + by rewrite/#.
        smt(in_dom formatK parseK).
      rnd=>//=.
      conseq(:_==> INV m{2} ICORE.m{1} /\ IBlockSponge.m{2} = m{2});progress.
      + smt(getP formatK parseK in_dom).
      + smt(getP formatK parseK in_dom).
      + smt(getP formatK parseK in_dom).
      conseq(:_==> IBlockSponge.m{2} = m{2});progress.
      while{2}(IBlockSponge.m{2} = m{2} /\ 0 < i0{2} /\ (forall (j : int),
         0 < j < n0{2} => format p0{2} j \in dom m{2}))(n0{2}-i0{2});auto.
      + sp;rcondf 1;auto=>/#.
      smt(parseK formatK).
    + conseq(:_==> IBlockSponge.m = m);1:smt(in_dom parseK formatK).
      while(IBlockSponge.m = m /\ 0 < i0 /\ (forall (j : int),
         0 < j < n0 => format p0 j \in dom m));auto.
      + sp;rcondf 1;auto=>/#.
      smt(parseK formatK).
    + conseq(:_==> IBlockSponge.m{2} = m{2});1:smt(in_dom parseK formatK).
      while{2}(IBlockSponge.m{2} = m{2} /\ 0 < i0{2} /\ (forall (j : int),
         0 < j < n0{2} => format p0{2} j \in dom m{2}))(n0{2}-i0{2});auto.
      + sp;rcondf 1;auto=>/#.
      smt(parseK formatK).

  by inline*;auto;call(:true);auto;smt(in_dom dom0 in_fset0).
  qed.



end section PROOF.
