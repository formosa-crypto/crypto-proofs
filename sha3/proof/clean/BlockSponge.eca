require import Core Logic Distr.
require import Int IntExtra Real List NewFMap FSet.
require import StdOrder.
(*---*) import IntOrder.

require import NewCommon.
(*---*) import Block DBlock Capacity DCapacity.

(*** THEORY PARAMETERS ***)
(** Validity of Functionality Queries **)
op valid: block list -> bool.
axiom valid_spec p: valid p => p <> [].

(** Validity and Parsing/Formatting of Functionality Queries **)
op format (p : block list) (n : int) = p ++ nseq (n - 1) b0.
op parse: block list -> (block list * int).

axiom formatK bs: format (parse bs).`1 (parse bs).`2 = bs.
axiom parseK p n: 0 < n => valid p => parse (format p n) = (p,n).

lemma parse_injective: injective parse.
proof. by move=> bs1 bs2 eq_format; rewrite -formatK eq_format (@formatK bs2). qed.

lemma parse_valid p: valid p => parse p = (p,1).
proof.
move=>h;cut{1}->:p=format p 1;2:smt(parseK).
by rewrite/format/=nseq0 cats0.
qed.

(******************* Useful lemmas ******************)
lemma take_nseq (b:block) i j : take i (nseq j b) = nseq (min i j) b.
proof.
move:i;elim/natind=>//=.
+ smt(take_le0 nseq0_le).
move=>i hi0 hind.
case(i + 1 <= j)=>hi1j.
+ rewrite (take_nth b);1:smt(size_nseq).
  rewrite hind nth_nseq 1:/# //=-nseqSr/#.
rewrite take_oversize;smt(size_nseq).
qed.


(*** DEFINITIONS ***)
(** Low-Level Definitions **)
require (*--*) NewCore.

clone import NewCore as Low with
  op valid bs <- let (b,s) = bs in valid b /\ 0 < s
proof * by done.

(** High-Level Definitions **)
(* Indifferentiability *)
clone import Indifferentiability as BS_Ind with
  type p     <- block * capacity,
  type f_in  <- block list,
  type f_out <- block
proof * by done.

(* BlockSponge Construction *)
module (BlockSponge : CONSTRUCTION) (P : DPRIMITIVE) : FUNCTIONALITY = {
  proc init() = {}

  proc f(p : block list) : block = {
    var (sa,sc) <- (b0,c0);
    var i <- 0;
    var (x,n) <- parse p;

    if (valid x /\ 0 < n) {
      while (i < size p) {
        (sa,sc) <@ P.f((sa +^ nth witness p i,sc));
        i <- i + 1;
      }
    }
    return sa;
  }
}.

(* Ideal Block Sponge Functionality *)
module IBlockSponge : FUNCTIONALITY = {
  var m : (block list,block) fmap

  proc init() = {
    m <- map0;
  }

  proc fill_in(x) = {
    if (!mem (dom m) x) {
      m.[x] <$ bdistr;
    }
    return oget m.[x];
  }

  proc f(x : block list) = {
    var bs <- b0;
    var i <- 0;

    var (p,n) <- parse x;
    if (valid p /\ 0 < n) {
      while (i < n) {
        fill_in(take (size p + i) x);
        i <- i + 1;
      }
      bs <@ fill_in(x);
    }

    return bs;
  }
}.


(* Parametric Simulator *) 
module (HiSim (S : Low.SIMULATOR) : SIMULATOR) (F : DFUNCTIONALITY) = {
  module LoF = {
    proc f(p : block list, n : int): block list = {
      var r <- [];
      var b;
      var i <- 1;

      if (valid p /\ 0 < n)
      {
        while (i <= n) {
          b <@ F.f(format p i);
          r <- rcons r b;
          i <- i + 1;
        }
        
      }
      return r;
    }
  }

  proc init = S(LoF).init
  proc f    = S(LoF).f
  proc fi   = S(LoF).fi
}.

pred INV (mc : (block list,block) fmap) (mb : (block list * int,block) fmap) =
  forall p, mc.[p] = mb.[parse p].

(* Constructed Distinguisher *)
module (LoDist (D : DISTINGUISHER) : Low.DISTINGUISHER)
           (F : Low.DFUNCTIONALITY) (P : Low.DPRIMITIVE) = {
  module HiF = {
    proc f(p : block list) = {
      var r <- [];
      var b <- b0;
      var x,n;
    

      (x,n) <- parse p;

      if (valid x /\ 0 < n) {
        r <@ F.f(x,n);
        b <- last b0 r;
      }
      return b;
    }
  }

  proc distinguish = D(HiF,P).distinguish
}.


(*** PROOF
     forall P D S,
          LoDist(D)^{Core(P),P} ~ LoDist(D)^{ICore,S(ICore)}
       => D^{BlockSponge(P),P} ~ D^{IBlockSponge,HiSim(S)(IBlockSponge)} ***)
section PROOF.
  declare module P : PRIMITIVE     { Low.ICORE, IBlockSponge, HiSim }.
  declare module S : Low.SIMULATOR { Low.ICORE, IBlockSponge, HiSim, P }.
  declare module D : DISTINGUISHER { Low.ICORE, IBlockSponge, HiSim, P, S }.

  lemma LiftInd &m:
    `| Pr[Low.Indif(CORE(P),P,LoDist(D)).main() @ &m: res]
       - Pr[Low.Indif(ICORE,S(ICORE),LoDist(D)).main() @ &m: res] |
    = `| Pr[Indif(BlockSponge(P),P,D).main() @ &m: res]
         - Pr[Indif(IBlockSponge,HiSim(S,IBlockSponge),D).main() @ &m: res] |.
  proof.
  do !congr.
  + byequiv (_: ={glob D, glob P} ==> _ )=> //=; proc.
    call (_: ={glob P}); first 2 by sim.
    + proc=> /=; sp;if=>//=;1:progress=>/#.
      inline*;sp;wp.
      rcondt{1}1;progress.
      splitwhile{2}1: i < size x.
      seq 3 1:(  ={glob P,sa,sc,p}
              /\ (x,n,p0,n0){1} = (x,n,x,n){2}
              /\ valid x{1}
              /\ i{2} = size x{2}
              /\ i{1} = 1
              /\ r0{1} = [sa{1}]
              /\ (x{2}, n{2}) = parse p{2}
              /\ 0 < n{1}).
      + wp;conseq(:_==>  ={glob P,sa,sc,i,p,x,n}
              /\ i{2} = size x{2}
              /\ (x,n,p0,n0){1} = (x,n,x,n){2});progress.
        while( ={glob P,sa,sc,i,p,x,n}
            /\ (x{2}, n{2}) = parse p{2}
            /\ (p0,n0){1} = (x,n){2}
            /\ 0 <= i{2} <= size x{2} <= size p{2});auto;1:call(:true);auto;progress;2..9,-3..-1:smt(size_ge0).
        + by rewrite-(formatK p{2})-H/=/format nth_cat H3.
        + by rewrite-(formatK p{2})-H/=/format size_cat;smt(size_ge0).
        by rewrite-(formatK p{2})-H/=/format size_cat;smt(size_ge0).

      while( ={glob P,sa,sc,p}
          /\ i{1} - 1 = i{2} - size x{2}
          /\ size x{2} <= i{2} <= size p{2}
          /\ sa{1} = last b0 r0{1}
          /\ (x{2}, n{2}) = parse p{2}
          /\ (x{1}, n{1}) = parse p{1}
          /\ valid x{1}
          /\ 0 < n{1}
          /\ size p{2} = size x{2} + n{2} - 1
          /\ n0{1} = n{2}
          );auto;last first.
      + progress. 
        + by rewrite-(formatK p{2})-H0/=/format size_cat size_nseq/#. 
        + by rewrite-(formatK p{2})-H0/=/format size_cat size_nseq/#. 
        + by rewrite-(formatK p{2})-H0/=/format size_cat size_nseq/#. 
        by move:H2;rewrite-(formatK p{2})-H0/=/format size_cat size_nseq/#. 

      call(:true);auto;progress;2..5,-2..:smt(last_rcons).
      rewrite -(formatK p{2})-H2/=/format nth_cat nth_nseq_if.
      cut->//=:!i{2} < size x{2} by rewrite/#. 
      cut->//=: 0 <= i{2} - size x{2} by rewrite/#. 
      rewrite-H.
      cut->/=:i{1} - 1 < n{2} - 1 by rewrite/#.
      by rewrite BlockMonoid.addr0.
     
    by inline*;auto;call(:true);auto. 

  byequiv (_: ={glob D, glob S} ==> _)=> //=; proc.
  call (_:    ={glob S} /\ INV IBlockSponge.m{2} ICORE.m{1}).
  + proc (INV IBlockSponge.m{2} ICORE.m{1})=> //.
    proc=> /=; sp;if=> [&1 &2 [#] <*>| |] //=.
    inline{2} 1.1.
    inline*.
    while( INV IBlockSponge.m{2} ICORE.m{1}
        /\ 0 < i{1} <= n{1} + 1
        /\ ={n,p,r,i}
        /\ valid p{1}
        /\ 0 < n{1}
        /\ (forall j, 0 < j < i{1} => 
              format p{2} j \in dom IBlockSponge.m{2}));last auto=>/#. 
    rcondt{2}5;auto;1:smt(parseK). 
    swap{2}6-1;sp.
    conseq(:_==> INV IBlockSponge.m{2} ICORE.m{1} /\
            (forall j, 0 < j <= n0{1} => 
              format p0{1} j \in dom IBlockSponge.m{2}));1:smt(parseK formatK).
    conseq(: INV IBlockSponge.m{2} ICORE.m{1} /\ (forall (j : int),
              0 < j < n0{1} => format p0{1} j \in dom IBlockSponge.m{2}) /\
              (p0,n0){1} = parse x1{2} /\ (x=x1){2} /\ ={p0,n0} /\ 
              n0{1} = i{2} /\ 0 <= i0{2} < i{2}
              ==> _);1:smt(parseK formatK). 
    seq 1 1 : (INV IBlockSponge.m{2} ICORE.m{1} /\ 0 < n0{2} /\
              (forall (j : int), 0 < j <= n0{1} => 
                format p0{1} j \in dom IBlockSponge.m{2}) /\
              (p0,n0){1} = parse x1{2} /\ ={p0,n0} /\ (x=x1){2});last first. 
    + rcondf{2}1;auto;smt(parseK formatK).
    splitwhile{2}1:(i0+1<n0).
    seq 0 1:(INV IBlockSponge.m{2} ICORE.m{1} /\ 0 < n0{2} /\ i0{2} + 1 = n0{2}
                /\ (x=x1){2} /\ (forall (j : int), 0 < j < n0{1} => 
                format p0{1} j \in dom IBlockSponge.m{2}) /\
              (p0,n0){1} = parse x1{2} /\ ={p0,n0} /\ (x=x1){2});last first. 
    + rcondt{2}1;1:auto=>/#;rcondf{2}4;1: by progress;sp;if;auto=>/#.
      sp;if;auto;progress. 
      + rewrite-(formatK x1{2})-H2/=take_cat addzAC/=-addzA/=take_nseq/min/=.
        cut->/=:!size p0{2} + i0{2} < size p0{2} by rewrite/#.
        smt(in_dom formatK).
      + move:H3;rewrite-(formatK x1{2})-H2/=take_cat addzAC/=-addzA/=take_nseq/min/=.
        cut->/=:!size p0{2} + i0{2} < size p0{2} by rewrite/#.
        smt(in_dom formatK).
      + rewrite-(formatK x1{2})-H2/=take_cat addzAC/=-addzA/=take_nseq/min/=.
        smt(getP parseK formatK). 
      + rewrite-(formatK x1{2})-H2/=take_cat addzAC/=-addzA/=take_nseq/min/=.
        smt(in_dom getP parseK formatK). 
      + case(j=i0{2} + 1)=>//=;2:rewrite/#.
        smt(in_dom getP parseK formatK). 
    while{2}((p0{2}, n0{2}) = parse x1{2} /\ (x=x1){2} /\ 0 <= i0{2} < n0{2} /\
                INV IBlockSponge.m{2} ICORE.m{1} /\ (p0,n0){1} = parse x1{2} /\
              ={p0,n0} /\ (forall (j : int), 0 < j < n0{2} => 
                format p0{2} j \in dom IBlockSponge.m{2}))(n0{2}-i0{2});progress.
    + sp;rcondf 1;auto;progress. 
      + rewrite-(formatK x1{hr})-H3/=take_cat addzAC/=/=take_nseq/min/=.
        cut->/=:!size p0{hr} + i0{hr} < size p0{hr} by rewrite/#.
        by cut/#:=H4 (i0{hr}+1).
      + by rewrite/#.
      by rewrite/#.
    by auto=>/#.

  + proc (INV IBlockSponge.m{2} ICORE.m{1})=> //.
    proc=> /=; sp;if=> [&1 &2 [#] <*>| |] //=.
    inline{2} 1.1.
    inline*.
    while( INV IBlockSponge.m{2} ICORE.m{1}
        /\ 0 < i{1} <= n{1} + 1
        /\ ={n,p,r,i}
        /\ valid p{1}
        /\ 0 < n{1}
        /\ (forall j, 0 < j < i{1} => 
              format p{2} j \in dom IBlockSponge.m{2}));last auto=>/#. 
    rcondt{2}5;auto;1:smt(parseK). 
    swap{2}6-1;sp.
    conseq(:_==> INV IBlockSponge.m{2} ICORE.m{1} /\
            (forall j, 0 < j <= n0{1} => 
              format p0{1} j \in dom IBlockSponge.m{2}));1:smt(parseK formatK).
    conseq(: INV IBlockSponge.m{2} ICORE.m{1} /\ (forall (j : int),
              0 < j < n0{1} => format p0{1} j \in dom IBlockSponge.m{2}) /\
              (p0,n0){1} = parse x1{2} /\ (x=x1){2} /\ ={p0,n0} /\ 
              n0{1} = i{2} /\ 0 <= i0{2} < i{2}
              ==> _);1:smt(parseK formatK). 
    seq 1 1 : (INV IBlockSponge.m{2} ICORE.m{1} /\ 0 < n0{2} /\
              (forall (j : int), 0 < j <= n0{1} => 
                format p0{1} j \in dom IBlockSponge.m{2}) /\
              (p0,n0){1} = parse x1{2} /\ ={p0,n0} /\ (x=x1){2});last first. 
    + rcondf{2}1;auto;smt(parseK formatK).
    splitwhile{2}1:(i0+1<n0).
    seq 0 1:(INV IBlockSponge.m{2} ICORE.m{1} /\ 0 < n0{2} /\ i0{2} + 1 = n0{2}
                /\ (x=x1){2} /\ (forall (j : int), 0 < j < n0{1} => 
                format p0{1} j \in dom IBlockSponge.m{2}) /\
              (p0,n0){1} = parse x1{2} /\ ={p0,n0} /\ (x=x1){2});last first. 
    + rcondt{2}1;1:auto=>/#;rcondf{2}4;1: by progress;sp;if;auto=>/#.
      sp;if;auto;progress. 
      + rewrite-(formatK x1{2})-H2/=take_cat addzAC/=-addzA/=take_nseq/min/=.
        cut->/=:!size p0{2} + i0{2} < size p0{2} by rewrite/#.
        smt(in_dom formatK).
      + move:H3;rewrite-(formatK x1{2})-H2/=take_cat addzAC/=-addzA/=take_nseq/min/=.
        cut->/=:!size p0{2} + i0{2} < size p0{2} by rewrite/#.
        smt(in_dom formatK).
      + rewrite-(formatK x1{2})-H2/=take_cat addzAC/=-addzA/=take_nseq/min/=.
        smt(getP parseK formatK). 
      + rewrite-(formatK x1{2})-H2/=take_cat addzAC/=-addzA/=take_nseq/min/=.
        smt(in_dom getP parseK formatK). 
      + case(j=i0{2} + 1)=>//=;2:rewrite/#.
        smt(in_dom getP parseK formatK). 
    while{2}((p0{2}, n0{2}) = parse x1{2} /\ (x=x1){2} /\ 0 <= i0{2} < n0{2} /\
                INV IBlockSponge.m{2} ICORE.m{1} /\ (p0,n0){1} = parse x1{2} /\
              ={p0,n0} /\ (forall (j : int), 0 < j < n0{2} => 
                format p0{2} j \in dom IBlockSponge.m{2}))(n0{2}-i0{2});progress.
    + sp;rcondf 1;auto;progress. 
      + rewrite-(formatK x1{hr})-H3/=take_cat addzAC/=/=take_nseq/min/=.
        cut->/=:!size p0{hr} + i0{hr} < size p0{hr} by rewrite/#.
        by cut/#:=H4 (i0{hr}+1).
      + by rewrite/#.
      by rewrite/#.
    by auto=>/#.

  + proc.
    sp;if=> [&1 &2 [#] <*>/#| |] //=.
    inline*;sp;rcondt{1}1;auto.
    swap{2}1;sp.
    conseq(:_==> last Block.b0 r0{1} = oget IBlockSponge.m{2}.[x{2}] /\
                INV IBlockSponge.m{2} ICORE.m{1});progress.
    seq 1 1 :(last Block.b0 r0{1} = oget IBlockSponge.m{2}.[x{2}] /\
                INV IBlockSponge.m{2} ICORE.m{1} /\
                x1{2} \in dom IBlockSponge.m{2});last by rcondf{2}1;auto=>/#. 
    conseq(:_==> INV IBlockSponge.m{2} ICORE.m{1} /\ i{2} = n{2} /\
                Some (last Block.b0 r0{1}) = 
                IBlockSponge.m{2}.[take (size p + i){2} x{2}]);progress.
    + move:H5;rewrite take_oversize;2:smt(oget_some). 
      by rewrite-formatK/=-H/=size_cat size_nseq/#. 
    + move:H5;rewrite take_oversize. 
      + by rewrite-formatK/=-H/=size_cat size_nseq/#. 
      by rewrite in_dom/#.
    while( i{1} = i{2}+1 /\ n0{1} = n{2} /\ p{2} = p0{1}
        /\ valid p0{1} /\ 0 < i{1} /\ i{2} <= n{2}
        /\ (i{2} = n{2} => Some (last Block.b0 r0{1}) =
           IBlockSponge.m{2}.[take (size p{2} + i{2}) x{2}])
        /\ INV IBlockSponge.m{2} ICORE.m{1}
        /\ parse x{2} = (p0{1},n0{1}));auto;last first.
    + progress=>/#. 
    sp;if;auto;smt(take_nseq parseK in_dom formatK take_cat getP last_rcons).

  by inline*;auto;call(:true);auto;smt(in_dom dom0 in_fset0).
qed.
end section PROOF.
