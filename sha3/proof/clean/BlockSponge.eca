require import Core Logic Distr.
require import Int IntExtra Real List NewFMap FSet.
require import StdOrder.
(*---*) import IntOrder.

require import NewCommon.
(*---*) import Block DBlock Capacity DCapacity.

(*** THEORY PARAMETERS ***)
(** Validity of Functionality Queries **)
op valid: block list -> bool.
axiom valid_spec p: valid p => p <> [].
(* FIXME : verify if this axiom is correct. *)
axiom valid_take p i: valid p => 0 < i => valid (take i p).

(** Validity and Parsing/Formatting of Functionality Queries **)
op format (p : block list) (n : int) = p ++ nseq (n - 1) b0.
op parse: block list -> (block list * int).

axiom formatK bs: format (parse bs).`1 (parse bs).`2 = bs.
axiom parseK p n: 0 < n => valid p => parse (format p n) = (p,n).

lemma parse_injective: injective parse.
proof. by move=> bs1 bs2 eq_format; rewrite -formatK eq_format (@formatK bs2). qed.

lemma parse_valid p: valid p => parse p = (p,1).
proof.
move=>h;cut{1}->:p=format p 1;2:smt(parseK).
by rewrite/format/=nseq0 cats0.
qed.

(******************* Useful lemmas ******************)
lemma take_nseq (b:block) i j : take i (nseq j b) = nseq (min i j) b.
proof.
move:i;elim/natind=>//=.
+ smt(take_le0 nseq0_le).
move=>i hi0 hind.
case(i + 1 <= j)=>hi1j.
+ rewrite (take_nth b);1:smt(size_nseq).
  rewrite hind nth_nseq 1:/# //=-nseqSr/#.
rewrite take_oversize;smt(size_nseq).
qed.


(*** DEFINITIONS ***)
(** Low-Level Definitions **)
require (*--*) NewCore.

clone import NewCore as Low with
  op valid bs <- let (b,s) = bs in valid b /\ 0 < s
proof * by done.

(** High-Level Definitions **)
(* Indifferentiability *)
clone import Indifferentiability as BS_Ind with
  type p     <- block * capacity,
  type f_in  <- block list * int,
  type f_out <- block list
proof * by done.

(* BlockSponge Construction *)
module (BlockSponge : CONSTRUCTION) (P : DPRIMITIVE) : FUNCTIONALITY = {
  proc init() = {}

  proc f(p : block list, n : int) : block list = {
    var r <- [];
    var (sa,sc) <- (b0,c0);
    var i <- 0;

    if (valid p /\ 0 < n) {
      while (i < size p) {
        (sa,sc) <@ P.f((sa +^ nth witness p i,sc));
        i <- i + 1;
      }
      i <- 1;
      r <- rcons r sa;
      while (i < n) {
        (sa,sc) <@ P.f(sa,sc);
        r <- rcons r sa;
        i <- i + 1;
      }
    }
    return r;
  }
}.

(* Ideal Block Sponge Functionality *)
module IBlockSponge : FUNCTIONALITY = {
  var m : (block list * int,block) fmap

  proc init() = {
    m <- map0;
  }

  proc fill_in(x, n) = {
    if (!mem (dom m) (x, n)) {
      m.[(x,n)] <$ bdistr;
    }
    return oget m.[(x,n)];
  }

  proc f(x, n) = {
    var b, bs;
    var i <- 1;

    bs <- [];
    if (valid x /\ 0 < n) {
      (* while (i < size x) { *)
      (*   b <@ fill_in(take i x,1); *)
      (*   i <- i + 1; *)
      (* } *)
      (* i <- 1; *)
      b <@ fill_in(x, 1);
      bs <- rcons bs b;
      while (i < n) {
        i <- i + 1;
        b <@ fill_in(x, i);
        bs <- rcons bs b;
      }
    }
    return bs;
  }
}.


(* Parametric Simulator *) 
module (HiSim (S : Low.SIMULATOR) : SIMULATOR) (F : DFUNCTIONALITY) = {
  module LoF = {
    proc f(p : block list, n : int): block list = {
      var r <- [];
      var b <- [];
      var i <- 1;

      if (valid p /\ 0 < n)
      {
        (* while (i < size p) { *)
        (*   b <@ F.f(take i p,1); *)
        (*   r <- r ++ b; *)
        (*   i <- i + 1; *)
        (* } *)
        b <@ F.f(p,n);
        r <- r ++ b;
      }
      return r;
    }
  }

  proc init = S(LoF).init
  proc f    = S(LoF).f
  proc fi   = S(LoF).fi
}.

pred INV (mc : (block list,block) fmap) (mb : (block list * int,block) fmap) =
  forall p, mc.[p] = mb.[parse p].

(* Constructed Distinguisher *)
module (LoDist (D : DISTINGUISHER) : Low.DISTINGUISHER)
           (F : Low.DFUNCTIONALITY) (P : Low.DPRIMITIVE) = {
  module HiF = {
    proc f(p : block list, n : int) = {
      var r <- [];

      if (valid p /\ 0 < n) {
        r <@ F.f(p,n);
      }
      return r;
    }
  }

  proc distinguish = D(HiF,P).distinguish
}.

(*** PROOF
     forall P D S,
          LoDist(D)^{Core(P),P} ~ LoDist(D)^{ICore,S(ICore)}
       => D^{BlockSponge(P),P} ~ D^{IBlockSponge,HiSim(S)(IBlockSponge)} ***)
section PROOF.
  declare module P : PRIMITIVE     { Low.ICORE, IBlockSponge, HiSim }.
  declare module S : Low.SIMULATOR { Low.ICORE, IBlockSponge, HiSim, P }.
  declare module D : DISTINGUISHER { Low.ICORE, IBlockSponge, HiSim, P, S }.

  lemma LiftInd &m:
    `| Pr[Low.Indif(CORE(P),P,LoDist(D)).main() @ &m: res]
       - Pr[Low.Indif(ICORE,S(ICORE),LoDist(D)).main() @ &m: res] |
    = `| Pr[Indif(BlockSponge(P),P,D).main() @ &m: res]
         - Pr[Indif(IBlockSponge,HiSim(S,IBlockSponge),D).main() @ &m: res] |.
  proof.
  do !congr.
  + byequiv (_: ={glob D, glob P} ==> _ )=> //=; proc.
    call (_: ={glob P}); first 2 by sim.
    + proc=> /=; sp; if=>//=; inline{1} 1.
      sp;wp.
      rcondt{1}1;progress.
      while( ={sa,sc,glob P,i} /\ r0{1} = r{2} /\ n{2} = n0{1});auto;1:call(:true);auto.
      by conseq(:_==> ={sa, sc, glob P} /\ r0{1} = r{2} /\ n{2} = n0{1});
        2:sim;progress=>/#.

    by inline*;auto;call(:true);auto.

  byequiv (_: ={glob D, glob S} ==> _)=> //=; proc.
  call (_:    ={glob S} /\ ={m}(ICORE,IBlockSponge) ).
  + proc (ICORE.m{1} = IBlockSponge.m{2})=> //.
    proc=> /=; sp;if=> [&1 &2 [#] <*>| |] //.
    inline*.
    sp;rcondt{2}1;auto.
    rcondt{1}1;1:auto=>/#.
    conseq(:_ ==> r{1} = bs{2} /\ ICORE.m{1} = IBlockSponge.m{2});progress.
    by while( i{1} = i0{2} + 1 /\ n{1} = n0{2} /\ x{2} = p{1}
        /\ ICORE.m{1} = IBlockSponge.m{2} /\ r{1} = bs{2});sp;if;auto=>/#.

  + proc(={m}(ICORE,IBlockSponge))=>//=.
    proc;inline*;sp;if;auto;sp;rcondt{2}1;auto;sp.
    rcondt{1}1;1:auto=>/#;sp.
    conseq(:_ ==> r{1} = bs{2} /\ ICORE.m{1} = IBlockSponge.m{2});progress.
    by while( i{1} = i0{2} + 1 /\ n{1} = n0{2} /\ x{2} = p{1}
        /\ ICORE.m{1} = IBlockSponge.m{2} /\ r{1} = bs{2});sp;if;auto=>/#.

  + proc;inline*;sp;if;auto;sp;rcondt{1}1;auto;progress.
    rcondt{1}1;1:auto=>/#;sp.
    conseq(:_ ==> r0{1} = bs{2} /\ ICORE.m{1} = IBlockSponge.m{2});progress.
    by while( i{1} = i{2} + 1 /\ n0{1} = n{2} /\ x{2} = p0{1}
        /\ ICORE.m{1} = IBlockSponge.m{2} /\ r0{1} = bs{2});sp;if;auto=>/#.

  by inline*;auto;call(:true);auto.
qed.

(*     conseq (_:    ={r, i} *)
(*                /\ r{2} = [] *)
(*                /\ b{2} = [] *)
(*                /\ i{2} = 1 *)
(*                /\ parse p{1} = (p{2},n{2}) *)
(*                /\ valid p{2} *)
(*                /\ 0 < n{2} *)
(*                /\ INV ICORE.m{1} IBlockSponge.m{2} *)
(*                ==> _)=> />. *)
(*     + by move=> &1 &2=> <-. *)
(*     splitwhile{1} 1: (i < size (parse p).`1); inline{2} 2. *)
(*     rcondt{2} 6; first by auto; while (true)=> //; auto=> /> &hr <- //. *)
(*     wp. while (   i{1} = i0{2} + size x0{2} - 1 *)
(*                /\ p{1} = x0{2} ++ nseq (n0 - 1){2} b0 *)
(*                /\ r{1} = r{2} ++ bs{2} *)
(*                /\ 0 < i0{2} *)
(*                /\ valid x0{2} *)
(*                /\ n{2} = n0{2} *)
(*                /\ INV ICORE.m{1} IBlockSponge.m{2} *)
(*                /\ parse p{1} = (p{2}, n{2})). *)
(*     + wp;inline*;sp;wp;if;auto;smt(parseK min_lel size_nseq take_nseq  *)
(*         rcons_cat parse_injective getP in_dom oget_some take_size take0 *)
(*         take_cat parse_valid valid_take cat_rcons cats0 size_cat size_ge0). *)
(*     wp=>/=.  *)
(*     conseq(:_==>  ={r, i} *)
(*              /\ valid p{2} *)
(*              /\ 0 < n{2} *)
(*              /\ p{1} = p{2} ++ nseq (n{2} - 1) Block.b0 *)
(*              /\ i{1} = size p{2} *)
(*              /\ parse p{1} = (p{2}, n{2}) *)
(*              /\ INV ICORE.m{1} IBlockSponge.m{2});progress;..-2:smt(cats0 size_cat size_ge0). *)
(*     while(   ={r,i} *)
(*           /\ valid p{2} *)
(*           /\ 0 < n{2} *)
(*           /\ p{1} = p{2} ++ nseq (n{2} - 1) Block.b0 *)
(*           /\ 0 < i{1} <= size p{2} *)
(*           /\ parse p{1} = (p{2}, n{2}) *)
(*           /\ INV ICORE.m{1} IBlockSponge.m{2}). *)
(*     + inline*;auto;sp;rcondt{2}1;1:(auto;smt(valid_take)).  *)
(*       rcondt{2}1;1:auto;sp;rcondf{2}5;1:auto;if;auto; *)
(*         smt(parse_injective getP oget_some in_dom take_size take0 take_cat  *)
(*           parse_valid valid_take cat_rcons cats0 size_cat size_ge0). *)
(*     auto;smt(parseK min_lel size_nseq take_nseq valid_spec *)
(*         rcons_cat parse_injective getP in_dom oget_some take_size take0 *)
(*         take_cat parse_valid valid_take cat_rcons cats0 size_cat size_ge0). *)
(*   + proc (INV ICORE.m{1} IBlockSponge.m{2})=> //. *)
(*     proc. *)
(*     sp;if;1:progress=>/#. *)
(*     splitwhile{1} 1 : i < size (parse p).`1. *)
(*     rcondt{1}2;progress. *)
(*     + while(i <= size (parse p).`1);auto;1:call(:true);auto;progress. *)
(*       + rewrite/#. *)
(*       + smt(size_ge0 valid_spec). *)
(*       cut/#:size (parse x{m0}).`1 <= size x{m0}. *)
(*       by rewrite-{2}(formatK x{m0}) -H/=/format size_cat size_nseq/#.  *)
(*     inline*;auto. *)
(*     replace{2} {  *)
(*       while {  *)
(*         setup;  *)
(*         if { *)
(*          (while as loop) *)
(*         }; *)
(*         setup_end *)
(*       }; *)
(*       after *)
(*     } by { *)
(*       while(i < size p) { *)
(*         setup; *)
(*         loop; *)
(*         setup_end; *)
(*       } *)
(*       after; *)
(*     } *)
(*     (r{2} = [] /\ (p{2}, n{2}) = parse x{2} /\ b{2} = [] /\  *)
(*       i{2} = 1 /\ r{1} = [] /\ i{1} = 1 /\ p{1} = x{2} /\  *)
(*       INV ICORE.m{1} IBlockSponge.m{2} /\ valid (parse p{1}).`1 /\  *)
(*       0 < (parse p{1}).`2 *)
(*       ==> r{1} = r{2} ++ bs0{2} /\ INV ICORE.m{1} IBlockSponge.m{2}) *)
(*     (={i,p,n,x,r,b,IBlockSponge.m, *)


(* (* now we should manage the while loops *) *)
(*     admit. *)
(*   + auto. *)

(*   + proc; sp; if=> //=; inline{1} 1; rcondt{1} 4. *)
(*     + by auto=> /> &hr _ ^valid_x+ ^n_gt0 /parseK H - /H {H} ->. *)
(*       sp;wp. *)
(*       conseq(:_==> drop (size p{1} - 1) r0{1} = bs{2} *)
(*                 /\ ={glob S} *)
(*                 /\ INV ICORE.m{1} IBlockSponge.m{2});progress. *)
(*       by do !congr;rewrite b2i_eq1/#. *)
(*     inline*;rewrite/INV. *)
(* (* This is false : because ICORE.m{1} will be bigger than IBlockSponge.m{2} *) *)
(*     splitwhile{1}1:i<=size p;rcondt{2}1;1:auto=>/#. *)
(*     inline*. *)
(*     (* same as the second loop in LoF.f *)   *)
(*     admit. *)
(*   by inline *; auto; call (_: true); auto=> /> p; rewrite !map0P. *)
(*   qed. *)
end section PROOF.
