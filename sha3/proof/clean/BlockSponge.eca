require import Core Logic Distr.
require import Int IntExtra Real List NewFMap FSet.
require (*--*) StdBigop.
(*---*) import StdBigop.Bigint.
require import StdOrder.
(*---*) import IntOrder.

require import Gconcl.
(*---*) import Common SLCommon.
(*---*) import Block DBlock Capacity DCapacity.

(*** THEORY PARAMETERS ***)
(** Validity of Functionality Queries **)
op valid: block list -> bool.
axiom valid_spec p: valid p => p <> [].

(** Validity and Parsing/Formatting of Functionality Queries **)
op format (p : block list) (n : int) = p ++ nseq (n - 1) b0.
op parse: block list -> (block list * int).

axiom formatK bs: format (parse bs).`1 (parse bs).`2 = bs.
axiom parseK p n: 0 < n => valid p => parse (format p n) = (p,n).

lemma parse_injective: injective parse.
proof. by move=> bs1 bs2 eq_format; rewrite -formatK eq_format (@formatK bs2). qed.

lemma parse_valid p: valid p => parse p = (p,1).
proof.
move=>h;cut{1}->:p=format p 1;2:smt(parseK).
by rewrite/format/=nseq0 cats0.
qed.

(******************* Useful lemmas ******************)
lemma take_nseq (b:block) i j : take i (nseq j b) = nseq (min i j) b.
proof.
move:i;elim/natind=>//=.
+ smt(take_le0 nseq0_le).
move=>i hi0 hind.
case(i + 1 <= j)=>hi1j.
+ rewrite (take_nth b);1:smt(size_nseq).
  rewrite hind nth_nseq 1:/# //=-nseqSr/#.
rewrite take_oversize;smt(size_nseq).
qed.

lemma sumid_leq (n m p : int) : 0 <= n => m <= p => sumid n m <= sumid n p.
proof.
move=>Hn0 Hmp.
case(m<=n)=>Hmn. search BIA.big 0 (<=).
+ rewrite BIA.big_geq//.
  by apply sumr_ge0_seq=>//=;smt(mem_iota size_ge0).
rewrite(BIA.big_cat_int m n p) 1:/# //.
cut/#:0<=sumid m p.
by apply sumr_ge0_seq=>//=;smt(mem_iota size_ge0).
qed.

(*** DEFINITIONS ***)
(** Low-Level Definitions **)
require (*--*) NewCore.

clone import NewCore as Low with
  op valid bs <- let (b,s) = bs in valid b /\ 0 < s
proof * by done.

(** High-Level Definitions **)
(* Indifferentiability *)
clone import Indifferentiability as BS_Ind with
  type p     <- block * capacity,
  type f_in  <- block list,
  type f_out <- block
proof * by done.

(* BlockSponge Construction *)
module (BlockSponge : CONSTRUCTION) (P : DPRIMITIVE) : FUNCTIONALITY = {
  proc init() = {}

  proc f(p : block list) : block = {
    var (sa,sc) <- (b0,c0);
    var i <- 0;
    var (x,n) <- parse p;

    if (valid x /\ 0 < n) {
      while (i < size p) {
        (sa,sc) <@ P.f((sa +^ nth b0 p i,sc));
        i <- i + 1;
      }
    }
    return sa;
  }
}.

(* Ideal Block Sponge Functionality *)
module IBlockSponge : FUNCTIONALITY = {
  var m : (block list,block) fmap

  proc init() = {
    m <- map0;
  }

  proc fill_in(x) = {
    if (!mem (dom m) x) {
      m.[x] <$ bdistr;
    }
    return oget m.[x];
  }

  proc f(x : block list) = {
    var bs <- b0;
    var i <- 1;

    var (p,n) <- parse x;
    if (valid p /\ 0 < n) {
      while (i < n) {
        fill_in(format p i);
        i <- i + 1;
      }
      bs <@ fill_in(x);
    }

    return bs;
  }
}.


(* Parametric Simulator *) 
module (LowSim (S : SIMULATOR) : Low.SIMULATOR) (F : Low.DFUNCTIONALITY) = {
  module LoF = {
    proc f(x : block list) = {
      var r <- [];
      var b <- b0;
      var i <- 1;

      if (let (p,n) = parse x in valid p /\ 0 < n)
      {
        r <@ F.f(parse x);
        b <- last b0 r;
      }
      return b;
    }
  }

  proc init = S(LoF).init
  proc f    = S(LoF).f
  proc fi   = S(LoF).fi
}.

pred INV (mc : (block list,block) fmap) (mb : (block list * int,block) fmap) =
  forall p, mc.[p] = mb.[parse p].

(* Constructed Distinguisher *)
module (HiDist (D : Low.DISTINGUISHER) : DISTINGUISHER)
           (F : DFUNCTIONALITY) (P : DPRIMITIVE) = {
  var c : int
  module HiF = {
    proc f(p : block list, n : int) = {
      var r <- [];
      var b <- b0;
      var i <- 1;
    
      if (valid p /\ 0 < n /\ c + sumid (size p) (size p + n) <= max_size) {
        while(i <= n) {
          b <@ F.f(format p i);
          c <- c + size p + i - 1;
          r <- rcons r b;
          i <- i + 1;
        }
      }
      return r;
    }
  }
  module C = {
    proc f (x) = {
      var y <- (b0,c0);
      if (c + 1 <= max_size) {
        c <- c + 1;
        y <@ P.f(x);
      }
      return y;
    }
    proc fi (x) = {
      var y <- (b0,c0);
      if (c + 1 <= max_size) {
        c <- c + 1;
        y <@ P.fi(x);
      }
      return y;
    }
  }

  proc distinguish() = {
    var a;
    c <- 0;
    a <@ D(HiF,C).distinguish();
    return a;
  }
}.

module DFCn (F : Low.FUNCTIONALITY) : Low.FUNCTIONALITY = {
  proc init = F.init
  proc f(p : block list, n : int) = {
    var r : block list <- [];
    if(C.c + sumid (size p) (size p + n) <= max_size /\ valid p /\ 0 < n) {
      r <@ F.f(p,n);
      C.c <- C.c + sumid (size p) (size p + n);
    }
    return r;
  }
}.

module DPC (P : PRIMITIVE) : PRIMITIVE = {
  proc init () = {
    C.init();
    P.init();
  }
  proc f(x) = {
    var y <- (b0,c0);
    if (C.c + 1 <= max_size) {
      y <@ P.f(x);
      C.c <- C.c + 1;
    }
    return y;
  }
  proc fi(x) = {
    var y <- (b0,c0);
    if (C.c + 1 <= max_size) {
      y <@ P.fi(x);
      C.c <- C.c + 1;
    }
    return y;
  }
}.

module DFC1 (F : FUNCTIONALITY) : FUNCTIONALITY = {
  proc init = F.init
  proc f(x : block list) = {
    var b : block <- b0;
    if (C.c + size x <= max_size) {
      C.c <- C.c + size x;
      b <@ F.f(x);
    }
    return b;
  }
}.

module P = Common.Perm.Perm.
print Real_Ideal.
(*** PROOF
     forall P D S,
         HiDist(D)^{BlockSponge(P),P} ~ HiDist(D)^{IBlockSponge,S(IBlockSponge)}
       => D^{Core(P),P} ~ D^{ICore,LowSim(S,ICore)} ***)
section PROOF.
  declare module S : SIMULATOR         { Low.ICORE, IBlockSponge, HiDist, C, P }.
  declare module D : Low.DISTINGUISHER { Low.ICORE, IBlockSponge, HiDist, C, P, S }.


  local module EagerCORE (P : Low.PRIMITIVE) = {
    var order : block list
    var capa  : capacity
    var blo   : block
    var map   : (block * capacity) list
    proc init() = {
      order <- [];
      capa <- c0;
      blo <- b0;
      map <- [];
      CORE(P).init();
    }
    proc g(bi,ci) = {
      var bj, cj;
      (bj,cj) <@ P.f(bi,ci);
      map <- rcons map (bi,ci);
      return (bj,cj);
    }
    proc f (p : block list, n : int) = {
      var r  : block list;
      var i  : int;

      (blo,capa) <- (b0,c0);
      r <- [];
      i <- 0;
      if (valid p /\ 0 < n) {
        while(i < size p) {
          (blo,capa) <@ P.f(blo +^ nth b0 p i, capa);
          i <- i + 1;
        }
        i <- 1;
        order <- p;
        r <- rcons r blo;
        while (i < n) {
          order <- rcons order b0;
          (blo,capa) <@ P.f(blo,capa);
          r <- rcons r blo;
          i <- i + 1;
        }
      }
      return r;
    }
    proc ewhile() = {
      var i : int <- 0;
      blo <- b0;
      capa <- c0;
      map <- [];
      while(i < size order) {
        (blo,capa) <@ g(blo +^ nth b0 order i,capa);
        i <- i + 1;
      }
    }
    proc nwhile(k : int) : block list = {
      var i : int <- 1;
      var result : block list <- [];
      ewhile();
      result <- rcons result EagerCORE.blo;
      while(i < k) {
        EagerCORE.order <- rcons EagerCORE.order b0;
        (blo,capa) <@ g(blo,capa);
        result <- rcons result EagerCORE.blo;
        i <- i + 1;
      }
      return result;
    }
    proc enwhile(k : int) : block list = {
      var i : int <- 1;
      var m : (block * capacity) list <- [];
      var result : block list <- [];
      ewhile();
      result <- rcons result EagerCORE.blo;
      while(i < k) {
        EagerCORE.order <- rcons EagerCORE.order b0;
        m <- rcons EagerCORE.map (EagerCORE.blo, EagerCORE.capa);
        ewhile();
        EagerCORE.map <- m;
        result <- rcons result EagerCORE.blo;
        i <- i + 1;
      }
      return result;
    }
        
  }.

  local module EagCORE (P : Low.PRIMITIVE) : Low.FUNCTIONALITY = {
    proc init = EagerCORE(P).init


    proc f (p : block list, n : int) = {
      var r  : block list;
      var i  : int;

      (EagerCORE.blo,EagerCORE.capa) <- (b0,c0);
      r <- [];
      i <- 0;
      if (valid p /\ 0 < n) {
        i <- 1;
        EagerCORE.order <- p;
        EagerCORE(P).ewhile();
        r <- rcons r EagerCORE.blo;
        while (i < n) {
          EagerCORE.order <- rcons EagerCORE.order b0;
          EagerCORE(P).ewhile();
          r <- rcons r EagerCORE.blo;
          i <- i + 1;
        }
      }
      return r;
    }
  }.


  local equiv nwhile_enwhile (n : int) :
    EagerCORE(P).nwhile ~ EagerCORE(P).enwhile :
    ={arg, glob P, glob EagerCORE} /\ arg{1} = n ==> ={res, glob P, glob EagerCORE}.
  proof.
  move:n;elim/natind=>n Hn0.
  + by proc;sp;rcondf{1}3;progress;2:rcondf{2}3;progress;-1:sim;
      (inline*;wp;while(!i<k);1:(sp;if);auto=>/#).
  move=>Hind;case(1 <= n)=>Hn1;last first.
  + by proc;sp;rcondf{1}3;2:rcondf{2}3;-1:sim;progress;inline*;
      by wp;while(!i<k);1:(sp;if);auto=>/#.
  proc.
  replace{1} { (!<-)  as init ; rest} by {
      init;
      result <@ EagerCORE(P).nwhile(n);
      EagerCORE.order <- rcons EagerCORE.order b0;
      (EagerCORE.blo,EagerCORE.capa) <@ EagerCORE(P).g(EagerCORE.blo,EagerCORE.capa);
      result <- rcons result EagerCORE.blo;
      i <- i + 1;
    }
    (={glob P, glob EagerCORE} /\ k{1} = n + 1
      ==> ={result, glob P, glob EagerCORE})
    (={glob P, glob EagerCORE} /\ k{2} = n + 1
      ==> ={result, glob P, glob EagerCORE});
    progress;1:rewrite/#.
  + sp;inline{2}1;sp;sim.
    splitwhile{1}3: i < n.
    rcondt{1}4;progress.
    + inline*;while(i <= n /\ k = n + 1);1:(sp;if;auto=>/#).
      by conseq(:_==> true);1:progress=>/#;auto.
    rcondf{1}8;progress.
    + inline*;sp;wp;conseq(:_==> i=n);progress.
      seq 3 : (i = n);last by sp;if;auto.
      while(i <= n);first by sp;if;auto=>/#.
      by conseq(:_==> true);2:auto;progress=>/#.
    wp;sim.
    while(={glob P, glob EagerCORE} /\ (result,i,n){1} = (result0,i0,k0){2}
        /\ k{1} = n + 1);1:(inline*;sp;if;auto=>/#).
    by wp;conseq(:_==> ={glob P, glob EagerCORE});1:progress=>/#;sim.

  replace{2} { (!<-)  as init ; rest} by {
      init;
      result <@ EagerCORE(P).enwhile(n);
      EagerCORE.order <- rcons EagerCORE.order b0;
      m <- rcons EagerCORE.map (EagerCORE.blo, EagerCORE.capa);
      EagerCORE(P).ewhile();
      EagerCORE.map <- m;
      result <- rcons result EagerCORE.blo;
      i <- i + 1;
    }
    (={glob P, glob EagerCORE}
      ==> ={result, glob P, glob EagerCORE})
    (={glob P, glob EagerCORE} /\ k{2} = n + 1
      ==> ={result, glob P, glob EagerCORE});
    progress;1:rewrite/#;last first.
  + sp;inline{1}1;sp;sim.
    splitwhile{2}3: i < n.
    rcondt{2}4;2:rcondf{2}10;progress.
    + by while(i <= n /\ k = n + 1);by inline*;sp;wp;conseq(:_==> true);auto=>/#.
    + wp;conseq(:_==> i = n);progress.
      seq 3 : (i = n);last by inline*;conseq(:_==> true);auto.
      by while(i <= n /\ k = n + 1); by inline*;sp;wp;conseq(:_==> true);auto=>/#.
    sim.
    while(={glob P, glob EagerCORE} /\ (result,i,n){2} = (result0,i0,k0){1}
        /\ k{2} = n + 1);1:inline*. 
    + by sp;wp;conseq(:_==> ={glob P, glob EagerCORE} /\ i1{1} = i0{2});
        1:progress=>/#;sim.
    by wp;conseq(:_==> ={glob P, glob EagerCORE});1:progress=>/#;sim.

  replace{2} { (! <- as before); <@ ; after} by {
      before;
      result <@ EagerCORE(P).nwhile(n);
      after;
    }
    (={glob P, glob EagerCORE} ==> ={result, glob P, glob EagerCORE})
    (={glob P, glob EagerCORE} ==> ={result, glob P, glob EagerCORE});
    progress;1:rewrite/#;last by sim;call(Hind);auto.
  
  sp;sim.
  
  inline{2}4.
  seq 1 1 : (={glob P, glob EagerCORE, result}
         /\ size EagerCORE.order{2} = size EagerCORE.map{1}
         /\ nth (b0,c0) EagerCORE.map{1} 0 = (nth b0 EagerCORE.order{1} 0, c0)
         /\ (forall y, y \in EagerCORE.map{1} => y \in dom Perm.m{1})
         /\ (0 = size EagerCORE.map{1} =>
              (EagerCORE.blo,EagerCORE.capa){1} = (b0,c0))
         /\ (0 < size EagerCORE.map{1} =>
              (EagerCORE.blo,EagerCORE.capa){1} =
              oget Perm.m{1}.[last (b0,c0) EagerCORE.map{1}])
         /\ (forall j, 0 < j < size EagerCORE.map{1} =>
              let ej = nth (b0,c0) EagerCORE.map{1} j in
              let ej1 = nth (b0,c0) EagerCORE.map{1} (j-1) in
              let mj = nth b0 EagerCORE.order{1} j in
              Perm.m{1}.[ej1] = Some (ej.`1 +^ mj, ej.`2)));last first.

  + inline*.
    splitwhile{2}7:i0 < size EagerCORE.order - 1.
    rcondt{2}8;2:rcondf{2}16;progress.
    + by while(i0 < size EagerCORE.order);1:(sp;if);auto;smt(size_rcons size_ge0).
    + wp;conseq(:_==> i0 = size EagerCORE.order-1);1:progress=>/#.
      seq 7:(i0 = size EagerCORE.order-1);2:(sp;if;auto=>/#).
      by while(i0 <= size EagerCORE.order - 1);1:(sp;if);auto;smt(size_rcons size_ge0).
    sim.
    swap{1}-3;sim;sp 1 2;wp.
    conseq(:_==> ={Perm.m, Perm.mi, EagerCORE.blo, EagerCORE.capa}
              /\ i0{2} = size EagerCORE.order{2} - 1);progress.
    + by rewrite nth_rcons size_rcons-addzA/=Block.WRing.addr0/#.
    alias{2}1 permm = Perm.m.
    alias{2}1 permmi = Perm.mi.
    sp 0 2;conseq(:_==> m{2} = rcons EagerCORE.map{1} (EagerCORE.blo{1}, EagerCORE.capa{1})
                /\ (EagerCORE.blo{2}, EagerCORE.capa{2}) = last (b0, c0) m{2}
                /\ i0{2} = size EagerCORE.order{2} - 1
                /\ (Perm.m = permm /\ Perm.mi = permmi){2});1:smt(last_rcons).

    while{2}(={glob P, EagerCORE.order}
        /\ (i0 = 0 => (EagerCORE.blo,EagerCORE.capa)=(b0,c0)){2}
        /\ 0 <= i0{2} <= size EagerCORE.order{2} - 1
        /\ i0{2} = size EagerCORE.map{2}
        /\ size EagerCORE.order{2}-1 = size EagerCORE.map{1}
        /\ rcons EagerCORE.map{1} (last (b0,c0) m{2}) = m{2}
        /\ nth (b0,c0) EagerCORE.map{1} 0 = (nth b0 EagerCORE.order{1} 0, c0)
        /\ (0 < i0{2} => (EagerCORE.blo,EagerCORE.capa){2} =
            oget Perm.m{1}.[last (b0,c0) EagerCORE.map{2}])
        /\ EagerCORE.map{2} = take i0{2} m{2}
        /\ (Perm.m = permm /\ Perm.mi = permmi){2}
        /\ (forall y, y \in EagerCORE.map{1} => y \in dom Perm.m{1})
        /\ (forall j, 0 < j < size EagerCORE.map{1} =>
             let ej = nth (b0,c0) EagerCORE.map{1} j in
             let ej1 = nth (b0,c0) EagerCORE.map{1} (j-1) in
             let mj = nth b0 EagerCORE.order{1} j in
             Perm.m{1}.[ej1] = Some (ej.`1 +^ mj, ej.`2))
        /\ (EagerCORE.blo{1}, EagerCORE.capa{1}) = last (b0, c0) m{2}
        /\ 1 <= size EagerCORE.order{1}
      )
      (size EagerCORE.order{2} - 1 - i0{2});
      progress;1:auto.
    + sp;rcondf 1;auto;progress.
      + case(0<size EagerCORE.map{hr})=>Hi0;last first.
        + cut h:EagerCORE.map{hr} = [] by smt(size_eq0).
          rewrite h/=;cut[->->]:=H _;1:rewrite/#.
          by rewrite Block.WRing.add0r H7-H4 mem_nth/#.
        cut:=H5 Hi0;rewrite-nth_last.
        rewrite {1}H6 nth_take 1,2:/# -H3 nth_rcons-H2. 
        cut->/=:size EagerCORE.map{hr} - 1 < size EagerCORE.order{hr}-1 by rewrite/#.
        rewrite H8 1:/# oget_some/==>[[->->]].
        rewrite -Block.WRing.addrA Block.xorwK Block.WRing.addr0//=.
        rewrite H7 H6 size_take;1:smt(size_ge0).
        rewrite-H3 size_rcons-H2-addzA/= H11/=. 
        by cut/#:=mem_nth (b0,c0)EagerCORE.map{m}(size EagerCORE.map{hr})_;smt(size_ge0).
      + by rewrite/#.
      + by rewrite/#.
      + by rewrite/#.
      + by rewrite/#.
      + smt(size_rcons).
      + by rewrite last_rcons/#.
      + case(0<size EagerCORE.map{hr})=>Hi0;last first.
        + cut h:EagerCORE.map{hr} = [] by smt(size_eq0).
          rewrite h/=;cut[->->]:=H _;1:rewrite/#.
          rewrite Block.WRing.add0r(take_nth(b0,c0)0)/= 2:/#. 
          smt(size_rcons size_ge0).
        rewrite(take_nth(b0,c0));1:smt(size_rcons size_ge0).
        congr;cut:=H5 Hi0.
        rewrite-nth_last {1}H6 {2}H6. 
        rewrite nth_take 1,2:/#.
        rewrite size_take 1:/#.
        rewrite-H3 size_rcons-H2-addzA/=H11/=nth_rcons.
        rewrite-H3-H2/=.
        cut->/=:size EagerCORE.map{hr} - 1 < size EagerCORE.order{hr} - 1 by rewrite/#.
        rewrite H8 1:/# oget_some/==>[[->->]].
        rewrite -Block.WRing.addrA Block.xorwK Block.WRing.addr0//=.
        rewrite nth_rcons.
        by rewrite-H3-H2/=H12/=/#.
      by rewrite/#.
    
    sp;auto;progress.
    + smt(size_ge0 size_rcons).
    + smt(size_ge0 size_rcons).
    + smt(last_rcons).
    + smt(nth_rcons size_ge0). 
    + smt(take0).
    + smt(nth_rcons).
    + smt(last_rcons).
    + smt(size_ge0 size_rcons).
    + smt(size_ge0 size_rcons).
    + case(size map_R = 0)=>HmapR.
      + cut:=size_eq0 map_R;rewrite HmapR/==>{HmapR}HmapR.
        cut Hmap1:(size EagerCORE.map{1} = 0) by rewrite/#.
        cut:=size_eq0 EagerCORE.map{1};rewrite Hmap1/==>{Hmap1}Hmap1.
        rewrite Hmap1=>/={Hind}.
        move:H6;rewrite HmapR/==>[[->->]].
        by move:H2;rewrite Hmap1/==>[[->->]].
      cut h:size order_R = size map_R by rewrite/#.
      rewrite last_rcons H12 1:/# -nth_last {1}H13 nth_take 1,2:/#.
      rewrite nth_rcons-H9 size_rcons-addzA/=h.
      cut->/=:size map_R - 1 < size map_R by rewrite/#.
      cut->:size map_R = size EagerCORE.map{1} by rewrite/#.
      by rewrite nth_last/#.
    smt(size_ge0 size_rcons).

  inline*;wp.
  case(size EagerCORE.order{1} = 0).
  + sp;rcondf{1}1;2:rcondf{2}1;auto;progress;1,2:smt(size_eq0 size_ge0).
    while(={Perm.mi, Perm.m, k0} /\ i0{1} = i1{2} /\ k0{1} = n /\
        ={EagerCORE.map, EagerCORE.blo, EagerCORE.capa, EagerCORE.order} /\
        ={result0} /\
          size EagerCORE.order{2} = size EagerCORE.map{1} /\
          nth (b0, c0) EagerCORE.map{1} 0 = (nth b0 EagerCORE.order{1} 0, c0) /\
      (forall (y1 : block * capacity),
        y1 \in EagerCORE.map{1} => y1 \in dom Perm.m{1}) /\
      (0 = size EagerCORE.map{1} =>
        EagerCORE.blo{1} = b0 && EagerCORE.capa{1} = c0) /\
      (0 < size EagerCORE.map{1} =>
        (EagerCORE.blo{1}, EagerCORE.capa{1}) =
          oget Perm.m{1}.[last (b0, c0) EagerCORE.map{1}]) /\
          forall (j : int),
          0 < j < size EagerCORE.map{1} =>
          Perm.m{1}.[nth (b0, c0) EagerCORE.map{1} (j - 1)] =
          Some
      ((nth (b0, c0) EagerCORE.map{1} j).`1 +^
        nth b0 EagerCORE.order{1} j, (nth (b0, c0) EagerCORE.map{1} j).`2));auto;progress.
    + sp;if;auto;progress.
      + smt(mem_rcons dom_set in_fsetU1 last_rcons size_rcons size_ge0 nth_rcons).
      + smt(mem_rcons dom_set in_fsetU1 last_rcons size_rcons size_ge0 nth_rcons).
      + smt(mem_rcons dom_set in_fsetU1 last_rcons size_rcons size_ge0 nth_rcons).
      + smt(mem_rcons dom_set in_fsetU1 last_rcons size_rcons size_ge0 nth_rcons).
      + smt(mem_rcons dom_set in_fsetU1 last_rcons size_rcons size_ge0 nth_rcons).
      + smt(mem_rcons dom_set in_fsetU1 last_rcons size_rcons size_ge0 nth_rcons).
      + rewrite getP !nth_rcons. rewrite size_rcons in H11.
        cut->/=:j - 1 < size EagerCORE.map{2} by rewrite/#.
        rewrite H.
        case(j<size EagerCORE.map{2})=>Hj/=.
        + cut->/=:!nth (b0, c0) EagerCORE.map{2} (j - 1) =
             (EagerCORE.blo{2}, EagerCORE.capa{2})
            by cut/#:nth (b0, c0) EagerCORE.map{2} (j - 1) \in dom Perm.m{2};smt(mem_nth). 
          by rewrite H4//.
        cut->/=:j=size EagerCORE.map{2} by rewrite/#.
        cut->/=:!nth (b0, c0) EagerCORE.map{2} (size EagerCORE.map{2} - 1) =
             (EagerCORE.blo{2}, EagerCORE.capa{2}) by smt(mem_nth).
        by rewrite Block.WRing.addr0 H3;smt(get_oget mem_nth nth_last).
      + smt(mem_rcons dom_set in_fsetU1 last_rcons size_rcons size_ge0 nth_rcons).
      + smt(mem_rcons dom_set in_fsetU1 last_rcons size_rcons size_ge0 nth_rcons).
      + smt(mem_rcons dom_set in_fsetU1 last_rcons size_rcons size_ge0 nth_rcons).
      + smt(mem_rcons dom_set in_fsetU1 last_rcons size_rcons size_ge0 nth_rcons).
      + smt(mem_rcons dom_set in_fsetU1 last_rcons size_rcons size_ge0 nth_rcons).
      + smt(mem_rcons dom_set in_fsetU1 last_rcons size_rcons size_ge0 nth_rcons).
      + rewrite !nth_rcons. rewrite size_rcons in H9.
        cut->/=:j - 1 < size EagerCORE.map{2} by rewrite/#.
        rewrite H.
        case(j<size EagerCORE.map{2})=>Hj/=.
          by rewrite H4//.
        cut->/=:j=size EagerCORE.map{2} by rewrite/#.
        by rewrite Block.WRing.addr0 H3;smt(get_oget mem_nth nth_last).
      smt(mem_rcons dom_set in_fsetU1 last_rcons size_rcons size_ge0 nth_rcons size_eq0).
    smt(mem_rcons dom_set in_fsetU1 last_rcons size_rcons size_ge0 nth_rcons).


  while(={glob P, glob EagerCORE, result0, k0}
          /\ size EagerCORE.order{2} = size EagerCORE.map{1}
          /\ i1{2} <= size EagerCORE.order{2}
          /\ 1 <= i1{2} <= k0{2} /\ k0{2} = n
          /\ i1{2} = i0{1}
          /\ nth (b0, c0) EagerCORE.map{1} 0 = (nth b0 EagerCORE.order{1} 0, c0)
          /\ (forall (y1 : block * capacity),
              y1 \in EagerCORE.map{1} => y1 \in dom Perm.m{1})
          /\ (0 = size EagerCORE.map{1} =>
               (EagerCORE.blo{1}, EagerCORE.capa{1}) = (b0, c0))
          /\ (0 < size EagerCORE.order{1} =>
               (EagerCORE.blo{1}, EagerCORE.capa{1}) =
                oget Perm.m{1}.[last (b0, c0) EagerCORE.map{1}])
          /\ (forall (j : int), 0 < j < size EagerCORE.map{1} =>
              let ej = nth (b0, c0) EagerCORE.map{1} j in
              let ej1 = nth (b0, c0) EagerCORE.map{1} (j - 1) in
              let mj = nth b0 EagerCORE.order{1} j in
              Perm.m{1}.[ej1] = Some (ej.`1 +^ mj, ej.`2))).
  + sp;if;auto;progress.
    + smt(size_rcons size_ge0).
    + smt(size_rcons size_ge0).
    + smt(size_rcons size_ge0).
    + smt(size_rcons size_ge0).
    + smt(size_rcons size_ge0 nth_rcons).
    + smt(mem_rcons dom_set in_fsetU1).
    + smt(mem_rcons dom_set in_fsetU1 last_rcons size_rcons size_ge0).
    + smt(mem_rcons dom_set in_fsetU1 last_rcons size_rcons size_ge0).
    + smt(mem_rcons dom_set in_fsetU1 last_rcons size_rcons size_ge0).
    + rewrite getP !nth_rcons. rewrite size_rcons in H14.
      cut->/=:j - 1 < size EagerCORE.map{2} by rewrite/#.
      rewrite H.
      case(j<size EagerCORE.map{2})=>Hj/=.
      + cut->/=:!nth (b0, c0) EagerCORE.map{2} (j - 1) =
           (EagerCORE.blo{2}, EagerCORE.capa{2})
          by cut/#:nth (b0, c0) EagerCORE.map{2} (j - 1) \in dom Perm.m{2};smt(mem_nth). 
        by rewrite H7//.
      cut->/=:j=size EagerCORE.map{2} by rewrite/#.
      cut->/=:!nth (b0, c0) EagerCORE.map{2} (size EagerCORE.map{2} - 1) =
           (EagerCORE.blo{2}, EagerCORE.capa{2}) by smt(mem_nth).
      by rewrite Block.WRing.addr0 H6;smt(get_oget mem_nth nth_last).

    + smt(mem_rcons dom_set in_fsetU1 last_rcons size_rcons size_ge0).
    + smt(mem_rcons dom_set in_fsetU1 last_rcons size_rcons size_ge0).
    + smt(mem_rcons dom_set in_fsetU1 last_rcons size_rcons size_ge0).
    + smt(mem_rcons dom_set in_fsetU1 last_rcons size_rcons size_ge0 nth_rcons).
    + smt(mem_rcons dom_set in_fsetU1 last_rcons size_rcons size_ge0 nth_rcons).
    + smt(mem_rcons dom_set in_fsetU1 last_rcons size_rcons size_ge0 nth_rcons).
    + smt(mem_rcons dom_set in_fsetU1 last_rcons size_rcons size_ge0 nth_rcons).
    + smt(mem_rcons dom_set in_fsetU1 last_rcons size_rcons size_ge0 nth_rcons).
    + smt(mem_rcons dom_set in_fsetU1 last_rcons size_rcons size_ge0 nth_rcons).
    + rewrite !nth_rcons. rewrite size_rcons in H12.
      cut->/=:j - 1 < size EagerCORE.map{2} by rewrite/#.
      rewrite H.
      case(j<size EagerCORE.map{2})=>Hj/=.
        by rewrite H7//.
      cut->/=:j=size EagerCORE.map{2} by rewrite/#.
      by rewrite Block.WRing.addr0 H6;smt(get_oget mem_nth nth_last).
    wp;sp.

    conseq(:_==> ={glob P, glob EagerCORE, result0, k0}
          /\ size EagerCORE.order{2} = size EagerCORE.map{1}
          /\ nth (b0, c0) EagerCORE.map{1} 0 = (nth b0 EagerCORE.order{1} 0, c0)
          /\ (forall (y1 : block * capacity),
              y1 \in EagerCORE.map{1} => y1 \in dom Perm.m{1})
          /\ (0 = size EagerCORE.map{1} =>
               (EagerCORE.blo{1}, EagerCORE.capa{1}) = (b0, c0))
          /\ (0 < size EagerCORE.order{1} =>
               (EagerCORE.blo{1}, EagerCORE.capa{1}) =
                oget Perm.m{1}.[last (b0, c0) EagerCORE.map{1}])
          /\ (forall (j : int), 0 < j < size EagerCORE.map{1} =>
              let ej = nth (b0, c0) EagerCORE.map{1} j in
              let ej1 = nth (b0, c0) EagerCORE.map{1} (j - 1) in
              let mj = nth b0 EagerCORE.order{1} j in
              Perm.m{1}.[ej1] = Some (ej.`1 +^ mj, ej.`2)));1:smt(size_ge0).

    (* TODO : reprendre ici *)
    admit.
  qed.

  equiv core_blocksponge :
      Low.Indif(DFCn(CORE(P)),DPC(P),D).main ~
      Indif(DFC1(BlockSponge(P)),DPC(P),HiDist(D)).main :
      ={glob D, glob P} ==> ={res, C.c} /\ ={c}(C,HiDist).
  proof.
  transitivity Low.Indif(DFCn(EagerCORE(P)),DPC(P),D).main
    (={glob D, glob P} ==> ={res, C.c})
    (={glob D, glob P} ==> ={res, C.c} /\ ={c}(C,HiDist));progress;1:rewrite/#.
  + proc=>/=;call (_: ={glob P, C.c}); first 2 by sim.
    + by proc=> /=;inline*;sp;if;auto;sp;if;auto;sim.

    by inline*;auto;call(:true);auto. 

  transitivity Low.Indif(DFCn(EagCORE(P)),DPC(P),D).main
    (={glob D, glob P} ==> ={res, C.c})
    (={glob D, glob P} ==> ={res, C.c} /\ ={c}(C,HiDist));progress;1:rewrite/#.
  + proc.
    call (_: ={glob P, C.c}); first 2 by sim.
    + proc=> /=; sp. 
      if=>//=;auto;inline{1}1;inline{2}1;sp;if;auto;swap{1}3-2;swap{2}2.
      conseq(:_==> ={r0,glob P});progress;sp.
      replace{1} { while ; rest } by {
          EagerCORE(P).ewhile();
          rest;
        }
        (={glob P, EagerCORE.order, r0, p0, n0} /\ i{1} = 0
          /\ (EagerCORE.blo,EagerCORE.capa,EagerCORE.order){1} = (b0,c0,p0{1})
          ==> ={r0, glob P})
        (={glob P,glob EagerCORE, n0, p0, r0} ==> ={r0, glob P});
        progress;1:rewrite/#;first inline*;sim;auto;progress.
    
      (* eager part *)
      replace{2} {| (<@ as ewhile); rest } by {
          rest;
          EagerCORE.order <- take (size EagerCORE.order - 1) EagerCORE.order;
          ewhile;
        }
        (={glob P, glob EagerCORE, n0, p0, r0} ==> ={r0, glob P})
        (={glob P, glob EagerCORE, n0, p0, r0} ==> ={r0, glob P});
        progress;1:rewrite/#;last first.
      + 


      replace{2} { begin ; while } by {
          begin;
          while(i < n0) {
            EagerCORE(Perm).ewhile();
            EagerCORE.order <- rcons EagerCORE.order b0;
            i <- i + 1;
            (EagerCORE.blo, EagerCORE.capa) <@ 
              Perm.f(EagerCORE.blo, EagerCORE.capa);
            r0 <- rcons r0 EagerCORE.blo;
          }
        }
        (={glob P, glob EagerCORE, n0, p0, r0} ==> ={r0, glob P})
        (={glob P, glob EagerCORE, n0, p0, r0} ==> ={r0, glob P});
        progress;1:rewrite/#;last first.
      + while(={r0, p0, n0, i, glob P, glob EagerCORE});
        last by conseq(:_==> ={r0, p0, n0, i, glob P, glob EagerCORE});progress;sim.
        inline*;sp. swap{1}3 2;wp=>//=.
        splitwhile{2}1: i0 < size EagerCORE.order - 1.
        rcondt{2}2;progress.
        + by while(i0 < size EagerCORE.order);1:(sp;if);auto;smt(size_ge0).
        rcondf{2}6;progress.
        + seq 1 : (i0 = size EagerCORE.order - 1);last by sp;if;auto=>/#.
          by while(0 <= i0 < size EagerCORE.order);1:(sp;if);auto;smt(size_ge0 size_rcons).
        wp=>/=.
        conseq(:_==> ={glob P, glob EagerCORE, r0, x});progress;sim.
        wp.
        conseq(:_==> ={glob P, EagerCORE.blo, EagerCORE.capa, r0}
                  /\ i0{2} = size EagerCORE.order{2} - 1
                  /\ rcons EagerCORE.order{1} b0 = EagerCORE.order{2});progress.
        + by rewrite nth_rcons size_rcons-addzA/=Block.WRing.addr0.
        conseq(:_==> ={glob P, EagerCORE.blo, EagerCORE.capa, r0}
                  /\ i0{2} = size EagerCORE.order{1});progress.
        + smt(size_rcons).
        while( ={glob P, EagerCORE.blo, EagerCORE.capa, r0, i0}
            /\ rcons EagerCORE.order{1} b0 = EagerCORE.order{2}
            /\ 0 <= i0{2} <= size EagerCORE.order{1});
          last auto;smt(size_ge0 size_rcons).
        wp;conseq(:_==> ={glob P, EagerCORE.blo, EagerCORE.capa, r0, i0}
                     /\ x0{1} = x{2});1:smt(size_rcons).
        by sp;sim;smt(nth_rcons size_rcons).        
      + 

    by inline*;auto;call(:true);auto.


  + proc;inline{2}3;wp;call (_: ={glob P, C.c} /\ ={c}(C,HiDist)). 
    + by proc;inline*;sp;auto;if;auto;sp;rcondt{2}1;auto;sp;if;auto. 
    + by proc;inline*;sp;auto;if;auto;sp;rcondt{2}1;auto;sp;if;auto.
    proc;inline*;sp;auto.
    if;1:progress=>/#;sp;wp.
    rcondt{1}1;1:auto=>/#;sp.
    rcondt{2}1;1:auto=>/#;sp.
    rcondt{2}1;1:auto;progress.
    + rewrite size_cat nseq0/=. 
      cut/#:size p{hr} <= sumid (size p{hr}) (size p{hr} + n{hr}).
      rewrite  BIA.big_ltn 1:/# /=. 
      cut/#:=sumr_ge0_seq predT(fun n=>n)(range (size p{hr} + 1) (size p{hr} + n{hr})) _. 
      smt(mem_iota size_ge0).
    sp;rcondt{2}1;1:(auto;smt(parseK formatK));sp.
    conseq(:_==> r0{1} = r{2} /\ ={glob P} /\ C.c{2} = HiDist.c{2}
          /\ i{1} = n{1}
          /\ C.c{1} + sumid (size p{1}) (size p{1} + i{1}) = C.c{2});progress.
    while(   r0{1} = r{2} /\ ={glob P,p} /\ C.c{2} = HiDist.c{2}
          /\ C.c{1} + sumid (size p{1}) (size p{1} + n{2}) <= max_size
          /\ C.c{1} + sumid (size p{1}) (size p{1} + i{1}) = C.c{2}
          /\ (n0, EagerCORE.blo, EagerCORE.capa){1} = (n, sa, sc){2}
          /\ EagerCORE.order{1} = format p{2} i{1}
          /\ i{2} = i{1} + 1
          /\ 0 < i{1} <= n0{1}
          /\ valid p{2}).
    + sp;rcondt{2}1;auto;progress.
      + cut/#:sumid (size p{hr}) (size p{hr} + i{m}) + 
              size (format p{hr} (i{m} + 1)) <=
              sumid (size p{hr}) (size p{hr} + n{hr}).
        rewrite size_cat size_nseq-addzA/=/max H0/=.
        cut/=<-:=BIA.big_int_recr (size p{hr} + i{m})(size p{hr})(fun n=>n)_;1:rewrite/#. 
        smt(sumid_leq size_ge0).
      swap{2}5;sp;auto.
      rcondt{2}1;1:(auto;smt(formatK parseK)).
      conseq(:_==> ={glob P} /\
          (EagerCORE.blo, EagerCORE.capa){1} = (sa, sc){2});progress.
      + rewrite size_cat-(addzA _ 1)/=size_nseq/max H1/=/#.
      + rewrite size_cat-(addzA _ 1)/=size_nseq/max H1/=. search BIA.big (+) 1.
        by cut/#:=BIA.big_int_recr_cond(size p{2} + i{1})(size p{2})predT(fun n=>n)_;rewrite/#.
      + by rewrite rcons_cat-nseqSr 1:/# -addzA/=/format-addzA/=.
      + rewrite/#.
      + rewrite/#.
      + rewrite/#.
      while(={glob P} /\
          (i1,EagerCORE.order,EagerCORE.blo,EagerCORE.capa){1} = (i0,p0,sa,sc){2});auto.
      + by sp;if;auto.
      progress.
      + by rewrite rcons_cat-nseqSr 1:/# -addzA/=/format-addzA/=.
      + by move:H6;rewrite rcons_cat-nseqSr 1:/# -addzA/=/format-addzA/=.
      by move:H6;rewrite rcons_cat-nseqSr 1:/# -addzA/=/format-addzA/=.
    wp;conseq(:_==> ={glob P} /\
          (EagerCORE.blo, EagerCORE.capa){1} = (sa, sc){2});progress.
    + by rewrite size_cat nseq0/#.
    + by rewrite size_cat nseq0/= BIA.big_int1.
    + by rewrite/format nseq0 cats0/#.
    + rewrite/#.
    + rewrite/#.
    + rewrite/#.
    + rewrite/#.
    while(={glob P} /\
        (i0,EagerCORE.order,EagerCORE.blo,EagerCORE.capa){1} = (i0,p0,sa,sc){2});auto.
    + by sp;if;auto.
    progress.
    + by rewrite/format nseq0 cats0/#.
    + by rewrite size_cat nseq0/#.
    + by move:H3;rewrite size_cat nseq0/#.
    by auto;progress.
  by inline*;auto;call(:true);auto.
  qed.
  
  equiv icore_iblocksponge :
      Low.Indif(DFCn(ICORE),DPC(LowSim(S,ICORE)),D).main ~
      Indif(DFC1(IBlockSponge),DPC(S(IBlockSponge)),HiDist(D)).main :
      ={glob S, glob D} ==> ={res, C.c} /\ ={c}(C,HiDist).
  proof.
  proc;inline{2}3;wp;call (_:
      ={glob S,C.c} /\ ={c}(C,HiDist)
  /\ INV IBlockSponge.m{2} ICORE.m{1}).
  + proc;inline*;sp;if;auto.
    swap{2}3;sp;rcondt{2}1;auto.
    call(: ={C.c} /\ ={c}(C,HiDist) /\ INV IBlockSponge.m{2} ICORE.m{1})=>/=;auto.
    proc=> /=; sp;if;1:progress=>/#;inline*;sp;auto.
    rcondt{1}1;1:auto=>/#.
    wp.
    splitwhile{1}1:i0<n.
    rcondt{1}2;progress.
    + by while(i0<=n);2:auto=>/#;sp;if;auto=>/#.
    rcondf{1}8;progress.
    + wp;seq 1:(i0=n);2:(sp;if;auto=>/#).
      by while(i0<=n);2:auto=>/#;sp;if;auto=>/#.
    wp. 
    conseq(:_==> INV IBlockSponge.m{2} ICORE.m{1} /\
      ICORE.m{1}.[(p0{1}, n0{1})] = IBlockSponge.m{2}.[x1{2}]);progress.
    + smt(last_rcons).
    seq 3 2 : (INV IBlockSponge.m{2} ICORE.m{1} /\ 
      parse x1{2} = (p0{1}, n0{1}) /\ valid p0{1} /\ 0 < n0{1});
      last if;1:smt(in_dom);auto;smt(getP formatK parseK).
    wp;conseq(:_==> INV IBlockSponge.m{2} ICORE.m{1} /\ i0{1} = n{1});1:progress=>/#.
    while( ={n,p} /\ INV IBlockSponge.m{2} ICORE.m{1}
        /\ i0{1} = i{2} /\ valid p{1} /\ 0 < n{2} /\ 0 < i0{1} <= n{1}).
    + sp;if;auto;smt(in_dom formatK parseK getP).
    by auto;smt(in_dom formatK parseK getP).
   
  + proc;sp;if;auto;swap{2}1;inline{2}1;sp;rcondt{2}1;auto.
    call(: ={C.c} /\  C.c{1} = HiDist.c{2}/\ INV IBlockSponge.m{2} ICORE.m{1})=> //.
    proc=> /=; sp;if;1:progress=>/#;inline*;sp;auto.
    rcondt{1}1;1:auto=>/#.
    wp.
    splitwhile{1}1:i0<n.
    rcondt{1}2;progress.
    + by while(i0<=n);2:auto=>/#;sp;if;auto=>/#.
    rcondf{1}8;progress.
    + wp;seq 1:(i0=n);2:(sp;if;auto=>/#).
      by while(i0<=n);2:auto=>/#;sp;if;auto=>/#.
    wp. 
    conseq(:_==> INV IBlockSponge.m{2} ICORE.m{1} /\
      ICORE.m{1}.[(p0{1}, n0{1})] = IBlockSponge.m{2}.[x1{2}]);progress.
    + smt(last_rcons).
    seq 3 2 : (INV IBlockSponge.m{2} ICORE.m{1} /\ 
      parse x1{2} = (p0{1}, n0{1}) /\ valid p0{1} /\ 0 < n0{1});
      last if;1:smt(in_dom);auto;smt(getP formatK parseK).
    wp;conseq(:_==> INV IBlockSponge.m{2} ICORE.m{1} /\ i0{1} = n{1});1:progress=>/#.
    while( ={n,p} /\ INV IBlockSponge.m{2} ICORE.m{1}
        /\ i0{1} = i{2} /\ valid p{1} /\ 0 < n{2} /\ 0 < i0{1} <= n{1}).
    + sp;if;auto;smt(in_dom formatK parseK getP).
    by auto;smt(in_dom formatK parseK getP).

  + proc=> /=; sp;if;1:progress=>/#;inline*;sp;auto.
    rcondt{1}1;1:auto=>/#;wp.
    conseq(:_==> INV IBlockSponge.m{2} ICORE.m{1}
              /\ C.c{1} + sumid (size p{1}) (size p{1} + n{1}) =  C.c{2}
              /\ HiDist.c{2} = C.c{2} /\ r0{1} = r{2});progress.
    while( INV IBlockSponge.m{2} ICORE.m{1}
        /\ ={i,p,n} /\ n0{1} = n{2} /\ p0{1} = p{1}
        /\ valid p{1} /\ 0 < n{1} /\ 0 < i{1} <= n0{1} + 1
        /\ C.c{1} + sumid (size p{1}) (size (format p{1} i{1})) =  C.c{2}
        /\ C.c{1} + sumid (size p{1}) (size p{1} + n{1}) <= max_size
        /\ (forall j, 0 < j < i{1} => 
              format p{2} j \in dom IBlockSponge.m{2})
        /\ HiDist.c{2} = C.c{2} /\ r0{1} = r{2});last first.
    + auto;progress.
      + rewrite/#.
      + by rewrite size_cat nseq0/= BIA.big_geq/=. 
      + smt(in_dom).
      by rewrite size_cat size_nseq max_ler /#.
    sp.
    rcondt{2}1;1:auto;progress.
    + rewrite-addzA. 
      cut/=<-:=BIA.big_int_recr_cond(size (format p{hr} i{hr}))(size p{hr})predT(fun n=>n)_.
      + by rewrite size_cat size_nseq max_ler/#.
      cut/#:=sumid_leq(size p{hr})(size (format p{hr} i{hr}) + 1)(size p{hr} + n{hr})_ _;1:smt(size_ge0).
      by rewrite size_cat size_nseq max_ler/#.
    swap{2}1 7;sp.
    wp=>/=.
    conseq(:_==> INV IBlockSponge.m{2} ICORE.m{1}
              /\ (forall (j : int),
                   0 < j < i{1} + 1 => format p{2} j \in dom IBlockSponge.m{2})
              /\ oget ICORE.m{1}.[(p1{1}, n1{1})] = bs{2});progress.
    + rewrite/#.
    + rewrite/#.
    + rewrite -addzA;congr=>//. 
      rewrite 2!size_cat-addzA/=2!size_nseq{1}/max H3/=max_ler 1:/#.
      cut/#:=BIA.big_int_recr_cond(size p{2} + (i{2} -1))(size p{2})predT(fun n=>n)_;rewrite/#.
    + rewrite -4!addzA;congr=>//;congr. 
      by rewrite size_cat/=size_nseq max_ler 1:/#.
    rcondt{2}1;1:(auto;smt(parseK formatK)).
    alias{2}1 m = IBlockSponge.m;sp;wp=>/=;swap{2}2-1;sp.
    if{1};2:rcondf{2}2;1:rcondt{2}2;progress.
    + while(!(format p0 n0) \in dom IBlockSponge.m /\ 0 < i0 );auto.
      + sp;if;auto;progress. 
        + by rewrite dom_set in_fsetU1 H/=/format;smt(catsI size_nseq).
        + by rewrite/#.
        + by rewrite/#.
        smt(in_dom formatK parseK).
      rnd=>//=.
      conseq(:_==> INV m{2} ICORE.m{1} /\ IBlockSponge.m{2} = m{2});progress.
      + smt(getP formatK parseK in_dom).
      + smt(getP formatK parseK in_dom).
      + smt(getP formatK parseK in_dom).
      conseq(:_==> IBlockSponge.m{2} = m{2});progress.
      while{2}(IBlockSponge.m{2} = m{2} /\ 0 < i0{2} /\ (forall (j : int),
         0 < j < n0{2} => format p0{2} j \in dom m{2}))(n0{2}-i0{2});auto.
      + sp;rcondf 1;auto=>/#.
      smt(parseK formatK).
    + conseq(:_==> IBlockSponge.m = m);1:smt(in_dom parseK formatK).
      while(IBlockSponge.m = m /\ 0 < i0 /\ (forall (j : int),
         0 < j < n0 => format p0 j \in dom m));auto.
      + sp;rcondf 1;auto=>/#.
      smt(parseK formatK).
    + conseq(:_==> IBlockSponge.m{2} = m{2});1:smt(in_dom parseK formatK).
      while{2}(IBlockSponge.m{2} = m{2} /\ 0 < i0{2} /\ (forall (j : int),
         0 < j < n0{2} => format p0{2} j \in dom m{2}))(n0{2}-i0{2});auto.
      + sp;rcondf 1;auto=>/#.
      smt(parseK formatK).

  by inline*;auto;call(:true);auto;smt(in_dom dom0 in_fset0).
  qed.



end section PROOF.
