require import Core Logic Distr.
require import Int IntExtra Real List NewFMap FSet.
require import StdOrder.
(*---*) import IntOrder.

require import NewCommon.
(*---*) import Block DBlock Capacity DCapacity.

(*** THEORY PARAMETERS ***)
(** Validity of Functionality Queries **)
op valid: block list -> bool.
axiom valid_spec p: valid p => p <> [].

(** Validity and Parsing/Formatting of Functionality Queries **)
op format (p : block list) (n : int) = p ++ nseq (n - 1) b0.
op parse: block list -> (block list * int).

axiom formatK bs: format (parse bs).`1 (parse bs).`2 = bs.
axiom parseK p n: 0 < n => valid p => parse (format p n) = (p,n).

lemma parse_injective: injective parse.
proof. by move=> bs1 bs2 eq_format; rewrite -formatK eq_format (@formatK bs2). qed.

lemma parse_valid p: valid p => parse p = (p,1).
proof.
move=>h;cut{1}->:p=format p 1;2:smt(parseK).
by rewrite/format/=nseq0 cats0.
qed.

(******************* Useful lemmas ******************)
lemma take_nseq (b:block) i j : take i (nseq j b) = nseq (min i j) b.
proof.
move:i;elim/natind=>//=.
+ smt(take_le0 nseq0_le).
move=>i hi0 hind.
case(i + 1 <= j)=>hi1j.
+ rewrite (take_nth b);1:smt(size_nseq).
  rewrite hind nth_nseq 1:/# //=-nseqSr/#.
rewrite take_oversize;smt(size_nseq).
qed.


(*** DEFINITIONS ***)
(** Low-Level Definitions **)
require (*--*) NewCore.

clone import NewCore as Low with
  op valid bs <- let (b,s) = bs in valid b /\ 0 < s
proof * by done.

(** High-Level Definitions **)
(* Indifferentiability *)
clone import Indifferentiability as BS_Ind with
  type p     <- block * capacity,
  type f_in  <- block list,
  type f_out <- block
proof * by done.

(* BlockSponge Construction *)
module (BlockSponge : CONSTRUCTION) (P : DPRIMITIVE) : FUNCTIONALITY = {
  proc init() = {}

  proc f(p : block list) : block = {
    var (sa,sc) <- (b0,c0);
    var i <- 0;
    var (x,n) <- parse p;

    if (valid x /\ 0 < n) {
      while (i < size p) {
        (sa,sc) <@ P.f((sa +^ nth witness p i,sc));
        i <- i + 1;
      }
    }
    return sa;
  }
}.

(* Ideal Block Sponge Functionality *)
module IBlockSponge : FUNCTIONALITY = {
  var m : (block list,block) fmap

  proc init() = {
    m <- map0;
  }

  proc fill_in(x) = {
    if (!mem (dom m) x) {
      m.[x] <$ bdistr;
    }
    return oget m.[x];
  }

  proc f(x : block list) = {
    var bs <- b0;
    var i <- 0;

    var (p,n) <- parse x;
    if (valid p /\ 0 < n) {
      while (i < n) {
        fill_in(take (size p + i) x);
        i <- i + 1;
      }
      bs <@ fill_in(x);
    }

    return bs;
  }
}.


(* Parametric Simulator *) 
module (HiSim (S : Low.SIMULATOR) : SIMULATOR) (F : DFUNCTIONALITY) = {
  module LoF = {
    proc f(p : block list, n : int): block list = {
      var r <- [];
      var b;
      var i <- 1;

      if (valid p /\ 0 < n)
      {
        while (i <= n) {
          b <@ F.f(format p i);
          r <- rcons r b;
          i <- i + 1;
        }
        
      }
      return r;
    }
  }

  proc init = S(LoF).init
  proc f    = S(LoF).f
  proc fi   = S(LoF).fi
}.

pred INV (mc : (block list,block) fmap) (mb : (block list * int,block) fmap) =
  forall p, mc.[p] = mb.[parse p].

(* Constructed Distinguisher *)
module (HiDist (D : Low.DISTINGUISHER) : DISTINGUISHER)
           (F : DFUNCTIONALITY) (P : DPRIMITIVE) = {
  module HiF = {
    proc f(p : block list, n : int) = {
      var r <- [];
      var b <- b0;
      var i <- 1;
    
      if (valid p /\ 0 < n) {
        while(i <= n) {
          b <@ F.f(format p i);
          r <- rcons r b;
          i <- i + 1;
        }
      }
      return r;
    }
  }

  proc distinguish = D(HiF,P).distinguish
}.


(*** PROOF
     forall P D S,
         HiDist(D)^{BlockSponge(P),P} ~ HiDist(D)^{IBlockSponge,HiSim(S)(IBlockSponge)}
       => D^{Core(P),P} ~ D^{ICore,S(ICore)} ***)
section PROOF.
  declare module P : PRIMITIVE     { Low.ICORE, IBlockSponge, HiSim }.
  declare module S : Low.SIMULATOR { Low.ICORE, IBlockSponge, HiSim, P }.
  declare module D : Low.DISTINGUISHER { Low.ICORE, IBlockSponge, HiSim, P, S }.



  (* FIXME : is this the eager we want ? *)
  local module EagerCORE (P : Low.PRIMITIVE) : Low.FUNCTIONALITY = {
    var order : block list
    var capa  : capacity
    var blo   : block
    proc init() = {
      order <- [];
      capa <- c0;
      blo <- b0;
      CORE(P).init();
    }
    proc f (p : block list, n : int) = {
      var r  : block list;
      var i  : int;

      (blo,capa) <- (b0,c0);
      r <- [];
      i <- 0;
      if (valid p /\ 0 < n) {
        while(i < size p) {
          (blo,capa) <@ P.f(blo +^ nth witness p i, capa);
          i <- i + 1;
        }
        i <- 1;
        order <- p;
        r <- rcons r blo;
        while (i < n) {
          (blo,capa) <@ P.f(blo,capa);
          order <- rcons order b0;
          r <- rcons r blo;
          i <- i + 1;
        }
      }
      return r;
    }
    proc ewhile() = {
      var i : int <- 0;
      while(i < size order) {
        (blo,capa) <@ P.f(blo +^ nth witness order i,capa);
        i <- i + 1;
      } 
    }
  }.

  lemma core_blocksponge &m :
      Pr[Low.Indif(CORE(P),P,D).main() @ &m: res] =
      Pr[Indif(BlockSponge(P),P,HiDist(D)).main() @ &m: res].
  proof.
  (* cut->: *)
  (*     Pr[Low.Indif(EagerCORE(P),P,D).main() @ &m: res] = *)
  (*     Pr[Low.Indif(CORE(P),P,D).main() @ &m: res]. *)
  byequiv(: ={glob D, glob P} ==>_)=>//=;proc.
  call (_: ={glob P}); first 2 by sim.
  + proc=> /=; sp;if=>//=.
    inline*;sp;wp. 
    (* eager part *)
    admit.

  by inline*;auto;call(:true);auto.
  qed.



  lemma icore_iblocksponge &m :
      Pr[Low.Indif(ICORE,S(ICORE),D).main() @ &m: res] =
      Pr[Indif(IBlockSponge,HiSim(S,IBlockSponge),HiDist(D)).main() @ &m: res].
  proof.
  byequiv(: ={glob D, glob S} ==>_)=>//=;proc.
  call (_:    ={glob S} /\ INV IBlockSponge.m{2} ICORE.m{1}).
  + proc (INV IBlockSponge.m{2} ICORE.m{1})=> //.
    proc=> /=; sp;if=> [&1 &2 [#] <*>| |] //=.
    inline{2} 1.1.
    inline*.
    while( INV IBlockSponge.m{2} ICORE.m{1}
        /\ 0 < i{1} <= n{1} + 1
        /\ ={n,p,r,i}
        /\ valid p{1}
        /\ 0 < n{1}
        /\ (forall j, 0 < j < i{1} => 
              format p{2} j \in dom IBlockSponge.m{2}));last auto=>/#. 
    rcondt{2}5;auto;1:smt(parseK). 
    swap{2}6-1;sp.
    conseq(:_==> INV IBlockSponge.m{2} ICORE.m{1} /\
            (forall j, 0 < j <= n0{1} => 
              format p0{1} j \in dom IBlockSponge.m{2}));1:smt(parseK formatK).
    conseq(: INV IBlockSponge.m{2} ICORE.m{1} /\ (forall (j : int),
              0 < j < n0{1} => format p0{1} j \in dom IBlockSponge.m{2}) /\
              (p0,n0){1} = parse x1{2} /\ (x=x1){2} /\ ={p0,n0} /\ 
              n0{1} = i{2} /\ 0 <= i0{2} < i{2}
              ==> _);1:smt(parseK formatK). 
    seq 1 1 : (INV IBlockSponge.m{2} ICORE.m{1} /\ 0 < n0{2} /\
              (forall (j : int), 0 < j <= n0{1} => 
                format p0{1} j \in dom IBlockSponge.m{2}) /\
              (p0,n0){1} = parse x1{2} /\ ={p0,n0} /\ (x=x1){2});last first. 
    + rcondf{2}1;auto;smt(parseK formatK).
    splitwhile{2}1:(i0+1<n0).
    seq 0 1:(INV IBlockSponge.m{2} ICORE.m{1} /\ 0 < n0{2} /\ i0{2} + 1 = n0{2}
                /\ (x=x1){2} /\ (forall (j : int), 0 < j < n0{1} => 
                format p0{1} j \in dom IBlockSponge.m{2}) /\
              (p0,n0){1} = parse x1{2} /\ ={p0,n0} /\ (x=x1){2});last first. 
    + rcondt{2}1;1:auto=>/#;rcondf{2}4;1: by progress;sp;if;auto=>/#.
      sp;if;auto;progress. 
      + rewrite-(formatK x1{2})-H2/=take_cat addzAC/=-addzA/=take_nseq/min/=.
        cut->/=:!size p0{2} + i0{2} < size p0{2} by rewrite/#.
        smt(in_dom formatK).
      + move:H3;rewrite-(formatK x1{2})-H2/=take_cat addzAC/=-addzA/=take_nseq/min/=.
        cut->/=:!size p0{2} + i0{2} < size p0{2} by rewrite/#.
        smt(in_dom formatK).
      + rewrite-(formatK x1{2})-H2/=take_cat addzAC/=-addzA/=take_nseq/min/=.
        smt(getP parseK formatK). 
      + rewrite-(formatK x1{2})-H2/=take_cat addzAC/=-addzA/=take_nseq/min/=.
        smt(in_dom getP parseK formatK). 
      + case(j=i0{2} + 1)=>//=;2:rewrite/#.
        smt(in_dom getP parseK formatK). 
    while{2}((p0{2}, n0{2}) = parse x1{2} /\ (x=x1){2} /\ 0 <= i0{2} < n0{2} /\
                INV IBlockSponge.m{2} ICORE.m{1} /\ (p0,n0){1} = parse x1{2} /\
              ={p0,n0} /\ (forall (j : int), 0 < j < n0{2} => 
                format p0{2} j \in dom IBlockSponge.m{2}))(n0{2}-i0{2});progress.
    + sp;rcondf 1;auto;progress. 
      + rewrite-(formatK x1{hr})-H3/=take_cat addzAC/=/=take_nseq/min/=.
        cut->/=:!size p0{hr} + i0{hr} < size p0{hr} by rewrite/#.
        by cut/#:=H4 (i0{hr}+1).
      + by rewrite/#.
      by rewrite/#.
    by auto=>/#.

  + proc (INV IBlockSponge.m{2} ICORE.m{1})=> //.
    proc=> /=; sp;if=> [&1 &2 [#] <*>| |] //=.
    inline{2} 1.1.
    inline*.
    while( INV IBlockSponge.m{2} ICORE.m{1}
        /\ 0 < i{1} <= n{1} + 1
        /\ ={n,p,r,i}
        /\ valid p{1}
        /\ 0 < n{1}
        /\ (forall j, 0 < j < i{1} => 
              format p{2} j \in dom IBlockSponge.m{2}));last auto=>/#. 
    rcondt{2}5;auto;1:smt(parseK). 
    swap{2}6-1;sp.
    conseq(:_==> INV IBlockSponge.m{2} ICORE.m{1} /\
            (forall j, 0 < j <= n0{1} => 
              format p0{1} j \in dom IBlockSponge.m{2}));1:smt(parseK formatK).
    conseq(: INV IBlockSponge.m{2} ICORE.m{1} /\ (forall (j : int),
              0 < j < n0{1} => format p0{1} j \in dom IBlockSponge.m{2}) /\
              (p0,n0){1} = parse x1{2} /\ (x=x1){2} /\ ={p0,n0} /\ 
              n0{1} = i{2} /\ 0 <= i0{2} < i{2}
              ==> _);1:smt(parseK formatK). 
    seq 1 1 : (INV IBlockSponge.m{2} ICORE.m{1} /\ 0 < n0{2} /\
              (forall (j : int), 0 < j <= n0{1} => 
                format p0{1} j \in dom IBlockSponge.m{2}) /\
              (p0,n0){1} = parse x1{2} /\ ={p0,n0} /\ (x=x1){2});last first. 
    + rcondf{2}1;auto;smt(parseK formatK).
    splitwhile{2}1:(i0+1<n0).
    seq 0 1:(INV IBlockSponge.m{2} ICORE.m{1} /\ 0 < n0{2} /\ i0{2} + 1 = n0{2}
                /\ (x=x1){2} /\ (forall (j : int), 0 < j < n0{1} => 
                format p0{1} j \in dom IBlockSponge.m{2}) /\
              (p0,n0){1} = parse x1{2} /\ ={p0,n0} /\ (x=x1){2});last first. 
    + rcondt{2}1;1:auto=>/#;rcondf{2}4;1: by progress;sp;if;auto=>/#.
      sp;if;auto;progress. 
      + rewrite-(formatK x1{2})-H2/=take_cat addzAC/=-addzA/=take_nseq/min/=.
        cut->/=:!size p0{2} + i0{2} < size p0{2} by rewrite/#.
        smt(in_dom formatK).
      + move:H3;rewrite-(formatK x1{2})-H2/=take_cat addzAC/=-addzA/=take_nseq/min/=.
        cut->/=:!size p0{2} + i0{2} < size p0{2} by rewrite/#.
        smt(in_dom formatK).
      + rewrite-(formatK x1{2})-H2/=take_cat addzAC/=-addzA/=take_nseq/min/=.
        smt(getP parseK formatK). 
      + rewrite-(formatK x1{2})-H2/=take_cat addzAC/=-addzA/=take_nseq/min/=.
        smt(in_dom getP parseK formatK). 
      + case(j=i0{2} + 1)=>//=;2:rewrite/#.
        smt(in_dom getP parseK formatK). 
    while{2}((p0{2}, n0{2}) = parse x1{2} /\ (x=x1){2} /\ 0 <= i0{2} < n0{2} /\
                INV IBlockSponge.m{2} ICORE.m{1} /\ (p0,n0){1} = parse x1{2} /\
              ={p0,n0} /\ (forall (j : int), 0 < j < n0{2} => 
                format p0{2} j \in dom IBlockSponge.m{2}))(n0{2}-i0{2});progress.
    + sp;rcondf 1;auto;progress. 
      + rewrite-(formatK x1{hr})-H3/=take_cat addzAC/=/=take_nseq/min/=.
        cut->/=:!size p0{hr} + i0{hr} < size p0{hr} by rewrite/#.
        by cut/#:=H4 (i0{hr}+1).
      + by rewrite/#.
      by rewrite/#.
    by auto=>/#.


  + proc=> /=; sp;if=> [&1 &2 [#] <*>| |] //=.
    inline{2} 1.1.
    inline*.
    while( INV IBlockSponge.m{2} ICORE.m{1}
        /\ 0 < i{1} <= n{1} + 1
        /\ ={n,p,r,i}
        /\ valid p{1}
        /\ 0 < n{1}
        /\ (forall j, 0 < j < i{1} => 
              format p{2} j \in dom IBlockSponge.m{2}));last auto=>/#. 
    rcondt{2}5;auto;1:smt(parseK). 
    swap{2}6-1;sp.
    conseq(:_==> INV IBlockSponge.m{2} ICORE.m{1} /\ 
              (forall (j : int), 0 < j <= i{2} => 
                format p{2} j \in dom IBlockSponge.m{2}));1:smt(formatK parseK).
    seq 1 1 :(INV IBlockSponge.m{2} ICORE.m{1} /\ 0 < i{2} /\
              (forall (j : int), 0 < j <= i{2} => 
                format p{2} j \in dom IBlockSponge.m{2}) /\
              x1{2} = format p{2} i{2});last first.
    + rcondf{2}1;auto=>/#. 
    conseq(:_==> INV IBlockSponge.m{2} ICORE.m{1} /\ 
              (forall (j : int), 0 < j <= i{2} => 
                format p{2} j \in dom IBlockSponge.m{2}));1:smt(formatK parseK).
    if{1}.
    + splitwhile{2}1:i0+1<n0.
      rcondt{2}2;1:auto.
      + by while(i0<n0);auto;1:(sp;if);auto;smt(parseK formatK). 
      rcondf{2}5;1:auto.
      + seq 1 : (i0 = n0 -1);2:by sp;if;auto=>/#.
        by while(i0<n0);1:(sp;if);auto;smt(parseK formatK).
      rcondt{2}3;1:auto.
      + alias 1 m = IBlockSponge.m;sp.
        conseq(:_==> i0=n0-1 /\ IBlockSponge.m = m /\ p = p0 /\ i = n0);progress.
        + by rewrite take_cat addzAC/=take_nseq/min/=;smt(in_dom formatK parseK).
        conseq(:_==> i0=n0-1 /\ IBlockSponge.m = m);1:smt(formatK parseK).
        while(0 <= i0 < n0 /\ (forall (j : int), 0 <= j < n0 - 1 => 
                take (size p0 + j) x \in dom m) /\ IBlockSponge.m = m);progress.
        + rcondf 2;auto=>/#.
        auto;progress;1,3:smt(formatK parseK).
        rewrite take_cat addzAC/=take_nseq. 
        cut->/=:p0{hr}=p{hr} by smt(parseK formatK). 
        cut h:i{hr}=n0{hr} by smt(formatK parseK). 
        by rewrite h;cut/#:=H5 (j+1).
      wp;rnd=>/=. 
      alias{2} 1 m = IBlockSponge.m;sp.
      conseq(:_==> i0{2} = n0{2} - 1 /\ IBlockSponge.m{2} = m{2} /\ 
              x0{2} = format p{2} n0{2});1:smt(formatK parseK getP dom_set in_dom).
      wp;conseq(:_==> i0{2} = n0{2} - 1 /\ m{2} = IBlockSponge.m{2});progress. 
      + rewrite take_cat addzAC/=take_nseq. 
        cut->/=:p0{2}=p{2} by smt(parseK formatK). 
        cut h:i{2}=n0{2} by smt(formatK parseK).
        by rewrite h min_lel///format;smt(nseq0 cats0).
      while{2}(0 <= i0{2} < n0{2} /\ (forall (j : int), 0 <= j < n0{2} - 1 => 
                take (size p0{2} + j) x{2} \in dom m{2}) /\ 
                IBlockSponge.m{2} = m{2})(n0{2}-i0{2}-1);progress.
      + rcondf 2;auto=>/#.
      auto;progress;1,3..:smt(formatK parseK).
      rewrite take_cat addzAC/=take_nseq. 
      cut->/=:p0{2}=p{2} by smt(parseK formatK). 
      cut h:i{2}=n0{2} by smt(formatK parseK). 
      by rewrite h;cut/#:=H5 (j+1).
    rewrite/=.
    alias{2}1 m = IBlockSponge.m;sp.
    conseq(:_==> m{2} = IBlockSponge.m{2});1:smt(in_dom formatK parseK).
    while{2}(0 <= i0{2} <= n0{2} /\ (forall (j : int), 0 <= j < n0{2} => 
                take (size p0{2} + j) x{2} \in dom m{2}) /\ 
                IBlockSponge.m{2} = m{2})(n0{2}-i0{2});progress.
    + rcondf 2;auto=>/#.
    auto;progress;1,3..:smt(formatK parseK). 
    rewrite take_cat addzAC/=take_nseq. 
    cut->/=:p0{2}=p{2} by smt(parseK formatK). 
    cut h:i{2}=n0{2} by smt(formatK parseK). 
    rewrite h;case(j=0)=>[->/=|]. 
    + rewrite-take_nseq take0 cats0.
      by cut/=:=H5 1;smt(in_dom parseK formatK nseq0 cats0).
    cut->/=:!size p{2} + j < size p{2} by rewrite/#.
    by cut:=H5 (j+1);smt(in_dom parseK formatK nseq0 cats0).

  by inline*;auto;call(:true);auto;smt(in_dom dom0 in_fset0).
  qed.




  lemma LiftInd &m:
    `| Pr[Low.Indif(CORE(P),P,D).main() @ &m: res]
       - Pr[Low.Indif(ICORE,S(ICORE),D).main() @ &m: res] |
    = `| Pr[Indif(BlockSponge(P),P,HiDist(D)).main() @ &m: res]
         - Pr[Indif(IBlockSponge,HiSim(S,IBlockSponge),HiDist(D)).main() @ &m: res] |.
  proof.
  do !congr.
  + byequiv (_: ={glob D, glob P} ==> _ )=> //=; proc.
    call (_: ={glob P}); first 2 by sim.
    + proc=> /=; sp;if=>//=;1:progress=>/#.
      inline*;sp;wp.
      rcondt{1}1;progress.
      splitwhile{2}1: i < size x.
      seq 3 1:(  ={glob P,sa,sc,p}
              /\ (x,n,p0,n0){1} = (x,n,x,n){2}
              /\ valid x{1}
              /\ i{2} = size x{2}
              /\ i{1} = 1
              /\ r0{1} = [sa{1}]
              /\ (x{2}, n{2}) = parse p{2}
              /\ 0 < n{1}).
      + wp;conseq(:_==>  ={glob P,sa,sc,i,p,x,n}
              /\ i{2} = size x{2}
              /\ (x,n,p0,n0){1} = (x,n,x,n){2});progress.
        while( ={glob P,sa,sc,i,p,x,n}
            /\ (x{2}, n{2}) = parse p{2}
            /\ (p0,n0){1} = (x,n){2}
            /\ 0 <= i{2} <= size x{2} <= size p{2});auto;1:call(:true);auto;progress;2..9,-3..-1:smt(size_ge0).
        + by rewrite-(formatK p{2})-H/=/format nth_cat H3.
        + by rewrite-(formatK p{2})-H/=/format size_cat;smt(size_ge0).
        by rewrite-(formatK p{2})-H/=/format size_cat;smt(size_ge0).

      while( ={glob P,sa,sc,p}
          /\ i{1} - 1 = i{2} - size x{2}
          /\ size x{2} <= i{2} <= size p{2}
          /\ sa{1} = last b0 r0{1}
          /\ (x{2}, n{2}) = parse p{2}
          /\ (x{1}, n{1}) = parse p{1}
          /\ valid x{1}
          /\ 0 < n{1}
          /\ size p{2} = size x{2} + n{2} - 1
          /\ n0{1} = n{2}
          );auto;last first.
      + progress. 
        + by rewrite-(formatK p{2})-H0/=/format size_cat size_nseq/#. 
        + by rewrite-(formatK p{2})-H0/=/format size_cat size_nseq/#. 
        + by rewrite-(formatK p{2})-H0/=/format size_cat size_nseq/#. 
        by move:H2;rewrite-(formatK p{2})-H0/=/format size_cat size_nseq/#. 

      call(:true);auto;progress;2..5,-2..:smt(last_rcons).
      rewrite -(formatK p{2})-H2/=/format nth_cat nth_nseq_if.
      cut->//=:!i{2} < size x{2} by rewrite/#. 
      cut->//=: 0 <= i{2} - size x{2} by rewrite/#. 
      rewrite-H.
      cut->/=:i{1} - 1 < n{2} - 1 by rewrite/#.
      by rewrite BlockMonoid.addr0.
     
    by inline*;auto;call(:true);auto. 

  byequiv (_: ={glob D, glob S} ==> _)=> //=; proc.
  call (_:    ={glob S} /\ INV IBlockSponge.m{2} ICORE.m{1}).
  + proc (INV IBlockSponge.m{2} ICORE.m{1})=> //.
    proc=> /=; sp;if=> [&1 &2 [#] <*>| |] //=.
    inline{2} 1.1.
    inline*.
    while( INV IBlockSponge.m{2} ICORE.m{1}
        /\ 0 < i{1} <= n{1} + 1
        /\ ={n,p,r,i}
        /\ valid p{1}
        /\ 0 < n{1}
        /\ (forall j, 0 < j < i{1} => 
              format p{2} j \in dom IBlockSponge.m{2}));last auto=>/#. 
    rcondt{2}5;auto;1:smt(parseK). 
    swap{2}6-1;sp.
    conseq(:_==> INV IBlockSponge.m{2} ICORE.m{1} /\
            (forall j, 0 < j <= n0{1} => 
              format p0{1} j \in dom IBlockSponge.m{2}));1:smt(parseK formatK).
    conseq(: INV IBlockSponge.m{2} ICORE.m{1} /\ (forall (j : int),
              0 < j < n0{1} => format p0{1} j \in dom IBlockSponge.m{2}) /\
              (p0,n0){1} = parse x1{2} /\ (x=x1){2} /\ ={p0,n0} /\ 
              n0{1} = i{2} /\ 0 <= i0{2} < i{2}
              ==> _);1:smt(parseK formatK). 
    seq 1 1 : (INV IBlockSponge.m{2} ICORE.m{1} /\ 0 < n0{2} /\
              (forall (j : int), 0 < j <= n0{1} => 
                format p0{1} j \in dom IBlockSponge.m{2}) /\
              (p0,n0){1} = parse x1{2} /\ ={p0,n0} /\ (x=x1){2});last first. 
    + rcondf{2}1;auto;smt(parseK formatK).
    splitwhile{2}1:(i0+1<n0).
    seq 0 1:(INV IBlockSponge.m{2} ICORE.m{1} /\ 0 < n0{2} /\ i0{2} + 1 = n0{2}
                /\ (x=x1){2} /\ (forall (j : int), 0 < j < n0{1} => 
                format p0{1} j \in dom IBlockSponge.m{2}) /\
              (p0,n0){1} = parse x1{2} /\ ={p0,n0} /\ (x=x1){2});last first. 
    + rcondt{2}1;1:auto=>/#;rcondf{2}4;1: by progress;sp;if;auto=>/#.
      sp;if;auto;progress. 
      + rewrite-(formatK x1{2})-H2/=take_cat addzAC/=-addzA/=take_nseq/min/=.
        cut->/=:!size p0{2} + i0{2} < size p0{2} by rewrite/#.
        smt(in_dom formatK).
      + move:H3;rewrite-(formatK x1{2})-H2/=take_cat addzAC/=-addzA/=take_nseq/min/=.
        cut->/=:!size p0{2} + i0{2} < size p0{2} by rewrite/#.
        smt(in_dom formatK).
      + rewrite-(formatK x1{2})-H2/=take_cat addzAC/=-addzA/=take_nseq/min/=.
        smt(getP parseK formatK). 
      + rewrite-(formatK x1{2})-H2/=take_cat addzAC/=-addzA/=take_nseq/min/=.
        smt(in_dom getP parseK formatK). 
      + case(j=i0{2} + 1)=>//=;2:rewrite/#.
        smt(in_dom getP parseK formatK). 
    while{2}((p0{2}, n0{2}) = parse x1{2} /\ (x=x1){2} /\ 0 <= i0{2} < n0{2} /\
                INV IBlockSponge.m{2} ICORE.m{1} /\ (p0,n0){1} = parse x1{2} /\
              ={p0,n0} /\ (forall (j : int), 0 < j < n0{2} => 
                format p0{2} j \in dom IBlockSponge.m{2}))(n0{2}-i0{2});progress.
    + sp;rcondf 1;auto;progress. 
      + rewrite-(formatK x1{hr})-H3/=take_cat addzAC/=/=take_nseq/min/=.
        cut->/=:!size p0{hr} + i0{hr} < size p0{hr} by rewrite/#.
        by cut/#:=H4 (i0{hr}+1).
      + by rewrite/#.
      by rewrite/#.
    by auto=>/#.

  + proc (INV IBlockSponge.m{2} ICORE.m{1})=> //.
    proc=> /=; sp;if=> [&1 &2 [#] <*>| |] //=.
    inline{2} 1.1.
    inline*.
    while( INV IBlockSponge.m{2} ICORE.m{1}
        /\ 0 < i{1} <= n{1} + 1
        /\ ={n,p,r,i}
        /\ valid p{1}
        /\ 0 < n{1}
        /\ (forall j, 0 < j < i{1} => 
              format p{2} j \in dom IBlockSponge.m{2}));last auto=>/#. 
    rcondt{2}5;auto;1:smt(parseK). 
    swap{2}6-1;sp.
    conseq(:_==> INV IBlockSponge.m{2} ICORE.m{1} /\
            (forall j, 0 < j <= n0{1} => 
              format p0{1} j \in dom IBlockSponge.m{2}));1:smt(parseK formatK).
    conseq(: INV IBlockSponge.m{2} ICORE.m{1} /\ (forall (j : int),
              0 < j < n0{1} => format p0{1} j \in dom IBlockSponge.m{2}) /\
              (p0,n0){1} = parse x1{2} /\ (x=x1){2} /\ ={p0,n0} /\ 
              n0{1} = i{2} /\ 0 <= i0{2} < i{2}
              ==> _);1:smt(parseK formatK). 
    seq 1 1 : (INV IBlockSponge.m{2} ICORE.m{1} /\ 0 < n0{2} /\
              (forall (j : int), 0 < j <= n0{1} => 
                format p0{1} j \in dom IBlockSponge.m{2}) /\
              (p0,n0){1} = parse x1{2} /\ ={p0,n0} /\ (x=x1){2});last first. 
    + rcondf{2}1;auto;smt(parseK formatK).
    splitwhile{2}1:(i0+1<n0).
    seq 0 1:(INV IBlockSponge.m{2} ICORE.m{1} /\ 0 < n0{2} /\ i0{2} + 1 = n0{2}
                /\ (x=x1){2} /\ (forall (j : int), 0 < j < n0{1} => 
                format p0{1} j \in dom IBlockSponge.m{2}) /\
              (p0,n0){1} = parse x1{2} /\ ={p0,n0} /\ (x=x1){2});last first. 
    + rcondt{2}1;1:auto=>/#;rcondf{2}4;1: by progress;sp;if;auto=>/#.
      sp;if;auto;progress. 
      + rewrite-(formatK x1{2})-H2/=take_cat addzAC/=-addzA/=take_nseq/min/=.
        cut->/=:!size p0{2} + i0{2} < size p0{2} by rewrite/#.
        smt(in_dom formatK).
      + move:H3;rewrite-(formatK x1{2})-H2/=take_cat addzAC/=-addzA/=take_nseq/min/=.
        cut->/=:!size p0{2} + i0{2} < size p0{2} by rewrite/#.
        smt(in_dom formatK).
      + rewrite-(formatK x1{2})-H2/=take_cat addzAC/=-addzA/=take_nseq/min/=.
        smt(getP parseK formatK). 
      + rewrite-(formatK x1{2})-H2/=take_cat addzAC/=-addzA/=take_nseq/min/=.
        smt(in_dom getP parseK formatK). 
      + case(j=i0{2} + 1)=>//=;2:rewrite/#.
        smt(in_dom getP parseK formatK). 
    while{2}((p0{2}, n0{2}) = parse x1{2} /\ (x=x1){2} /\ 0 <= i0{2} < n0{2} /\
                INV IBlockSponge.m{2} ICORE.m{1} /\ (p0,n0){1} = parse x1{2} /\
              ={p0,n0} /\ (forall (j : int), 0 < j < n0{2} => 
                format p0{2} j \in dom IBlockSponge.m{2}))(n0{2}-i0{2});progress.
    + sp;rcondf 1;auto;progress. 
      + rewrite-(formatK x1{hr})-H3/=take_cat addzAC/=/=take_nseq/min/=.
        cut->/=:!size p0{hr} + i0{hr} < size p0{hr} by rewrite/#.
        by cut/#:=H4 (i0{hr}+1).
      + by rewrite/#.
      by rewrite/#.
    by auto=>/#.

  + proc.
    sp;if=> [&1 &2 [#] <*>/#| |] //=.
    inline*;sp;rcondt{1}1;auto.
    swap{2}1;sp.
    conseq(:_==> last Block.b0 r0{1} = oget IBlockSponge.m{2}.[x{2}] /\
                INV IBlockSponge.m{2} ICORE.m{1});progress.
    seq 1 1 :(last Block.b0 r0{1} = oget IBlockSponge.m{2}.[x{2}] /\
                INV IBlockSponge.m{2} ICORE.m{1} /\
                x1{2} \in dom IBlockSponge.m{2});last by rcondf{2}1;auto=>/#. 
    conseq(:_==> INV IBlockSponge.m{2} ICORE.m{1} /\ i{2} = n{2} /\
                Some (last Block.b0 r0{1}) = 
                IBlockSponge.m{2}.[take (size p + i){2} x{2}]);progress.
    + move:H5;rewrite take_oversize;2:smt(oget_some). 
      by rewrite-formatK/=-H/=size_cat size_nseq/#. 
    + move:H5;rewrite take_oversize. 
      + by rewrite-formatK/=-H/=size_cat size_nseq/#. 
      by rewrite in_dom/#.
    while( i{1} = i{2}+1 /\ n0{1} = n{2} /\ p{2} = p0{1}
        /\ valid p0{1} /\ 0 < i{1} /\ i{2} <= n{2}
        /\ (i{2} = n{2} => Some (last Block.b0 r0{1}) =
           IBlockSponge.m{2}.[take (size p{2} + i{2}) x{2}])
        /\ INV IBlockSponge.m{2} ICORE.m{1}
        /\ parse x{2} = (p0{1},n0{1}));auto;last first.
    + progress=>/#. 
    sp;if;auto;smt(take_nseq parseK in_dom formatK take_cat getP last_rcons).

  by inline*;auto;call(:true);auto;smt(in_dom dom0 in_fset0).
qed.
end section PROOF.


require import Gconcl.
print Gconcl.
print SLCommon.GReal.
print SLCommon.SqueezelessSponge.
print SLCommon.IdealIndif.
print SLCommon.RealIndif.
print SLCommon.DPRestr.
print SLCommon.DISTINGUISHER.
print DISTINGUISHER.
print SLCommon.DFUNCTIONALITY.
print SLCommon.DPRIMITIVE.
print DFUNCTIONALITY.
print DPRIMITIVE.