pragma -oldip. pragma +implicits.
require import Pred Fun Option Pair Int Real List FSet NewFMap NewDistr.
require import StdOrder Ring DProd.
(*---*) import IntOrder.

require (*..*) RP Indifferentiability.

(*** THEORY PARAMETERS ***)
(** Block/Rate **)
theory Block.
  op r : int.
  axiom r_ge0: 0 <= r.

  type block.

  op b0: block.
  op (+^): block -> block -> block.

  axiom addbA b1 b2 b3: b1 +^ (b2 +^ b3) = b1 +^ b2 +^ b3.
  axiom addbC b1 b2: b1 +^ b2 = b2 +^ b1.
  axiom add0b b: b0 +^ b = b.
  axiom addbK b: b +^ b = b0.

  op blocks: block list.
  axiom blocks_spec b: count (pred1 b) blocks = 1.
  axiom card_block: size blocks = 2^r.

  clone import Ring.ZModule as BlockMonoid with 
    type t               <- block,
    op zeror             <- b0,
    op ( + )             <- (+^),
    op [ - ] (b : block) <- b
  remove abbrev (-)
  proof *.
  realize addrA by exact/addbA.
  realize addrC by exact/addbC.
  realize add0r by exact/add0b.
  realize addNr by exact/addbK.

  clone import MFinite as DBlock with
    type t            <- block,
    op   Support.enum <- blocks
  rename "dunifin"  as "bdistr"
         "duniform" as "bdistr"
  proof *.
  realize Support.enum_spec by exact/blocks_spec.
end Block.
import Block DBlock.

(**  Capacity  **)
theory Capacity.
  op c : int.
  axiom c_ge0: 0 <= c.

  type capacity.

  op c0: capacity.

  op caps: capacity list.
  axiom caps_spec b: count (pred1 b) caps = 1.
  axiom card_capacity: size caps = 2^c.

  clone import MFinite as DCapacity with
    type t            <- capacity,
    op   Support.enum <- caps
  rename "dunifin"  as "cdistr"
         "duniform" as "cdistr"
  proof *.
  realize Support.enum_spec by exact/caps_spec.
end Capacity.
import Capacity DCapacity.

(** Validity of Functionality Queries and Partial Bijection **)
op valid: block list -> int -> bool.
axiom nil_not_valid bs n: valid bs n => bs <> [].

op extend: block list -> int -> block list.
op strip: block list -> (block list * int).

axiom strip_nil bs: (strip bs).`1 <> [] => bs <> [].
axiom stripK bs: extend (strip bs).`1 (strip bs).`2 = bs.
axiom extendK bs n: valid bs n => strip (extend bs n) = (bs,n).
axiom size_extend bs n: valid bs n => size (extend bs n) = size bs + n.

lemma injective_strip: injective strip.
proof.
by move=> bs1 bs2 eq_strip; rewrite -stripK eq_strip; exact/(@stripK bs2).
qed.

(** Adversary's Query Cost **)
op max_query: int.
axiom max_query_ge0: 0 <= max_query.

(*** DEFINITIONS ***)
type state  = block  * capacity.
op   dstate = bdistr `*` cdistr.

(** Indifferentiability Experiment **)
clone include Indifferentiability with
  type p     <- state, 
  type f_in  <- block list * int,
  type f_out <- block
  rename [module] "GReal" as "RealIndif"
         [module] "GIdeal"  as "IdealIndif".

(** Query Counting -- Note that we only count **adversary** queries **)
theory Counting.
  module C = {
    var c:int
    proc init() = { c <- 0; }
  }.

  module PC (P : PRIMITIVE) : PRIMITIVE = {
    proc init () = {
      C.init();
      P.init();
    }

    proc f (x : state) = {
      var y;

      C.c <- C.c + 1;
      y   <@ P.f(x);
      return y;
    }

    proc fi(x : state) = {
      var y;

      C.c <- C.c + 1;
      y   <@ P.fi(x);
      return y;
    }
  }.

  module DPRestr (P : DPRIMITIVE) : DPRIMITIVE = {
    proc f (x : state) = {
      var y <- (b0,c0);

      if (C.c + 1 <= max_query) {
        C.c <- C.c + 1;
        y   <@ P.f(x);
      }
      return y;
    }

    proc fi(x : state) = {
      var y <- (b0,c0);

      if (C.c + 1 <= max_query) {
        C.c <- C.c + 1;
        y   <@ P.fi(x);
      }
      return y;
    }
  }.

  module PRestr (P : PRIMITIVE) : PRIMITIVE = {
    proc init () = {
      C.init();
      P.init();
    }

    proc f = DPRestr(P).f
    proc fi = DPRestr(P).fi
  }.

  module FC (F : FUNCTIONALITY) : FUNCTIONALITY = {
    proc init = F.init

    proc f (p : block list, n : int) = {
      var b <- b0;

      if (valid p n) {
        C.c <- C.c + size p + n;
        b   <@ F.f(p,n);
      }
      return b;
    }
  }.

  module DFRestr (F : DFUNCTIONALITY) : DFUNCTIONALITY = {
    proc f (p : block list, n : int) = {
      var b <- b0;

      if (valid p n /\ C.c + size p + n <= max_query) {
        C.c <- C.c + size p + n;
        b <@ F.f(p, n);
      }
      return b;
    }
  }.

  module FRestr(F : FUNCTIONALITY) : FUNCTIONALITY = {
    proc init = F.init
    proc f = DFRestr(F).f
  }.

  module (DRestr (D : DISTINGUISHER) : DISTINGUISHER)
           (F : DFUNCTIONALITY) (P : DPRIMITIVE) = {
    proc distinguish() = {
      var b;

           C.init();
      b <@ D(DFRestr(F), DPRestr(P)).distinguish();
      return b;
    }
  }.
end Counting.
import Counting.

(** Core Extension Construction **)
module (CoreExtension : CONSTRUCTION) (P:DPRIMITIVE): FUNCTIONALITY = {
  proc init () = {}

  proc f(p : block list, n : int): block = {
    var (sa,sc) <- (b0,c0);

    if (valid p n) {
      p <- extend p n;
      while (p <> []) {
        (sa,sc) <@ P.f((sa +^ head witness p,sc));
        p <- behead p;
      }
    }
    return sa;
  }
}.

(** Ideal Core Extension Functionality **)
module ICoreExtension: FUNCTIONALITY = {
  var m : (block list * int,block) fmap

  proc init() = {
    m = map0;
  }

  proc f(p : block list, n : int): block = {
    var r <- b0;

    if (valid p n) {
      if (!mem (dom m) (p,n)) {
        m.[(p,n)] <$ bdistr;
      }
      r <- oget m.[(p,n)];
    }
    return r;
  }
}.

(** Initial and Final Games **)
module GReal  (D : DISTINGUISHER, P : PRIMITIVE) = RealIndif(CoreExtension,P,D).

module GIdeal (D : DISTINGUISHER, S : SIMULATOR) = IdealIndif(ICoreExtension,S,D).

(*** PROOF ***)
require (*--*) Core.

section PROOF.
  local clone Core as CoreSim with
    op   Block.r           <- r,
    type Block.block       <- block,
    op   Block.b0          <- b0,
    op   Block.(+^)        <- (+^),
    op   Block.enum        <- blocks,
    op   Capacity.c        <- c,
    type Capacity.capacity <- capacity,
    op   Capacity.c0       <- c0,
    op   Capacity.enum     <- caps,
    op   max_query         <- max_query,
    op   valid (bs)        <- valid (strip bs).`1 (strip bs).`2
  proof *.
  realize Block.r_ge0 by exact/r_ge0.
  realize Block.addbA by exact/addbA.
  realize Block.addbC by exact/addbC.
  realize Block.add0b by exact/add0b.
  realize Block.addbK by exact/addbK.
  realize Block.block_enum by exact/blocks_spec.
  realize Block.card_block by exact/card_block.
  realize Capacity.c_ge0 by exact/c_ge0.
  realize Capacity.capacity_enum by exact/caps_spec.
  realize Capacity.card_capacity by exact/card_capacity.
  realize max_query_ge0 by exact/max_query_ge0.
  realize valid_not_nil.
  proof. by move=> m /nil_not_valid; exact/(@strip_nil m). qed.

  (** Simulator and Distinguisher constructions **)
  module (RaiseSim (S : CoreSim.SIMULATOR) : SIMULATOR)
            (F : DFUNCTIONALITY) = {
    module LowerF = {
      proc f(p : block list) = {
        var n, b;

        (p,n) <- strip p;
        b     <@ F.f(p,n);
        return b;
      }
    }

    proc init = S(LowerF).init
    proc f    = S(LowerF).f
    proc fi   = S(LowerF).fi
  }.

  module (LowerDist (D : DISTINGUISHER) : CoreSim.DISTINGUISHER)
            (F : CoreSim.DFUNCTIONALITY) (P : CoreSim.DPRIMITIVE) = {
    module RaiseF = {
      proc f(p : block list, n : int) = {
        var b <- b0;

        if (valid p n) {
          p <- extend p n;
          b <@ F.f(p);
        }
        return b;
      }
    }

    proc distinguish = D(RaiseF,P).distinguish
  }.


  (** Transferring Query Counting -- We need to give two lemmas because of restrictions **)
  local equiv DRestr_LowerDist_Real
      (D <: DISTINGUISHER { CoreSim.Counting.C, Self.Counting.C })
      (C <: CoreSim.CONSTRUCTION {D, CoreSim.Counting.C, Self.Counting.C})
      (P <: DPRIMITIVE {D, C, CoreSim.Counting.C, Self.Counting.C}):
    LowerDist(DRestr(D),C(P),P).distinguish ~ CoreSim.Counting.DRestr(LowerDist(D),C(P),P).distinguish:
          ={glob D, glob C, glob P}
      ==> ={res, glob D, glob C, glob P} /\ Counting.C.c{1} = CoreSim.Counting.C.c{2}.
  proof.
  proc; call (_:    ={glob C, glob P}
                 /\ Counting.C.c{1} = CoreSim.Counting.C.c{2});
          first 2 by sim.
  + proc; sp; if{2}=> //=; last by rcondf{1} 1; 1:by auto=> /> ->.
    inline{2} 2; inline{1} 1.2.
    sp; if; auto.
    + by move=> /> &1 &2 ^ ^ ^ valid_pn /extendK -> /= /size_extend -> -> /#.
    rcondt{1} 5; 1:by auto.
    by sim; auto=> /> &1 &2 /size_extend -> /#.
  by inline *; auto.
  qed.

  local equiv DRestr_LowerDist_Ideal
      (D <: DISTINGUISHER { CoreSim.Counting.C, Self.Counting.C })
      (F <: CoreSim.DFUNCTIONALITY {D, CoreSim.Counting.C, Self.Counting.C})
      (S <: CoreSim.SIMULATOR {D, F, CoreSim.Counting.C, Self.Counting.C}):
    LowerDist(DRestr(D),F,S(F)).distinguish ~ CoreSim.Counting.DRestr(LowerDist(D),F,S(F)).distinguish:
          ={glob D, glob F, glob S}
      ==> ={res, glob D, glob F, glob S} /\ Counting.C.c{1} = CoreSim.Counting.C.c{2}.
  proof.
  proc; call (_:    ={glob F, glob S}
                 /\ Counting.C.c{1} = CoreSim.Counting.C.c{2});
          first 2 by sim.
  + proc; sp; if{2}=> //=; last by rcondf{1} 1; 1:by auto=> /> ->.
    inline{2} 2; inline{1} 1.2.
    sp; if; auto.
    + by move=> /> &1 &2 ^ ^ ^ valid_pn /extendK -> /= /size_extend -> -> /#.
    rcondt{1} 5; 1:by auto.
    by sim; auto=> /> &1 &2 /size_extend -> /#.
  by inline *; auto.
  qed.

  (** The raised simulator is such that the indifferentiability
      advantage of any high-level adversary is exactly that of the
      lowered distinguisher against the low-level simulator. **)
  local lemma LiftIndif
       (D <: DISTINGUISHER { CoreSim.Perm.Perm, CoreSim.ICore, CoreSim.S, ICoreExtension })
       &m:
    `| Pr[CoreSim.GReal(LowerDist(D)).main() @ &m: res]
       - Pr[CoreSim.GIdeal(LowerDist(D)).main() @ &m: res] |
    = `| Pr[GReal(D,CoreSim.Perm.Perm).main() @ &m: res]
         - Pr[GIdeal(D,RaiseSim(CoreSim.S)).main() @ &m: res] |.
  proof.
  do !congr.
  + byequiv (_: ={glob D} ==> _)=> //; proc.
    seq  2  2: (={glob CoreSim.Perm.Perm, glob D}).
    + by inline *; auto.
    call (_: ={glob CoreSim.Perm.Perm})=> //; first 2 by sim.
    proc; sp; if=> //=. inline{1} 2; wp.
    while (={glob CoreSim.Perm.Perm, sa, sc} /\ p0{1} = p{2}); auto.
    by inline *; sp; if=> //=; auto.
  byequiv (_: ={glob CoreSim.S, glob D} ==> _)=> //; proc.
  seq  2  2: (   ={glob D, glob CoreSim.S}
              /\ (forall p n,
                       mem (dom ICoreExtension.m) (p,n)
                    =>    valid p n){2}
              /\ (forall p n, valid p n =>
                    ICoreExtension.m.[(p,n)]{2} = CoreSim.ICore.m.[extend p n]{1})).
  + by inline *; auto; smt (in_dom map0P).
  call (_:   ={glob CoreSim.S}
          /\ (forall p n,
                   mem (dom ICoreExtension.m) (p,n)
                =>    valid p n){2}
          /\ (forall p n, valid p n =>
                ICoreExtension.m.[(p,n)]{2} = CoreSim.ICore.m.[extend p n]{1}))=> //.
  + proc; if=> //=; last by auto.
    if=> //=.
    + rcondt{1} 7=> [&m0|].
      + inline *; sp; if=> //=; last by auto; smt (bdistr_ll).
        if=> //=; last by auto; smt (bdistr_ll).
        by auto; smt (bdistr_ll cdistr_ll).
      rcondt{2} 7=> [&m0|].
      + inline *; sp; if=> //=; last by auto; smt (bdistr_ll).
        if=> //=; last by auto; smt (bdistr_ll).
        by auto; smt (bdistr_ll cdistr_ll).
      auto; sp.
      conseq (_:    ={x, p, v, glob CoreSim.S}
                 /\ CoreSim.S.pi.[x.`2]{2} = Some (p,v){2}
                 /\ CoreSim.S.m.[x]{1} = None
                 /\ (forall p n,
                          mem (dom ICoreExtension.m) (p,n)
                       =>    valid p n){2}
                 /\ (forall p n, valid p n =>
                       ICoreExtension.m.[(p,n)]{2} = CoreSim.ICore.m.[extend p n]{1})
                 ==>    ={glob CoreSim.S, y1, p, v, x}
                     /\ (forall p n,
                              mem (dom ICoreExtension.m) (p,n)
                           =>    valid p n){2}
                     /\ (forall p n, valid p n =>
                           ICoreExtension.m.[(p,n)]{2} = CoreSim.ICore.m.[extend p n]{1}))=> //.
      + auto=> /> &1 &2 ^pv_def <- [#] <*> h1 h2; rewrite !in_dom=> /= -> /=.
        by case: (CoreSim.S.pi.[x.`2]{2}) pv_def=> //= x @/oget /=.
      inline *; sp; if=> //=.
      + by move=> /> &1 &2; case: (strip (rcons p (v +^ x.`1)){2})=> p' n' [#] !->>.
      if=> //=.
      + move=> /> &1 &2; case _: (strip (rcons p (v +^ x.`1)){2})=> p' n' h_def [#] !->>.
        move=> _ _ h1 h2 /= valid_pn; rewrite !in_dom.
        rewrite h2 //.
        have ->: p' = (strip (rcons p (v +^ x.`1)){2}).`1 by rewrite h_def.
        have ->: n' = (strip (rcons p (v +^ x.`1)){2}).`2 by rewrite h_def.
        by rewrite (@stripK (rcons p (v +^ x.`1)){2}).
      + auto=> /> &1 &2; case _: (strip (rcons p (v +^ x.`1)){2})=> p' n' h_def [#] !->>.
        move=> pi_x2 m_x h1 h2 /= valid_pn; rewrite in_dom=> /= m_pvx1.
        move=> _ b _ _; rewrite getP /= oget_some getP /= oget_some /=; split.
        + move=> p n; rewrite in_dom getP; case ((p,n) = (p',n'))=> //= _.
          by rewrite -in_dom=> /h1.
        move=> p0 n0 valid_pn'; rewrite !getP h2 // -h_def.
        case: (extend p0 n0 = (rcons p (v +^ x.`1)){2})=> //=.
        + by rewrite -extendK=> // ->.
        case: ((p0,n0) = (strip (rcons p (v +^ x.`1))){2})=> //=.
        smt (stripK).
      + auto=> /> &1 &2; case _: (strip (rcons p (v +^ x.`1)){2})=> p' n' h_def [#] !->>.
        by move=> _ _ h1 h2 /= valid_pn' _; rewrite h2 //; smt (stripK).
      by auto.
    rcondf{1} 6; 1:by auto.
    rcondf{2} 6; 1:by auto.
    by auto.
  + by proc; if=> //=; auto.
  proc; sp; if=> //=; inline{1} 2.
  rcondt{1} 4; 1:auto.
  + by move=> &hr [#] !->> h1 h2 valid_p n_ge0 /=; rewrite extendK.
  sp; if=> //=.
  + by move=> /> &1 &2 h1 h2 valid_pn; rewrite !in_dom h2 // -extendK.
  + auto=> /> &1 &2 h1 h2 valid_pn; rewrite in_dom=> /= ^extend_pn_notin_m.
    rewrite -h2=> // pn_notin_m _ b _ _; rewrite 2!getP /=; split.
    + move=> p' n'; rewrite in_dom getP; case ((p',n') = (p{2},n{2}))=> //= _.
      by rewrite -in_dom=> /h1.
    move=> p0 m0 valid_pn0; rewrite !getP h2 // -!extendK //.
    case: (extend p0 m0 = extend p{2} n{2})=> [->|] //.
    by have /contra H /H ->:= (injective_strip (extend p0 m0) (extend p{2} n{2})).
  by auto=> /> &1 &2 h1 h2 valid_pn _; rewrite -h2.      
  qed.

  (** And we conclude with a bound on indifferentiability of the
      high-level construction **)
  (** TODO: Arrange that this lemma be non-local **)
  local lemma ExtensionIndif
       (D <: DISTINGUISHER { CoreSim.Perm.Perm, CoreSim.ICore, CoreSim.S,
                             ICoreExtension, CoreSim.Counting.C, Self.Counting.C })
       &m:
       (forall (F <: DFUNCTIONALITY {D}) (P <: DPRIMITIVE {D}),
             islossless P.f
          => islossless P.fi
          => islossless F.f
          => islossless D(F,P).distinguish)
    => `| Pr[GReal(DRestr(D),CoreSim.Perm.Perm).main() @ &m: res]
          - Pr[GIdeal(DRestr(D),RaiseSim(CoreSim.S)).main() @ &m: res] |
       <= (max_query ^ 2)%r / (2^(r + c))%r
          + max_query%r * ((2*max_query)%r / (2^c)%r)
          + max_query%r * ((2*max_query)%r / (2^c)%r).
  proof.
  move=> D_ll.
  rewrite -(LiftIndif (DRestr(D)) &m).
  have ->: Pr[CoreSim.GReal(LowerDist(DRestr(D))).main() @ &m: res]
           = Pr[CoreSim.GReal(CoreSim.Counting.DRestr(LowerDist(D))).main() @ &m: res].
  + byequiv (_: ={glob D} ==> _)=> //=; proc.
    call (DRestr_LowerDist_Real D CoreSim.Core CoreSim.Perm.Perm).
    by inline *; auto.
  have ->: Pr[CoreSim.GIdeal(LowerDist(DRestr(D))).main() @ &m: res]
           = Pr[CoreSim.GIdeal(CoreSim.Counting.DRestr(LowerDist(D))).main() @ &m: res].
  + byequiv (_: ={glob D} ==> _)=> //=; proc.
    call (DRestr_LowerDist_Ideal D CoreSim.ICore CoreSim.S).
    by inline *; auto.
  apply/(CoreSim.CoreIndiff (LowerDist(D)) &m _).
  move=> F P Pf_ll Pfi_ll Ff_ll; proc (true)=> //.
  by proc; sp; if=> //=; call Ff_ll; auto.
  qed.
end section PROOF.
