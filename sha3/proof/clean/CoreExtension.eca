pragma -oldip. pragma +implicits.
require import Pred Fun Option Pair Int Real List FSet NewFMap NewDistr.
require import StdOrder Ring DProd.
(*---*) import IntOrder.

require (*..*) RP Indifferentiability.

(*** THEORY PARAMETERS ***)
(** Block/Rate **)
theory Block.
  op r : int.
  axiom r_ge0: 0 <= r.

  type block.

  op b0: block.
  op (+^): block -> block -> block.

  axiom addbA b1 b2 b3: b1 +^ (b2 +^ b3) = b1 +^ b2 +^ b3.
  axiom addbC b1 b2: b1 +^ b2 = b2 +^ b1.
  axiom add0b b: b0 +^ b = b.
  axiom addbK b: b +^ b = b0.

  op blocks: block list.
  axiom blocks_spec b: count (pred1 b) blocks = 1.
  axiom card_block: size blocks = 2^r.

  clone import Ring.ZModule as BlockMonoid with 
    type t               <- block,
    op zeror             <- b0,
    op ( + )             <- (+^),
    op [ - ] (b : block) <- b
  remove abbrev (-)
  proof *.
  realize addrA by exact/addbA.
  realize addrC by exact/addbC.
  realize add0r by exact/add0b.
  realize addNr by exact/addbK.

  clone import MFinite as DBlock with
    type t            <- block,
    op   Support.enum <- blocks
  rename "dunifin"  as "bdistr"
         "duniform" as "bdistr"
  proof *.
  realize Support.enum_spec by exact/blocks_spec.
end Block.
import Block DBlock.

(**  Capacity  **)
theory Capacity.
  op c : int.
  axiom c_ge0: 0 <= c.

  type capacity.

  op c0: capacity.

  op caps: capacity list.
  axiom caps_spec b: count (pred1 b) caps = 1.
  axiom card_capacity: size caps = 2^c.

  clone import MFinite as DCapacity with
    type t            <- capacity,
    op   Support.enum <- caps
  rename "dunifin"  as "cdistr"
         "duniform" as "cdistr"
  proof *.
  realize Support.enum_spec by exact/caps_spec.
end Capacity.
import Capacity DCapacity.

(** Validity of Functionality Queries and Partial Bijection **)
op valid: block list -> bool.

op extend: block list -> int -> block list.
op strip: block list -> (block list * int).

axiom stripK bs: extend (strip bs).`1 (strip bs).`2 = bs.
axiom extendK bs n: 0 <= n => valid bs => strip (extend bs n) = (bs,n).

lemma injective_strip: injective strip.
proof.
by move=> bs1 bs2 eq_strip; rewrite -stripK eq_strip; exact/(@stripK bs2).
qed.

(** Adversary's Query Cost **)
op max_query: int.
axiom max_query_ge0: 0 <= max_query.

(*** DEFINITIONS ***)
type state  = block  * capacity.
op   dstate = bdistr `*` cdistr.

(** Indifferentiability Experiment **)
clone include Indifferentiability with
  type p     <- state, 
  type f_in  <- block list * int,
  type f_out <- block
  rename [module] "GReal" as "RealIndif"
         [module] "GIdeal"  as "IdealIndif".

(** Query Counting **)
module C = {
  var c:int
  proc init() = { c <- 0; }
}.

module PC (P : PRIMITIVE) : PRIMITIVE = {
  proc init () = {
    C.init();
    P.init();
  }

  proc f (x : state) = {
    var y;

    C.c <- C.c + 1;
    y   <@ P.f(x);
    return y;
  }

  proc fi(x : state) = {
    var y;

    C.c <- C.c + 1;
    y   <@ P.fi(x);
    return y;
  }
}.

module DPRestr (P : DPRIMITIVE) : DPRIMITIVE = {
  proc f (x : state) = {
    var y <- (b0,c0);

    if (C.c + 1 <= max_query) {
      C.c <- C.c + 1;
      y   <@ P.f(x);
    }
    return y;
  }

  proc fi(x : state) = {
    var y <- (b0,c0);

    if (C.c + 1 <= max_query) {
      C.c <- C.c + 1;
      y   <@ P.fi(x);
    }
    return y;
  }
}.

module PRestr (P : PRIMITIVE) : PRIMITIVE = {
  proc init () = {
    C.init();
    P.init();
  }

  proc f = DPRestr(P).f
  proc fi = DPRestr(P).fi
}.

module FC (F : FUNCTIONALITY) : FUNCTIONALITY = {
  proc init = F.init

  proc f (p : block list, n : int) = {
    var b <- b0;

    C.c <- C.c + size p;
    b   <@ F.f(p,n);
    return b;
  }
}.

module DFRestr (F : DFUNCTIONALITY) : DFUNCTIONALITY = {
  proc f (p : block list, n : int) = {
    var b <- b0;

    if (C.c + size p <= max_query) {
      C.c <- C.c + size p;
      b <@ F.f(p, n);
    }
    return b;
  }
}.

module FRestr(F : FUNCTIONALITY) : FUNCTIONALITY = {
  proc init = F.init
  proc f = DFRestr(F).f
}.

module (DRestr (D : DISTINGUISHER) : DISTINGUISHER)
         (F : DFUNCTIONALITY) (P : DPRIMITIVE) = {
  proc distinguish() = {
    var b;

         C.init();
    b <@ D(DFRestr(F), DPRestr(P)).distinguish();
    return b;
  }
}.

(** Core Extension Construction **)
module (CoreExtension : CONSTRUCTION) (P:DPRIMITIVE): FUNCTIONALITY = {
  proc init () = {}

  proc f(p : block list, n : int): block = {
    var (sa,sc) <- (b0,c0);

    if (valid p /\ 0 <= n) {
      p <- extend p n;
      while (p <> []) {
        (sa,sc) <@ P.f((sa +^ head witness p,sc));
        p <- behead p;
      }
    }
    return sa;
  }
}.

(** Ideal Core Extension Functionality **)
module ICoreExtension: FUNCTIONALITY = {
  var m : (block list * int,block) fmap

  proc init() = {
    m = map0;
  }

  proc f(p : block list, n : int): block = {
    var r <- b0;

    if (valid p /\ 0 <= n) {
      if (!mem (dom m) (p,n)) {
        m.[(p,n)] <$ bdistr;
      }
      r <- oget m.[(p,n)];
    }
    return r;
  }
}.

(** Initial and Final Games **)
module GReal  (D : DISTINGUISHER, P : PRIMITIVE) = RealIndif(CoreExtension,P,D).

module GIdeal (D : DISTINGUISHER, S : SIMULATOR) = IdealIndif(ICoreExtension,S,D).

(*** PROOF ***)
require (*--*) Core.

section PROOF.
  local clone Core as CoreSim with
    op   Block.r           <- r,
    type Block.block       <- block,
    op   Block.b0          <- b0,
    op   Block.(+^)        <- (+^),
    op   Block.enum        <- blocks,
    op   Capacity.c        <- c,
    type Capacity.capacity <- capacity,
    op   Capacity.c0       <- c0,
    op   Capacity.enum     <- caps,
    op   max_query         <- max_query,
    op   valid (bs)        <- valid (strip bs).`1 /\ 0 <= (strip bs).`2
  proof *.
  realize Block.r_ge0 by exact/r_ge0.
  realize Block.addbA by exact/addbA.
  realize Block.addbC by exact/addbC.
  realize Block.add0b by exact/add0b.
  realize Block.addbK by exact/addbK.
  realize Block.block_enum by exact/blocks_spec.
  realize Block.card_block by exact/card_block.
  realize Capacity.c_ge0 by exact/c_ge0.
  realize Capacity.capacity_enum by exact/caps_spec.
  realize Capacity.card_capacity by exact/card_capacity.
  realize valid_not_nil by admit.
  realize max_query_ge0 by exact/max_query_ge0.

  (** Simulator and Distinguisher constructions **)
  module (RaiseSim (S : CoreSim.SIMULATOR) : SIMULATOR)
            (F : DFUNCTIONALITY) = {
    module LowerF = {
      proc f(p : block list) = {
        var n, b;

        (p,n) <- strip p;
        b     <@ F.f(p,n);
        return b;
      }
    }

    proc init = S(LowerF).init
    proc f    = S(LowerF).f
    proc fi   = S(LowerF).fi
  }.

  module (LowerDist (D : DISTINGUISHER) : CoreSim.DISTINGUISHER)
            (F : CoreSim.DFUNCTIONALITY) (P : CoreSim.DPRIMITIVE) = {
    module RaiseF = {
      proc f(p : block list, n : int) = {
        var b <- b0;

        if (valid p /\ 0 <= n) {
          p <- extend p n;
          b <@ F.f(p);
        }
        return b;
      }
    }

    proc distinguish = D(RaiseF,P).distinguish
  }.

  declare module D : DISTINGUISHER { CoreSim.Core, CoreSim.Perm.Perm, CoreSim.ICore, CoreSim.S, CoreSim.C, ICoreExtension }.

  local lemma LiftIndif &m:
    `| Pr[CoreSim.GReal(LowerDist(D)).main() @ &m: res]
       - Pr[CoreSim.GIdeal(LowerDist(D)).main() @ &m: res] |
    = `| Pr[GReal(D,CoreSim.Perm.Perm).main() @ &m: res]
         - Pr[GIdeal(D,RaiseSim(CoreSim.S)).main() @ &m: res] |.
  proof.
  do !congr.
  + byequiv (_: ={glob D} ==> _)=> //; proc.
    seq  2  2: (={glob CoreSim.Perm.Perm, glob D}).
    + by inline *; auto.
    call (_: ={glob CoreSim.Perm.Perm})=> //.
    + by proc; inline{1} 2; wp; sim.
    + by proc; inline{1} 2; wp; sim.
    proc; sp; if=> //=. inline{1} 2; wp.
    while (={glob CoreSim.Perm.Perm, sa, sc} /\ p0{1} = p{2}); auto.
    by inline *; sp; if=> //=; auto.
  byequiv (_: ={glob CoreSim.S, glob D} ==> _)=> //; proc.
  seq  2  2: (   ={glob D, glob CoreSim.S}
              /\ (forall p n,
                       mem (dom ICoreExtension.m) (p,n)
                    =>    valid p
                       /\ 0 <= n){2}
              /\ (forall p n, valid p => 0 <= n =>
                    ICoreExtension.m.[(p,n)]{2} = CoreSim.ICore.m.[extend p n]{1})).
  + by inline *; auto; smt (in_dom map0P).
  call (_:   ={glob CoreSim.S}
          /\ (forall p n,
                   mem (dom ICoreExtension.m) (p,n)
                =>    valid p
                   /\ 0 <= n){2}
          /\ (forall p n, valid p => 0 <= n =>
                ICoreExtension.m.[(p,n)]{2} = CoreSim.ICore.m.[extend p n]{1}))=> //.
  + proc; if=> //=; last by auto.
    if=> //=.
    + rcondt{1} 7=> [&m0|].
      + inline *; sp; if=> //=; last by auto; smt (bdistr_ll).
        if=> //=; last by auto; smt (bdistr_ll).
        by auto; smt (bdistr_ll cdistr_ll).
      rcondt{2} 7=> [&m0|].
      + inline *; sp; if=> //=; last by auto; smt (bdistr_ll).
        if=> //=; last by auto; smt (bdistr_ll).
        by auto; smt (bdistr_ll cdistr_ll).
      auto; sp.
      conseq (_:    ={x, p, v, glob CoreSim.S}
                 /\ CoreSim.S.pi.[x.`2]{2} = Some (p,v){2}
                 /\ CoreSim.S.m.[x]{1} = None
                 /\ (forall p n,
                          mem (dom ICoreExtension.m) (p,n)
                       =>    valid p
                          /\ 0 <= n){2}
                 /\ (forall p n, valid p => 0 <= n =>
                       ICoreExtension.m.[(p,n)]{2} = CoreSim.ICore.m.[extend p n]{1})
                 ==>    ={glob CoreSim.S, y1, p, v, x}
                     /\ (forall p n,
                              mem (dom ICoreExtension.m) (p,n)
                           =>    valid p
                              /\ 0 <= n){2}
                     /\ (forall p n, valid p => 0 <= n =>
                           ICoreExtension.m.[(p,n)]{2} = CoreSim.ICore.m.[extend p n]{1}))=> //.
      + auto=> /> &1 &2 ^pv_def <- [#] <*> h1 h2; rewrite !in_dom=> /= -> /=.
        by case: (CoreSim.S.pi.[x.`2]{2}) pv_def=> //= x @/oget /=.
      inline *; sp; if=> //=.
      + by move=> /> &1 &2; case: (strip (rcons p (v +^ x.`1)){2})=> p' n' [#] !->>.
      if=> //=.
      + move=> /> &1 &2; case _: (strip (rcons p (v +^ x.`1)){2})=> p' n' h_def [#] !->>.
        move=> _ _ h1 h2 /= valid_p ge0_n; rewrite !in_dom.
        rewrite h2 //.
        have ->: p' = (strip (rcons p (v +^ x.`1)){2}).`1 by rewrite h_def.
        have ->: n' = (strip (rcons p (v +^ x.`1)){2}).`2 by rewrite h_def.
        by rewrite (@stripK (rcons p (v +^ x.`1)){2}).
      + auto=> /> &1 &2; case _: (strip (rcons p (v +^ x.`1)){2})=> p' n' h_def [#] !->>.
        move=> pi_x2 m_x h1 h2 /= valid_p n_ge0; rewrite in_dom=> /= m_pvx1.
        move=> _ b _ _; rewrite getP /= oget_some getP /= oget_some /=; split.
        + move=> p n; rewrite in_dom getP; case ((p,n) = (p',n'))=> //= _.
          by rewrite -in_dom=> /h1.
        move=> p0 n0 valid_p' n'_ge0; rewrite !getP h2 // -h_def.
        case: (extend p0 n0 = (rcons p (v +^ x.`1)){2})=> //=.
        + by rewrite -extendK=> // ->.
        case: ((p0,n0) = (strip (rcons p (v +^ x.`1))){2})=> //=.
        smt (stripK).
      + auto=> /> &1 &2; case _: (strip (rcons p (v +^ x.`1)){2})=> p' n' h_def [#] !->>.
        by move=> _ _ h1 h2 /= valid_p' n'_ge0 _; rewrite h2 //; smt (stripK).
      by auto.
    rcondf{1} 6; 1:by auto.
    rcondf{2} 6; 1:by auto.
    by auto.
  + by proc; if=> //=; auto.
  proc; sp; if=> //=; inline{1} 2.
  rcondt{1} 4; 1:auto.
  + by move=> &hr [#] !->> h1 h2 valid_p n_ge0 /=; rewrite extendK.
  sp; if=> //=.
  + by move=> /> &1 &2 h1 h2 valid_p n_ge0; rewrite !in_dom h2 // -extendK.
  + auto=> /> &1 &2 h1 h2 valid_p n_ge0; rewrite in_dom=> /= ^extend_pn_notin_m.
    rewrite -h2=> // pn_notin_m _ b _ _; rewrite 2!getP /=; split.
    + move=> p' n'; rewrite in_dom getP; case ((p',n') = (p{2},n{2}))=> //= _.
      by rewrite -in_dom=> /h1.
    move=> p0 m0 valid_p0 n0_ge0; rewrite !getP h2 // -!extendK //.
    case: (extend p0 m0 = extend p{2} n{2})=> [->|] //.
    by have /contra H /H ->:= (injective_strip (extend p0 m0) (extend p{2} n{2})).
  by auto=> /> &1 &2 h1 h2 valid_p n_ge0 _; rewrite -h2.      
  qed.

end section PROOF.
