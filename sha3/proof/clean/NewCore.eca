require import Pred Fun Option Pair Int Real List FSet NewFMap NewDistr.
require import StdOrder Ring DProd.
(*---*) import IntOrder.

require (*..*) RP Indifferentiability.

require import NewCommon.
(*---*) import Block DBlock Capacity DCapacity.

(** Validity of Functionality Queries **)
op valid: block list -> bool.

(*** DEFINITIONS ***)
type state  = block  * capacity.
op   dstate = bdistr `*` cdistr.

(** Indifferentiability Experiment **)
clone include Indifferentiability with
  type p     <- state,
  type f_in  <- block list,
  type f_out <- block list
  rename [module] "GReal" as "RealIndif"
         [module] "GIdeal"  as "IdealIndif".

(** Ideal Primitive **)
clone export RP as Perm with
  type t <- block * capacity,
  op   dt <- bdistr `*` cdistr
  rename
    [module type] "RP" as "PRIMITIVE"
    [module] "P" as "Perm".

(** Core Construction **)
module (Core : CONSTRUCTION) (P:DPRIMITIVE): FUNCTIONALITY = {
  proc init () = {}

  proc f(p : block list): block list = {
    var (sa,sc) <- (b0,c0);
    var r <- [];
    var i <- 0;

    while (i < size p) {
      (sa,sc) <@ P.f((sa +^ nth witness p i,sc));
      r <- rcons r sa;
      i <- i + 1;
    }
    return r;
  }
}.

(** Ideal Core Functionality **)
module ICore : FUNCTIONALITY = {
  var m : (block list,block) fmap

  proc init() = {
    m = map0;
  }

  proc fill_in(p : block list) = {
    if (!mem (dom m) p) {
      m.[p] <$ bdistr;
    }
    return oget m.[p];
  }

  proc f(p : block list): block list = {
    var r <- [];
    var i <- 1;
    var b;

    if (valid p) {
      while (i <= size p) {
        b <@ fill_in(take i p);
        r <- rcons r b;
        i <- i + 1;
      }
    }
    return r;
  }
}.

(** Core Simulator **)
module (S : SIMULATOR) (F : DFUNCTIONALITY) : PRIMITIVE = {
  var m, mi : (state,state) fmap
  var pi    : (capacity, block list * block) fmap

  proc init() = {
    m  <- map0;
    mi <- map0;
    pi <- map0.[c0 <- ([<:block>],b0)];
  }

  proc f(x : state): state = {
    var p, v, y, y1, y2;
    var b;

    if (!mem (dom m) x) {
      if (mem (dom pi) x.`2) {
        (p,v) <- oget pi.[x.`2]; 
        (* Not sure *)
        b     <- F.f (rcons p (v +^ x.`1));
        y1    <- last b0 b;
      } else {
        y1 <$ bdistr;
      }
      y2     <$ cdistr;
      y      <- (y1,y2);
      m.[x]  <- y;
      mi.[y] <- x;
      if (mem (dom pi) x.`2) {
        (p,v)     <- oget pi.[x.`2]; 
        pi.[y.`2] <- (rcons p (v +^ x.`1), y.`1);
      }
    } else {   
      y <- oget m.[x];
    }
    return y;
  }

  proc fi(x : state): state = {
    var y, y1, y2;

    if (!mem (dom mi) x) {
      y1     <$ bdistr;
      y2     <$ cdistr;
      y      <- (y1,y2);
      mi.[x] <- y;
      m.[y]  <- x;
    } else {
      y <- oget mi.[x];
    }
    return y;
  }
}.

(** Initial and Final Games **)
module GReal  (D : DISTINGUISHER) = RealIndif(Core,Perm,D).
module GIdeal (D : DISTINGUISHER) = IdealIndif(ICore,S,D).
