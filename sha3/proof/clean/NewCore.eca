require import Core Int Real List FSet NewFMap Distr.
require import StdOrder Ring DProd.
(*---*) import IntOrder.

require (*..*) RP Indifferentiability.

require import NewCommon.
(*---*) import Block DBlock Capacity DCapacity.

(** Validity of Functionality Queries **)
op valid: block list * int -> bool.

(*** DEFINITIONS ***)
type state  = block  * capacity.
op   dstate = bdistr `*` cdistr.

(** Indifferentiability Experiment **)
clone include Indifferentiability with
  type p     <- state,
  type f_in  <- block list * int,
  type f_out <- block list
  rename [module] "GReal" as "RealIndif"
         [module] "GIdeal"  as "IdealIndif".

(** CORE Construction **)
module (CORE : CONSTRUCTION) (P : DPRIMITIVE): FUNCTIONALITY = {
  proc init () = {}

  proc f(p : block list, n : int): block list = {
    var (sa,sc) <- (b0,c0);
    var r <- [];
    var i <- 0;

    while (i < size p) {
      (sa,sc) <@ P.f((sa +^ nth witness p i,sc));
      i <- i + 1;
    }
    i <- 1;
    if (valid (p,n)) {
      while(i <= n) {
        r <- rcons r sa;
        i <- i + 1;
        if (i <= n) {
          (sa,sc) <@ P.f(sa,sc);
        }
      }
    }
    return r;
  }
}.

(** Ideal CORE Functionality **)
module ICORE : FUNCTIONALITY = {
  var m : (block list * int,block) fmap

  proc init() = {
    m = map0;
  }

  proc fill_in(p : block list, n : int): block = {
    if (!mem (dom m) (p,n)) {
      m.[(p,n)] <$ bdistr;
    }
    return oget m.[(p,n)];
  }

  proc f(p : block list, n : int): block list = {
    var r <- [];
    var i <- 1;
    var b;

    if (valid (p,n)) {
      while (i <= n) {
        b <@ fill_in(p,i);
        r <- rcons r b;
        i <- i + 1;
      }
    }
    return r;
  }
}.

(** CORE Simulator **) 
module (S : SIMULATOR) (F : DFUNCTIONALITY) : PRIMITIVE = {
  var m, mi : (state,state) fmap
  var pi    : (capacity, block list * block) fmap

  proc init() = {
    m  <- map0;
    mi <- map0;
    pi <- map0.[c0 <- ([<:block>],b0)];
  }

  proc f(x : state): state = {
    var p, v, y, y1, y2;
    var b;

    if (!mem (dom m) x) {
      if (mem (dom pi) x.`2) {
        (p,v) <- oget pi.[x.`2]; 
        b     <- F.f (rcons p (v +^ x.`1),1);
        y1    <- last b0 b;
      } else {
        y1 <$ bdistr;
      }
      y2     <$ cdistr;
      y      <- (y1,y2);
      m.[x]  <- y;
      mi.[y] <- x;
      if (mem (dom pi) x.`2) {
        (p,v)     <- oget pi.[x.`2]; 
        pi.[y.`2] <- (rcons p (v +^ x.`1), y.`1);
      }
    } else {   
      y <- oget m.[x];
    }
    return y;
  }

  proc fi(x : state): state = {
    var y, y1, y2;

    if (!mem (dom mi) x) {
      y1     <$ bdistr;
      y2     <$ cdistr;
      y      <- (y1,y2);
      mi.[x] <- y;
      m.[y]  <- x;
    } else {
      y <- oget mi.[x];
    }
    return y;
  }
}.
