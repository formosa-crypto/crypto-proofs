require import Pred Fun Option Pair Int Real List FSet NewFMap NewDistr.
require import StdOrder Ring DProd.
(*---*) import IntOrder.

require (*..*) RP Indifferentiability.

(*** THEORY PARAMETERS ***)
(** Block/Rate **)
theory Block.
  op r : int.
  axiom r_ge0: 0 <= r.

  type block.

  op b0: block.
  op (+^): block -> block -> block.

  axiom addbA b1 b2 b3: b1 +^ (b2 +^ b3) = b1 +^ b2 +^ b3.
  axiom addbC b1 b2: b1 +^ b2 = b2 +^ b1.
  axiom add0b b: b0 +^ b = b.
  axiom addbK b: b +^ b = b0.

  op enum: block list.
  axiom block_enum b: count (pred1 b) enum = 1.
  axiom card_block: size enum = 2^r.

  clone import Ring.ZModule as BlockMonoid with 
    type t               <- block,
    op zeror             <- b0,
    op ( + )             <- (+^),
    op [ - ] (b : block) <- b
  remove abbrev (-)
  proof *.
  realize addrA by exact/addbA.
  realize addrC by exact/addbC.
  realize add0r by exact/add0b.
  realize addNr by exact/addbK.

  clone import MFinite as DBlock with
    type t            <- block,
    op   Support.enum <- enum
  rename "dunifin"  as "bdistr"
         "duniform" as "bdistr"
  proof *.
  realize Support.enum_spec by exact/block_enum.
end Block.
import Block DBlock.

(**  Capacity  **)
theory Capacity.
  op c : int.
  axiom c_ge0: 0 <= c.

  type capacity.

  op c0: capacity.

  op enum: capacity list.
  axiom capacity_enum b: count (pred1 b) enum = 1.
  axiom card_capacity: size enum = 2^c.

  clone import MFinite as DCapacity with
    type t            <- capacity,
    op   Support.enum <- enum
  rename "dunifin"  as "cdistr"
         "duniform" as "cdistr"
  proof *.
  realize Support.enum_spec by exact/capacity_enum.
end Capacity.
import Capacity DCapacity.

(** Validity of Functionality Queries **)
op valid: block list -> bool.
axiom valid_not_nil m: valid m => m <> [].

(** Adversary's Query Cost **)
op max_query: int.
axiom max_query_ge0: 0 <= max_query.

(*** DEFINITIONS ***)
type state  = block  * capacity.
op   dstate = bdistr `*` cdistr.

(** Indifferentiability Experiment **)
clone include Indifferentiability with
  type p     <- state, 
  type f_in  <- block list,
  type f_out <- block
  rename [module] "GReal" as "RealIndif"
         [module] "GIdeal"  as "IdealIndif".

(** Query Counting **)
module C = {
  var c:int
  proc init() = { c <- 0; }
}.

module PC (P : PRIMITIVE) : PRIMITIVE = {
  proc init () = {
    C.init();
    P.init();
  }

  proc f (x : state) = {
    var y;

    C.c <- C.c + 1;
    y   <@ P.f(x);
    return y;
  }

  proc fi(x : state) = {
    var y;

    C.c <- C.c + 1;
    y   <@ P.fi(x);
    return y;
  }
}.

module DPRestr (P : DPRIMITIVE) : DPRIMITIVE = {
  proc f (x : state) = {
    var y <- (b0,c0);

    if (C.c + 1 <= max_query) {
      C.c <- C.c + 1;
      y   <@ P.f(x);
    }
    return y;
  }

  proc fi(x : state) = {
    var y <- (b0,c0);

    if (C.c + 1 <= max_query) {
      C.c <- C.c + 1;
      y   <@ P.fi(x);
    }
    return y;
  }
}.

module PRestr (P : PRIMITIVE) : PRIMITIVE = {
  proc init () = {
    C.init();
    P.init();
  }

  proc f = DPRestr(P).f
  proc fi = DPRestr(P).fi
}.

module FC (F : FUNCTIONALITY) : FUNCTIONALITY = {
  proc init = F.init

  proc f (p : block list) = {
    var b <- witness;

    C.c <- C.c + size p;
    b   <@ F.f(p);
    return b;
  }
}.

module DFRestr (F : DFUNCTIONALITY) : DFUNCTIONALITY = {
  proc f (bs : block list) = {
    var b <- b0;

    if (C.c + size bs <= max_query) {
      C.c <- C.c + size bs;
      b <@ F.f(bs);
    }
    return b;
  }
}.

module FRestr(F : FUNCTIONALITY) : FUNCTIONALITY = {
  proc init = F.init
  proc f = DFRestr(F).f
}.

module (DRestr (D : DISTINGUISHER) : DISTINGUISHER)
         (F : DFUNCTIONALITY) (P : DPRIMITIVE) = {
  proc distinguish() = {
    var b;

         C.init();
    b <@ D(DFRestr(F), DPRestr(P)).distinguish();
    return b;
  }
}.

(** Ideal Primitive **)
clone export RP as Perm with
  type t <- block * capacity,
  op   dt <- bdistr `*` cdistr
  rename
    [module type] "RP" as "PRIMITIVE"
    [module] "P" as "Perm".

(** Core Construction **)
module (Core : CONSTRUCTION) (P:DPRIMITIVE): FUNCTIONALITY = {
  proc init () = {}

  proc f(p : block list): block = {
    var (sa,sc) <- (b0,c0);

    while (p <> []) {
      (sa,sc) <@ P.f((sa +^ head witness p,sc));
      p <- behead p;
    }
    return sa;
  }
}.

(** Ideal Core Functionality **)
module ICore: FUNCTIONALITY = {
  var m : (block list,block) fmap

  proc init() = {
    m = map0;
  }

  proc f(p : block list): block = {
    var r <- witness;

    if (valid p) {
      if (!mem (dom m) p) {
        m.[p] <$ bdistr;
      }
      r <- oget m.[p];
    }
    return r;
  }
}.

(** Core Simulator **)
module (S : SIMULATOR) (F : DFUNCTIONALITY) : PRIMITIVE = {
  var m, mi : (state,state) fmap
  var pi    : (capacity, block list * block) fmap

  proc init() = {
    m  <- map0;
    mi <- map0;
    pi <- map0.[c0 <- ([<:block>],b0)];
  }

  proc f(x : state): state = {
    var p, v, y, y1, y2;

    if (!mem (dom m) x) {
      if (mem (dom pi) x.`2) {
        (p,v) <- oget pi.[x.`2]; 
        y1    <- F.f (rcons p (v +^ x.`1));
      } else {
        y1 <$ bdistr;
      }
      y2     <$ cdistr;
      y      <- (y1,y2);
      m.[x]  <- y;
      mi.[y] <- x;
      if (mem (dom pi) x.`2) {
        (p,v)     <- oget pi.[x.`2]; 
        pi.[y.`2] <- (rcons p (v +^ x.`1), y.`1);
      }
    } else {   
      y <- oget m.[x];
    }
    return y;
  }

  proc fi(x : state): state = {
    var y, y1, y2;

    if (!mem (dom mi) x) {
      y1     <$ bdistr;
      y2     <$ cdistr;
      y      <- (y1,y2);
      mi.[x] <- y;
      m.[y]  <- x;
    } else {
      y <- oget mi.[x];
    }
    return y;
  }
}.

(** Initial and Final Games **)
module GReal  (D : DISTINGUISHER) = RealIndif(Core,PC(Perm),D).

module GIdeal (D : DISTINGUISHER) = IdealIndif(ICore,S,D).

(*** PROOF ***)
(** TODO -- This is not indifferentiability -- clean up and fix **)
(** However, this is what's proven (modulo the additional validity
    check in ICore, not present in IF. The validity checks may be
    problematic in combination with counting, so we need to make sure
    both are present throughout before diving in. **)
lemma CoreIndiff (D <: DISTINGUISHER {C, Perm, Core, ICore, S}) &m:
     (forall (F <: DFUNCTIONALITY {D}) (P <: DPRIMITIVE {D}),
           islossless P.f
        => islossless P.fi
        => islossless F.f
        => islossless D(F,P).distinguish)
  => Pr[RealIndif(Core,PC(Perm),D).main() @ &m: res /\ C.c <= max_query]
     <= Pr[IdealIndif(ICore,S,DRestr(D)).main() @ &m :res]
        + (max_query ^ 2)%r / (2^(r + c))%r
        + max_query%r * ((2*max_query)%r / (2^c)%r)
        + max_query%r * ((2*max_query)%r / (2^c)%r).
abort.
