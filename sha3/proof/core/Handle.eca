pragma -oldip. pragma +implicits.
require import Pred Fun Option Pair Int Real StdOrder Ring NewLogic.
require import List FSet NewFMap Utils Common SLCommon RndO.
require import DProd Dexcepted.
(*...*) import Capacity IntOrder.

require ConcreteF.

clone import GenEager as ROhandle with
    type from   <- handle,
    type to     <- capacity,
    op sampleto <- fun (_:int) => cdistr
    proof sampleto_ll by apply DWord.cdistr_ll.

module G1(D:DISTINGUISHER) = {
  var m, mi               : smap
  var mh, mhi             : hsmap
  var chandle             : int
  var paths               : (capacity, block list * block) fmap
  var bext, bcol          : bool

  module C = {

    proc f(p : block list): block = {
      var sa, sa', sc;
      var h, i <- 0; 
      sa <- b0;
      while (i < size p ) {
        if (mem (dom mh) (sa +^ nth witness p i, h)) {
          (sa, h) <- oget mh.[(sa +^ nth witness p i, h)];
        } else {
          sc                  <$ cdistr;
          bcol                <- bcol \/ hinv FRO.m sc <> None;
          sa'                 <@ F.RO.get(take (i+1) p);
          sa                  <- sa +^ nth witness p i;
          mh.[(sa,h)]         <- (sa', chandle);
          mhi.[(sa',chandle)] <- (sa, h);
          (sa,h)              <- (sa',chandle);
          FRO.m.[chandle]     <- (sc,Unknown);
          chandle             <- chandle + 1;
        }
        i        <- i + 1;
      }
      sa <- F.RO.get(p);
      return sa;
    }
  }

  module S = {

    proc f(x : state): state = {
      var p, v, y, y1, y2, hy2, hx2;

      if (!mem (dom m) x) {
        if (mem (dom paths) x.`2) {
          (p,v) <- oget paths.[x.`2]; 
          y1    <- F.RO.get (rcons p (v +^ x.`1));
          y2    <$ cdistr;
        } else {
          y1    <$ bdistr;
          y2    <$ cdistr;
        }
        y     <- (y1, y2);
        bext <- bext \/ mem (rng FRO.m) (x.`2, Unknown);   
        if (!(mem (rng FRO.m) (x.`2, Known))) {
          FRO.m.[chandle] <- (x.`2, Known);
          chandle <- chandle + 1;
        }
        hx2 <- oget (hinvK FRO.m x.`2);
        if (mem (dom mh) (x.`1, hx2) /\ in_dom_with FRO.m (oget mh.[(x.`1,hx2)]).`2 Unknown) {
          hy2               <- (oget mh.[(x.`1, hx2)]).`2;
          y                 <- (y.`1, (oget FRO.m.[hy2]).`1);
          FRO.m.[hy2]       <- (y.`2, Known);
          m.[x]             <- y;
          mi.[y]            <- x;
        } else {
          bcol              <- bcol \/ hinv FRO.m y.`2 <> None;          
          hy2               <- chandle;
          chandle           <- chandle + 1;
          FRO.m.[hy2]       <- (y.`2, Known);
          m.[x]             <- y;
          mh.[(x.`1, hx2)]  <- (y.`1, hy2);
          mi.[y]            <- x;
          mhi.[(y.`1, hy2)] <- (x.`1, hx2);
        }
        if (mem (dom paths) x.`2) {
          (p,v) <- oget paths.[x.`2]; 
          paths.[y.`2] <- (rcons p (v +^ x.`1), y.`1);
        }

      } else {   
        y <- oget m.[x];
      }
      return y;
    }

    proc fi(x : state): state = {
      var y, y1, y2, hx2, hy2;

      if (!mem (dom mi) x) {
        bext <- bext \/ mem (rng FRO.m) (x.`2, Unknown);   
        if (!(mem (rng FRO.m) (x.`2, Known))) {
          FRO.m.[chandle] <- (x.`2, Known);
          chandle <- chandle + 1;
        }
        hx2 <- oget (hinvK FRO.m x.`2);
        y1  <$ bdistr;
        y2  <$ cdistr;
        y   <- (y1,y2);
        if (mem (dom mhi) (x.`1,hx2) /\
            in_dom_with FRO.m (oget mhi.[(x.`1,hx2)]).`2 Unknown) {
          (y1,hy2)          <- oget mhi.[(x.`1, hx2)];
          y                 <- (y.`1, (oget FRO.m.[hy2]).`1);
          FRO.m.[hy2]       <- (y.`2, Known);
          mi.[x]            <- y;
          m.[y]             <- x;
        } else {
          bcol              <- bcol \/ hinv FRO.m y.`2 <> None;          
          hy2               <- chandle;
          chandle           <- chandle + 1;
          FRO.m.[hy2]       <- (y.`2, Known);
          mi.[x]            <- y;
          mhi.[(x.`1, hx2)] <- (y.`1, hy2);
          m.[y]             <- x;
          mh.[(y.`1, hy2)]  <- (x.`1, hx2);
        }
      } else {
        y <- oget mi.[x];
      }
      return y;
    }

  }

  proc main(): bool = {
    var b;

    F.RO.m   <- map0;
    m        <- map0;
    mi       <- map0;
    mh       <- map0;
    mhi      <- map0;
    bext     <- false;
    bcol     <- false;

    (* the empty path is initially known by the adversary to lead to capacity 0^c *)
    FRO.m    <- map0.[0 <- (c0, Known)];
    paths    <- map0.[c0 <- ([<:block>],b0)];
    chandle  <- 1;
    b        <@ D(C,S).distinguish();
    return b;
  }    
}.

(* -------------------------------------------------------------------------- *)
inductive eqm_handles (hs : handles) (m : smap) (mh : hsmap) =
  | MH of (forall xa xc ya yc,
             m.[(xa,xc)] = Some (ya,yc) =>
             exists xh yh xf yf,
                  hs.[xh]      = Some (xc,xf)
               /\ hs.[yh]      = Some (yc,yf)
               /\ mh.[(xa,xh)] = Some (ya,yh))
        & (forall xa xh ya yh,
             mh.[(xa,xh)] = Some (ya,yh) =>
             exists xc yc xf yf,
                  hs.[xh]     = Some (xc,xf)
               /\ hs.[yh]     = Some (yc,yf)
               /\ m.[(xa,xc)] = Some (ya,yc)).

inductive mh_spec (hs : handles) (m2 : smap) (mh : hsmap) (ro : (block list,block) fmap) =
  | H of (forall xa xh ya yh,
            mh.[(xa,xh)] = Some (ya,yh) =>
            exists xc yc xf yf,
                 hs.[xh] = Some (xc,xf)
              /\ hs.[yh] = Some (yc,yf)
              /\ if   yf = Known
                 then    m2.[(xa,xc)] = Some (ya,yc)
                      /\ xf = Known
                 else exists p v b,
                      ro.[rcons p b] = Some ya
                   /\ build_hpath mh p = Some (v,xh)
                   /\ xa = v +^ b)
       & (forall p xa b,
            ro.[rcons p xa] = Some b <=>
            exists v xh yh,
                 build_hpath mh p = Some (v,xh)
              /\ mh.[(v +^ xa,xh)] = Some (b,yh)).

inductive paths_spec (hs : handles) (mh : hsmap) (pi : (capacity,block list*block) fmap) =
  | P of (forall c p v,
            pi.[c] = Some (p,v) <=>
            exists h,
                 build_hpath mh p = Some(v,h)
              /\ hs.[h] = Some (c,Known)).

inductive handles_spec hs ch =
  | Hs of (huniq hs)
        & (hs.[0] = Some (c0,Known))
        & (forall h, mem (dom hs) h => h < ch).

inductive INV_CF_G1 (hs : handles) ch (m1 mi1 m2 mi2 : smap)
                    (mh2 mhi2 : hsmap) (ro : (block list,block) fmap) pi =
  | HCF_G1 of (eqm_handles hs m1 mh2)
            & (eqm_handles hs mi1 mhi2)
            & (incl m2 m1)
            & (incl mi2 mi1)
            & (mh_spec hs m2 mh2 ro)
            & (paths_spec hs mh2 pi)
            & (handles_spec hs ch).

lemma eqm_of_INV (ch : handle)
                 (mi1 m2 mi2 : smap) (mhi2 : hsmap)
                 (ro : (block list, block) fmap)
                 (pi : (capacity, block list * block) fmap)
                 hs m1 mh2:
  INV_CF_G1 hs ch m1 mi1 m2 mi2 mh2 mhi2 ro pi =>
  eqm_handles hs m1 mh2.
proof. by case. qed.

lemma eqmi_of_INV (ch : handle)
                  (m1 m2 mi2 : smap) (mh2 : hsmap)
                  (ro : (block list, block) fmap)
                  (pi : (capacity, block list * block) fmap)
                  hs mi1 mhi2:
  INV_CF_G1 hs ch m1 mi1 m2 mi2 mh2 mhi2 ro pi =>
  eqm_handles hs mi1 mhi2.
proof. by case. qed.

lemma incl_of_INV (hs : handles) (ch : handle)
                  (mi1 mi2 : smap) (mh2 mhi2: hsmap)
                  (ro : (block list, block) fmap)
                  (pi : (capacity, block list * block) fmap)
                  m1 m2:
  INV_CF_G1 hs ch m1 mi1 m2 mi2 mh2 mhi2 ro pi =>
  incl m2 m1.
proof. by case. qed.

lemma incli_of_INV (hs : handles) (ch : handle)
                   (m1 m2 : smap) (mh2 mhi2: hsmap)
                   (ro : (block list, block) fmap)
                   (pi : (capacity, block list * block) fmap)
                   mi1 mi2:
  INV_CF_G1 hs ch m1 mi1 m2 mi2 mh2 mhi2 ro pi =>
  incl mi2 mi1.
proof. by case. qed.

lemma mh_of_INV (ch : handle)
                (m1 mi1 mi2 : smap) (mhi2 : hsmap)
                (pi : (capacity, block list * block) fmap)
                hs m2 mh2 ro:
  INV_CF_G1 hs ch m1 mi1 m2 mi2 mh2 mhi2 ro pi =>
  mh_spec hs m2 mh2 ro.
proof. by case. qed.

lemma paths_of_INV (ch : handle)
                   (m1 m2 mi1 mi2: smap) (mhi2: hsmap)
                   (ro : (block list, block) fmap)
                   hs mh2 pi:
  INV_CF_G1 hs ch m1 mi1 m2 mi2 mh2 mhi2 ro pi =>
  paths_spec hs mh2 pi.
proof. by case. qed.

lemma handles_of_INV (m1 m2 mi1 mi2 : smap) (mh2 mhi2 : hsmap)
                     (ro : (block list, block) fmap)
                     (pi : (capacity, block list * block) fmap)
                     hs ch:
  INV_CF_G1 hs ch m1 mi1 m2 mi2 mh2 mhi2 ro pi =>
  handles_spec hs ch.
proof. by case. qed.

lemma eqm_dom_mh_m hs m mh hx2 f (x:state):
  eqm_handles hs m mh =>
  hs.[hx2] = Some (x.`2, f) =>
  mem (dom mh) (x.`1, hx2) => mem (dom m) x.
proof.
move=>[]H1 H2 Hhx2;rewrite !in_dom.
case: (mh.[_]) (H2 x.`1 hx2) => //= -[] b' h' /(_ b' h') [c c' f1 f1'].
by rewrite Hhx2=> /= -[][]<<- _;case:(x)=> ??[]_->.
qed.

lemma chandle_ge0 hs ch : handles_spec hs ch => 0 < ch.
proof. by case=> _ Heq Hlt; apply Hlt; rewrite in_dom Heq. qed.

lemma chandle_0 hs ch : handles_spec hs ch => 0 <> ch.
proof. by move=> Hh;apply/ltr_eqF/(@chandle_ge0 _ _ Hh). qed.

lemma eqm_up_handles hs ch m mh x2 :
   handles_spec hs ch =>
   eqm_handles hs m mh =>
   eqm_handles hs.[ch <- (x2, Known)] m mh.
proof.
case=> Hu Hh0 Hlt [] m_some mh_some; split.
+ move=> xb xc xb' xc' /m_some [h h' f f'] [#] Hh Hh' Hmh.
  exists h, h', f, f'; rewrite !getP Hmh -Hh -Hh' /=.
  rewrite ltr_eqF /=; 1:by apply/Hlt; rewrite in_dom Hh.
  by rewrite ltr_eqF; 1:by apply/Hlt; rewrite in_dom Hh'.
move=> xb xh xb' xh' /mh_some [c c' f f'] [#] Hh Hh' Hm.
exists c, c', f, f'; rewrite !getP Hm -Hh -Hh'.
rewrite ltr_eqF /=; 1:by apply/Hlt; rewrite in_dom Hh.
by rewrite ltr_eqF; 1:by apply/Hlt; rewrite in_dom Hh'.
qed.

lemma mh_up_handles hs ch m2 mh ro cf:
   handles_spec hs ch =>
   mh_spec hs m2 mh ro =>
   mh_spec hs.[ch <- cf] m2 mh ro.
proof.
move=> + [] mh_some ?=> -[] _ _ Hlt; split=> // b h b' h' /mh_some [c c' f f'] [#] Hh Hh' Hif.
exists c,c',f,f'; rewrite Hif -Hh -Hh' !getP.
rewrite ltr_eqF /=; 1:by apply/Hlt; rewrite in_dom Hh.
by rewrite ltr_eqF; 1:by apply/Hlt; rewrite in_dom Hh'.
qed.

lemma paths_up_handles m2 ro hs mh pi cf ch:
  mh_spec hs m2 mh ro =>
  handles_spec hs ch =>
  paths_spec hs mh pi =>
  paths_spec hs.[ch <- cf] mh pi.
proof.
move=> Hmh Hh [] Hp; split=> c p v; rewrite Hp; apply exists_iff=> x /=.
split=>- [] ^Hbu -> /=; rewrite getP.
+ case: Hh=> _ _ Hlt x_in_handles.
  by rewrite ltr_eqF; 1:by apply/Hlt; rewrite in_dom x_in_handles.
case: (x = ch)=> //=.
move: Hbu=> /build_hpathP [[#] _ _ ->|[p' b v' h' [#] _ _ Hh']].
+ by rewrite (@chandle_0 _ _ Hh).
case: Hh=> _ _ /(_ x) Hlt; rewrite ltr_eqF //.
by apply/Hlt; rewrite in_dom; case: Hmh=> /(_ _ _ _ _ Hh') [????] [#] _ ->.
qed.

lemma handles_up_handles hs ch x2 f':
  (forall (f : flag), ! mem (rng hs) (x2, f)) =>
  handles_spec hs ch =>
  handles_spec hs.[ch <- (x2, f')] (ch + 1).
proof.
move=> Hx2 ^Hh [] Hu Hh0 Hlt; split.
+ move=> h1 h2 [c1 f1] [c2 f2]; rewrite !getP /=.
  case: (h1 = ch)=> /= [-> [] ->> ->|_]; (case: (h2 = ch)=> [-> //= |_]).
  + by move=> Heq ->>; move: (Hx2 f2); rewrite in_rng negb_exists=> /= /(_ h2).
  + by move=> Heq [] ->> <<- ->>; move: (Hx2 f1); rewrite in_rng negb_exists=> /= /(_ h1).
  by apply Hu.
+ by rewrite getP (@chandle_0 _ _ Hh).
+ by move=> h; rewrite dom_set !inE /#.
qed.

lemma INV_CF_G1_up_handles hs ch m1 mi1 m2 mi2 mh mhi ro pi x2:
   INV_CF_G1 hs ch m1 mi1 m2 mi2 mh mhi ro pi =>
   (forall f, !mem (rng hs) (x2, f)) =>
   INV_CF_G1 hs.[ch <- (x2, Known)] (ch + 1) m1 mi1 m2 mi2 mh mhi ro pi.
proof.
case=> Heqm Heqmi Hincl Hincli Hmh Hp Hh Hx2.
exact/(HCF_G1 (eqm_up_handles Hh Heqm) (eqm_up_handles Hh Heqmi)
              _ _
              (:@mh_up_handles _ _ _ _ _ (x2,Known) Hh Hmh)
              (:@paths_up_handles m2 ro _ _ _ (x2,Known) _ Hmh Hh Hp)
              (:@handles_up_handles _ _ x2 Known _ Hh)).
qed.

lemma eqm_handles_up (hs : handles) m mh (h hx:handle) (x y : state) f:
  huniq hs =>
  hs.[h]  = None =>
  hs.[hx] = Some (x.`2, f) =>
  eqm_handles hs m mh =>
  eqm_handles hs.[h <- (y.`2,Known)] m.[x <- y] mh.[(x.`1,hx) <- (y.`1,h)].
proof.
move=> uniq_h h_h h_hx @/eqm_handles [] hmmh hmhm; split.
+ move=> b c b' c'; rewrite getP; case ((b,c) = x)=> /= [<<- ->> {x y} /=|].
  * by exists hx, h, f, Known; rewrite !getP /= [smt (in_dom)].
  move=> bc_neq_x /hmmh [] h0 h0' f0 f0' [#] h_h0 h_h0' mhi_bc.
  by exists h0, h0', f0, f0'; rewrite !getP [smt (in_dom)].
move=> xb xh b' h'; rewrite getP; case ((xb,xh) = (x.`1,hx))=> /= [[#] <*> [#] <*>|].
  * by exists x.`2, y.`2, f, Known; rewrite !getP [smt (in_dom)].
rewrite anda_and negb_and=> bh_neq_x1hx /hmhm /= [] c0 c0' f0 f0' [#] h_h0 h_bh' m_bc.
exists c0, c0', f0, f0'; rewrite !getP.
split; 1:smt (in_dom).
split; 1:smt (in_dom).
case x bh_neq_x1hx h_hx=> x1 x2 /= => - [/#|h0_neq_hx h_hx].
have -> //=: c0 <> x2; move: h0_neq_hx; apply/contra.
exact/(@uniq_h _ _ _ _ h_h0 h_hx).
qed.

lemma eqmi_handles_up (hs : handles) mi mhi (h hx : handle) (x y : state) f:
  (!exists f', mem (rng hs) (y.`2,f')) =>
  hs.[h]  = None =>
  hs.[hx] = Some (x.`2, f) =>
  eqm_handles hs mi mhi =>
  eqm_handles hs.[h <- (y.`2,Known)] mi.[y <- x] mhi.[(y.`1,h) <- (x.`1,hx)].
proof.
move=> y_notinr1_handles h_h h_hx @/eqm_handles [] hmmh hmhm; split.
+ move=> xb xc xb' xc'; rewrite getP; case ((xb,xc) = y)=> /= [<<- ->> {x y}|].
  * by exists h, hx, Known, f; rewrite !getP /= [smt (in_dom)].
  move=> bc_neq_y /hmmh [] h0 h0' f0 f0' [#] h_h0 h_h0' mhi_bc.
  by exists h0, h0', f0, f0'; rewrite !getP [smt (in_dom)].
move=> xb xh xb' xh'; rewrite getP; case ((xb,xh) = (y.`1,h))=> /= [[#] <*> [#] <*>|].
  * by exists y.`2, x.`2, Known, f; rewrite !getP [smt (in_dom)].
rewrite anda_and negb_and=> bh_neq_y1h /hmhm /= [] c0 c0' f0 f0' [#] h_bh h_bh' mi_bh.
exists c0, c0', f0, f0'; rewrite !getP.
split; 1:smt (in_dom).
split; 1:smt (in_dom).
case y bh_neq_y1h y_notinr1_handles=> y1 y2 /= [/#|h0_neq_h y_notinr1_handles].
have /#: c0 = y2 => false; move=> /(congr1 (fun x=> exists f', mem (rng hs) (x,f'))) /=.
rewrite y_notinr1_handles /= neqF /=; exists f0.
by rewrite in_rng; exists xh.
qed.

lemma incl_set (m m' : ('a,'b) fmap) x y:
  incl m m' =>
  incl m.[x <- y] m'.[x <- y].
proof. smt (in_dom getP). qed.

lemma hinv_notin_rng m y2:
  SLCommon.hinv m y2 = None =>
  (forall h f, m.[h] <> Some (y2,f)).
proof. by move=> hinv_none; have:= hinvP m y2; rewrite hinv_none. qed.

lemma handles_spec_notin_dom m h:
  handles_spec m h =>
  !mem (dom m) h.
proof. case; smt (in_dom). qed.

lemma neq_Known f: f <> Known <=> f = Unknown.
proof. by case f. qed.

lemma neq_Unkwown f: f <> Unknown <=> f = Known.
proof. by case f. qed.

op getflag (hs : handles) xc =
  omap snd (obind ("_.[_]" hs) (hinv hs xc)).

lemma getflagP hs xc f:
  huniq hs =>
  (mem (rng hs) (xc,f) <=> getflag hs xc = Some f).
proof.
move=> huniq_hs; split.
+ rewrite in_rng=> -[h] hs_h.
  move: (hinvP hs xc)=> [_ /(_ h f) //|].
  rewrite /getflag; case: (hinv hs xc)=> // h' _ [f']; rewrite oget_some.
  move=> /(huniq_hs _ h _ (xc,f)) /(_ hs_h) /= ->>.
  by rewrite hs_h.
rewrite /getflag; case: (hinvP hs xc)=> [-> //|].
rewrite in_rng; case: (hinv hs xc)=> //= h [f'].
rewrite oget_some=> ^ hs_h -> @/snd /= ->>.
by exists h.
qed.

lemma paths_prefix handles m2 mh ro paths c b p v:
  mh_spec handles m2 mh ro =>
  paths_spec handles mh paths =>
  paths.[c] = Some (rcons p b,v) =>
  (exists c' v', paths.[c'] = Some (p,v')).
proof.
move=> [] mh_some _ [] hpaths ^paths_c.
move=> /hpaths [h] [#] /build_hpathP [/#|] [p' b' v' h'] [#] ^/rconsIs + /rconssI- <*>.
move=> hpath + handles_h - /mh_some /= [c' c0 f' f]; rewrite handles_h /= => /> handles_h' _.
by exists c', v'; rewrite hpaths; exists h'.
qed.

lemma build_hpath_prefix mh p b v h:
  build_hpath mh (rcons p b) = Some (v,h) =>
  (exists v' h', build_hpath mh p = Some (v',h')).
proof.
move=> /build_hpathP [/#|] [p' b' v' h'] [#] + + _.
move=> ^/rconsIs <<- {b'} /rconssI <<- {p'} H.
by exists v', h'.
qed.

clone export ConcreteF as ConcreteF1.

inductive if_ind (b t e: bool) =
  | Then of b    & (b  => t)
  | Else of (!b) & (!b => e).

lemma ifP (b t e : bool): (if b then t else e) <=> if_ind b t e.
proof.
split; case: b=> _ => [t_|e_|[]//|[]//].
+ exact/Then.
exact/Else.
qed.

section AUX.

  declare module D : DISTINGUISHER {PF, RO, G1}.

  axiom D_ll (F <: DFUNCTIONALITY{D}) (P <: DPRIMITIVE{D}):
    islossless P.f => islossless P.fi => islossless F.f => 
    islossless D(F, P).distinguish.

  equiv CF_G1 : CF(D).main ~ G1(D).main: 
                 ={glob D} ==> !(G1.bcol \/ G1.bext){2} => ={res}.
  proof.
  proc.
  call (_: G1.bcol \/ G1.bext,
           INV_CF_G1 FRO.m{2} G1.chandle{2} PF.m{1} PF.mi{1}
                     G1.m{2} G1.mi{2} G1.mh{2} G1.mhi{2} F.RO.m{2} G1.paths{2}).
  (* lossless D *)
  + exact/D_ll.
  (** proofs for G1.S.f *)
  (* equivalence up to bad of PF.f and G1.S.f *)
  + proc; if{1}=> //=.
    (* x is not in m{1} so forall h, (x.1,h) is not in mh{2} *)
    + rcondt{2} 1.
      + move=> &m; auto=> &m' [#] _ <- Hinv.
        by rewrite !in_dom; apply/contra=> ^ h; case: Hinv=> _ _ ->.
      exists* F.RO.m{2}; elim*=> ro0.
      seq  2  3: (   !G1.bcol{2}
                  /\ (G1.bext <=> mem (rng FRO.m) (x.`2, Unknown)){2}
                  /\ ={x,y1,y2}
                  /\ INV_CF_G1 FRO.m{2} G1.chandle{2} PF.m{1} PF.mi{1} G1.m{2} G1.mi{2} G1.mh{2} G1.mhi{2} ro0 G1.paths{2}
                  /\ ! mem (dom PF.m{1}) x{1}
                  /\ (if   mem (dom G1.paths) x.`2
                      then let (p,v) = oget G1.paths.[x.`2] in
                           F.RO.m{2} = ro0.[rcons p (v+^x.`1) <- y.`1]
                      else F.RO.m = ro0){2}).
      + if{2}; last first.
        + by auto=> |> &1 &2; rewrite negb_or; case=> -> ->.
        inline{2} F.RO.get; rcondt{2} 4.
        + auto=> |> &m'; case: (x{m'})=> /= _x1 _x2 _ []
            [] m_some mh_some _ leq _ [] in_mh in_ro [] in_pi [] hs_inj hs0 hs_dom + + r0 _ - {r0} + x2_in_pi.
          have:= x2_in_pi; rewrite in_dom.
          case: {-1}(G1.paths.[_x2]{m'}) (eq_refl (G1.paths.[_x2]{m'}))=> //= -[] p v paths_x2.
          rewrite oget_some /=; have /in_pi [h_x2] [#] pv_hx2 hs_h_x2:= paths_x2.
          apply/contra; rewrite !in_dom.
          case: {-1}(F.RO.m.[rcons p (v +^ _x1)]{m'}) (eq_refl (F.RO.m.[rcons p (v +^ _x1)]{m'}))=> //= b.
          move=> ^ro_pv_x1 /in_ro [v' xh yh] [#].
          rewrite pv_hx2 /= => [#] <<- <<-.
          rewrite Block.xorwA Block.xorwK Block.xorwC Block.xorw0.
          by move=> /mh_some [xc yc xf yf] [#]; rewrite hs_h_x2 /= => [#] <<- <<- _ ->.
        auto=> |> &1 &2; rewrite negb_or; case=> -> -> /= Hinv x_notin_PF ^x2_in_paths.
        rewrite in_dom; case: {-1}(G1.paths.[x.`2]{2}) (eq_refl G1.paths.[x.`2]{2})=> //=.
        move=> [p v] paths_x2 y1' _ y2' _; rewrite oget_some /=.
        rewrite getP /= oget_some /= => x1 x2 [] <- <-.
        by rewrite getP /= oget_some.
      auto=> &1 &2; case: (x{2})=> [] x1 x2 /= [#] not_bcol bext_upd <*>.
      rewrite ifP=> Hinv x_notin_PF ROupd.
      split=> /= [x2K_notin_rFRO|x2K_in_rFRO].
      + split=> /= [#].
        + admit.
        admit.
      admit.
(*    swap{2} 3-2;swap{2}6-4;wp;conseq (_:y{1} =(r,y2){2}).
      + progress [-split];rewrite getP_eq oget_some H2/=.
        by move:H2;rewrite in_dom;case:(G1.paths{2}.[_]).
      transitivity{1} {y <- S.sample();} (true ==> ={y}) (true==>y{1}=(r,y2){2})=>//;1:by inline*;auto.
      transitivity{2} {(r,y2) <- S.sample2();} (true==>y{1}=(r,y2){2}) (true==> ={r,y2})=>//;2:by inline*;auto.
        by call sample_sample2;auto=> /=?[??]->.
      case (mem (rng FRO.m{2}) (x{2}.`2, Unknown)).
      + conseq (_:true);[by move=> ??[][]_[]->_->|auto].
      conseq (_: !G1.bcol{2} => 
                 oget PF.m{1}.[x{1}] = y{2} /\ 
                 INV_CF_G1 FRO.m{2} G1.chandle{2} PF.m{1} PF.mi{1} G1.m{2} G1.mi{2} G1.mh{2} G1.mhi{2} F.RO.m{2} G1.paths{2}).
      by move=> ??[][]_[]->[][]-> _ _ ->. *)
    admit.
(*  seq 0 2: ((!G1.bcol{2} /\ ={x, y} /\
              INV_CF_G1 FRO.m{2} G1.chandle{2} PF.m{1} PF.mi{1} G1.m{2} G1.mi{2}
                        G1.mh{2} G1.mhi{2} ro0 paths0 /\
              ! mem (dom PF.m{1}) x{1} /\
              if mem (dom paths0) x{2}.`2 then
                let (p0, v0) = oget paths0.[x{2}.`2] in
                F.RO.m{2} = ro0.[rcons p0 (v0 +^ x{2}.`1) <- y{2}.`1] /\
                G1.paths{2} = paths0.[y{2}.`2 <- (rcons p0 (v0 +^ x{2}.`1), y{2}.`1)]
              else F.RO.m{2} = ro0 /\ G1.paths{2} = paths0) /\
                   !mem (rng FRO.m{2}) (x{2}.`2, Unknown) /\
                   (FRO.m.[hx2]=Some(x.`2,Known)){2}).
        + auto=> &ml&mr[][]->[]_[][]-> ->[]Hinv []-> -> ^Hrng-> /=.   
          case (mem (rng FRO.m{mr}) (x{mr}.`2, Known))=> Hmem /=.
          + by split=>//;apply /huniq_hinvK=>//;move:Hinv;rewrite /INV_CF_G1/handles_spec.
          rewrite -anda_and;split=> [ | {Hinv}Hinv].
          + by apply INV_CF_G1_up_handles=>//[[]]. 
          rewrite rng_set (huniq_hinvK_h G1.chandle{mr}) ?getP//. 
          + by move:Hinv;rewrite /INV_CF_G1/handles_spec.
          by rewrite oget_some /=!inE/=;move:Hrng;apply NewLogic.contraLR=>/=;apply rng_rem_le.
        rcondf{2} 1.
        + move=> &ml;skip=> &mr[][]_[][]-> _ []Hinv[]Hndom _[]_ Hh;rewrite -not_def in_dom=> -[].
          move:Hinv=>[][][]_ /(_ (x{mr}.`1, hx2{mr}));case (G1.mh{mr}.[_])=>// bh' /(_ bh') [c c' f f'] /=. 
          by rewrite Hh/= => -[][]<- _ []_ H;case: (x{mr}) H Hndom => [x1 x2];rewrite in_dom=>->.
        auto=> &1 &2 [#] -> ->> ->> hinv x_notin_PF disj x2U_notinr_FRO FRO_hx2 /= hinv_y2.
        have:= hinvP FRO.m{2} y{2}.`2; rewrite hinv_y2 //= => y2_notinr1_FRO.
        rewrite getP /= oget_some /= /INV_CF_G1.
        rewrite (eqm_handles_up FRO.m{2} PF.m{1} G1.mh{2} G1.chandle{2} hx2{2} x{2} y{2} Known _ _ _ _) //= 1..3:[smt w=in_dom].
        rewrite (eqmi_handles_up FRO.m{2} PF.mi{1} G1.mhi{2} G1.chandle{2} hx2{2} x{2} y{2} Known _ _ _ _) //= 2..3:[smt w=in_dom].
        + rewrite negb_exists=> f /=; rewrite in_rng negb_exists=> h.
          exact/(y2_notinr1_FRO h f).
        have /eqT -> /= := incl_set G1.m{2} PF.m{1} x{2} y{2} _; 1: by smt ml=0.
        have /eqT -> /= := incl_set G1.mi{2} PF.mi{1} y{2} x{2} _; 1: by smt ml=0.
        rewrite handles_up_handles 1:[smt w=in_rng] 1:/# /=.
        split.
          rewrite /mh_spec; split.
            move=> bh [] b ch; rewrite getP; case (bh = (x.`1,hx2){2})=> [<*> /=|].
              rewrite anda_and=> [#] <*>.
              exists x{2}.`2, y{2}.`2, Known, Known=> //=.
              rewrite !getP /=; elim: (x{2}) FRO_hx2=> x1 x2 FRO_hx2; elim (y{2})=> y1 y2 /=.
              have /#: hx2{2} = G1.chandle{2} => false.
              move=> /(congr1 (fun x=> FRO.m{2}.[x])) /=; rewrite FRO_hx2.
              have:= handles_spec_notin_dom FRO.m{2} G1.chandle{2} _; 1: smt ml=0.
              by rewrite in_dom /= => ->.
            elim bh=> b' h' /=; rewrite anda_and negb_and=> bh_neq_xhx ^mh_bh.
            have @/eqm_handles [] hmmh hmhm := eqm_of_INV _ _ _ _ _ _ _ _ _ _ hinv.
            move=> /hmhm=>- [c c' f f'] /= [#] FRO_h' FRO_ch PF_b'c.
            exists c, c', f, f'=> //=.
            rewrite !getP /=; elim: (x{2}) FRO_hx2 mh_bh x2U_notinr_FRO x_notin_PF bh_neq_xhx=> x1 x2 /= FRO_hx2 mh_bh x2U_notinr_FRO x_notin_PF bh_neq_xhx.
            elim: (y{2}) y2_notinr1_FRO hinv_y2=> y1 y2 /= y2_notinr1_FRO hinv_y2.
            have -> /=: h' <> G1.chandle{2} by smt w=in_dom.
            rewrite FRO_h' /=.
            have -> /=: ch <> G1.chandle{2} by smt w=in_dom.
            rewrite FRO_ch /=; split=> /= [|/neq_Known ->> {f'}].
              case bh_neq_xhx=> [-> /#|h'_neq_hx2].
              have /#: c <> x2.
              have @/handles_spec [] huniq _ := handles_of_INV _ _ _ _ _ _ _ _ _ _ hinv.
              by move: h'_neq_hx2; apply/contra/(huniq _ _ (c,f) (x2,Known)).
            case disj.
              rewrite in_dom; case (paths0.[x{2}.`2])=> @/oget //= [[p0 v]] /= [#] <*>.
              admit. (** KEY observation: if two hstates lead to hstates that
                         share the same handle through mh, then they are equal **)
            admit. (* this one should be a lot easier *)
          admit. (* some pain here *)
        admit. (* will be painful as well *)
*)
  (* Stopped here *)
  + move=> &2 _; proc; if=> //=; wp; rnd predT; rnd predT; auto.
    smt (Block.DWord.bdistr_uf Capacity.DWord.cdistr_uf).
  (* lossless and do not reset bad G1.S.f *)
  + move=> _; proc; if; auto.
    conseq (_: _ ==> G1.bcol \/ G1.bext); 1:smt ().
    inline *; if=> //=; wp; rnd predT; wp; rnd predT; auto.
    + smt (Block.DWord.bdistr_uf Capacity.DWord.cdistr_uf).
    smt (Block.DWord.bdistr_uf Capacity.DWord.cdistr_uf).
  (** proofs for G1.S.fi *)
  (* equiv PF.P.fi G1.S.fi *)
  + admit.
  (* lossless PF.P.fi *)
  + admit.
  (* lossless and do not reset bad G1.S.fi *)
  + admit.
  (** proofs for G1.C.f *)
  (* equiv PF.C.f G1.C.f *)
  + admit.
  (* lossless PF.C.f *)
  + admit.
  (* lossless and do not reset bad G1.C.f *)
  + admit.
  (* Init ok *)
  admit.
(*inline *. auto; progress=> //=.
  + smt w=map0P.
  + smt w=map0P.
  + smt w=map0P.
  + smt w=map0P.
  + smt w=map0P.
  + smt w=(map0P in_dom).
  + smt w=map0P.
  + rewrite /paths_spec=> c p v. rewrite !getP; case (c = c0)=> //=.
      rewrite anda_and=> c_c0; split=> [[] <<- <<-|].
      + by exists 0; rewrite /build_hpath /= getP /= c_c0.
      move=> [h] @/build_hpath [] h0; rewrite getP; case (h = 0).
      + by move=> /= ->> ->>; move: h0; smt.
      smt w=map0P.
    move=> c_c0; rewrite map0P /= negb_exists /= => h.
    rewrite negb_and getP; case (h = 0)=> //=; [|by rewrite map0P].
    by move=> _; right; rewrite eq_sym.
  + smt w=(map0P getP).
  + by rewrite getP.
  + move: H; rewrite in_dom getP; case (h = 0)=> //=.
    by rewrite map0P.
  + by move: H1=> /H0 [#].*)
qed.

end section AUX.

section.

  declare module D: DISTINGUISHER{Perm, C, PF, G1, RO}.
  
  axiom D_ll (F <: DFUNCTIONALITY{D}) (P <: DPRIMITIVE{D}):
    islossless P.f => islossless P.fi =>
    islossless F.f => islossless D(F, P).distinguish.

  lemma Real_G1 &m: 
    Pr[GReal(D).main() @ &m: res /\ C.c <= max_size] <=
    Pr[G1(DRestr(D)).main() @ &m: res] +  (max_size ^ 2)%r * mu dstate (pred1 witness) + 
    Pr[G1(DRestr(D)).main() @&m: G1.bcol] + Pr[G1(DRestr(D)).main() @&m: G1.bext].
  proof. 
    apply (@RealOrder.ler_trans _ _ _ (Real_Concrete D D_ll &m)).
    cut : Pr[CF(DRestr(D)).main() @ &m : res] <= 
          Pr[G1(DRestr(D)).main() @ &m : res] + 
          Pr[G1(DRestr(D)).main() @ &m : G1.bcol \/ G1.bext].
    + byequiv (CF_G1 (DRestr(D)) _)=>//;1:by apply (DRestr_ll D D_ll).
      smt ml=0.
    cut /# : Pr[G1(DRestr(D)).main() @ &m : G1.bcol \/ G1.bext] <= 
             Pr[G1(DRestr(D)).main() @ &m : G1.bcol] + 
             Pr[G1(DRestr(D)).main() @ &m : G1.bext].
    rewrite Pr [mu_or]; smt.
  qed.

end section.


