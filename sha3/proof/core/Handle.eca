pragma -oldip. pragma +implicits.
require import Pred Fun Option Pair Int Real StdOrder Ring NewLogic.
require import List FSet NewFMap Utils Common SLCommon RndO.
require import DProd Dexcepted.
(*...*) import Capacity IntOrder.

require ConcreteF.

clone import GenEager as ROhandle with
  type from   <- handle,
  type to     <- capacity,
  op sampleto <- fun (_:int) => cdistr
  proof sampleto_ll by apply DWord.cdistr_ll.

module G1(D:DISTINGUISHER) = {
  var m, mi               : smap
  var mh, mhi             : hsmap
  var chandle             : int
  var paths               : (capacity, block list * block) fmap
  var bext, bcol          : bool

  module C = {

    proc f(p : block list): block = {
      var sa, sa', sc;
      var h, i <- 0; 
      sa <- b0;
      while (i < size p ) {
        if (mem (dom mh) (sa +^ nth witness p i, h)) {
          (sa, h) <- oget mh.[(sa +^ nth witness p i, h)];
        } else {
          sc                  <$ cdistr;
          bcol                <- bcol \/ hinv FRO.m sc <> None;
          sa'                 <@ F.RO.get(take (i+1) p);
          sa                  <- sa +^ nth witness p i;
          mh.[(sa,h)]         <- (sa', chandle);
          mhi.[(sa',chandle)] <- (sa, h);
          (sa,h)              <- (sa',chandle);
          FRO.m.[chandle]     <- (sc,Unknown);
          chandle             <- chandle + 1;
        }
        i        <- i + 1;
      }
      sa <- F.RO.get(p);
      return sa;
    }
  }

  module S = {

    proc f(x : state): state = {
      var p, v, y, y1, y2, hy2, hx2;

      if (!mem (dom m) x) {
        if (mem (dom paths) x.`2) {
          (p,v) <- oget paths.[x.`2]; 
          y1    <- F.RO.get (rcons p (v +^ x.`1));
          y2    <$ cdistr;
        } else {
          y1    <$ bdistr;
          y2    <$ cdistr;
        }
        y     <- (y1, y2);
        bext <- bext \/ mem (rng FRO.m) (x.`2, Unknown);   
        if (!(mem (rng FRO.m) (x.`2, Known))) {
          FRO.m.[chandle] <- (x.`2, Known);
          chandle <- chandle + 1;
        }
        hx2 <- oget (hinvK FRO.m x.`2);
        if (mem (dom mh) (x.`1, hx2) /\ in_dom_with FRO.m (oget mh.[(x.`1,hx2)]).`2 Unknown) {
          hy2               <- (oget mh.[(x.`1, hx2)]).`2;
          y                 <- (y.`1, (oget FRO.m.[hy2]).`1);
          FRO.m.[hy2]       <- (y.`2, Known);
          m.[x]             <- y;
          mi.[y]            <- x;
        } else {
          bcol              <- bcol \/ hinv FRO.m y.`2 <> None;
          hy2               <- chandle;
          chandle           <- chandle + 1;
          FRO.m.[hy2]       <- (y.`2, Known);
          m.[x]             <- y;
          mh.[(x.`1, hx2)]  <- (y.`1, hy2);
          mi.[y]            <- x;
          mhi.[(y.`1, hy2)] <- (x.`1, hx2);
        }
        if (mem (dom paths) x.`2) {
          (p,v) <- oget paths.[x.`2]; 
          paths.[y.`2] <- (rcons p (v +^ x.`1), y.`1);
        }
      } else {   
        y <- oget m.[x];
      }
      return y;
    }

    proc fi(x : state): state = {
      var y, y1, y2, hx2, hy2;

      if (!mem (dom mi) x) {
        bext <- bext \/ mem (rng FRO.m) (x.`2, Unknown);   
        if (!(mem (rng FRO.m) (x.`2, Known))) {
          FRO.m.[chandle] <- (x.`2, Known);
          chandle <- chandle + 1;
        }
        hx2 <- oget (hinvK FRO.m x.`2);
        y1  <$ bdistr;
        y2  <$ cdistr;
        y   <- (y1,y2);
        if (mem (dom mhi) (x.`1,hx2) /\
            in_dom_with FRO.m (oget mhi.[(x.`1,hx2)]).`2 Unknown) {
          (y1,hy2)          <- oget mhi.[(x.`1, hx2)];
          y                 <- (y.`1, (oget FRO.m.[hy2]).`1);
          FRO.m.[hy2]       <- (y.`2, Known);
          mi.[x]            <- y;
          m.[y]             <- x;
        } else {
          bcol              <- bcol \/ hinv FRO.m y.`2 <> None;          
          hy2               <- chandle;
          chandle           <- chandle + 1;
          FRO.m.[hy2]       <- (y.`2, Known);
          mi.[x]            <- y;
          mhi.[(x.`1, hx2)] <- (y.`1, hy2);
          m.[y]             <- x;
          mh.[(y.`1, hy2)]  <- (x.`1, hx2);
        }
      } else {
        y <- oget mi.[x];
      }
      return y;
    }

  }

  proc main(): bool = {
    var b;

    F.RO.m   <- map0;
    m        <- map0;
    mi       <- map0;
    mh       <- map0;
    mhi      <- map0;
    bext     <- false;
    bcol     <- false;

    (* the empty path is initially known by the adversary to lead to capacity 0^c *)
    FRO.m    <- map0.[0 <- (c0, Known)];
    paths    <- map0.[c0 <- ([<:block>],b0)];
    chandle  <- 1;
    b        <@ D(C,S).distinguish();
    return b;
  }
}.

(* -------------------------------------------------------------------------- *)
(** The state of CF contains only the map PF.m.
    The state of G1 contains:
    - the map hs that associates handles to flagged capacities;
    - the map G1.m that represents the *public* view of map PF.m;
    - the map G1.mh that represents PF.m with handle-based indirection;
    - the map ro that represents the functionality;
    - the map pi that returns *the* known path to a capacity if it exists.
    The following invariants encode these facts, and some auxiliary
    knowledge that can most likely be deduced but is useful in the proof.    **)

(** RELATIONAL: Map, Handle-Map and Handles are compatible **)
inductive m_mh (hs : handles) (m : smap) (mh : hsmap) =
  | INV_m_mh of (forall xa xc ya yc,
                   m.[(xa,xc)] = Some (ya,yc) =>
                   exists hx fx hy fy,
                        hs.[hx]      = Some (xc,fx)
                     /\ hs.[hy]      = Some (yc,fy)
                     /\ mh.[(xa,hx)] = Some (ya,hy))
              & (forall xa hx ya hy,
                   mh.[(xa,hx)] = Some (ya,hy) =>
                   exists xc fx yc fy,
                        hs.[hx]     = Some (xc,fx)
                     /\ hs.[hy]     = Some (yc,fy)
                     /\ m.[(xa,xc)] = Some (ya,yc)).

(* WELL-FORMEDNESS<2>: Handles, Map, Handle-Map and RO are compatible *)
inductive mh_spec (hs : handles) (Gm : smap) (mh : hsmap) (ro : (block list,block) fmap) =
  | INV_mh of (forall xa hx ya hy,
                 mh.[(xa,hx)] = Some (ya,hy) =>
                 exists xc fx yc fy,
                      hs.[hx] = Some (xc,fx)
                   /\ hs.[hy] = Some (yc,fy)
                   /\ if   fy = Known
                      then    Gm.[(xa,xc)] = Some (ya,yc)
                           /\ fx = Known
                      else exists p v,
                           ro.[rcons p (v +^ xa)] = Some ya
                        /\ build_hpath mh p = Some (v,hx))
            & (forall p bn b,
                 ro.[rcons p bn] = Some b <=>
                 exists v hx hy,
                      build_hpath mh p = Some (v,hx)
                   /\ mh.[(v +^ bn,hx)] = Some (b,hy))
            & (forall p v p' v' hx,
                    build_hpath mh p  = Some (v,hx)
                 => build_hpath mh p' = Some (v',hx)
                 => p = p' /\ v = v').

(* WELL-FORMEDNESS<2>: Handles, Handle-Map and Paths are compatible *)
inductive pi_spec (hs : handles) (mh : hsmap) (pi : (capacity,block list * block) fmap) =
  | INV_pi of (forall c p v,
                 pi.[c] = Some (p,v) <=>
                 exists h,
                      build_hpath mh p = Some(v,h)
                   /\ hs.[h] = Some (c,Known)).

(* WELL-FORMEDNESS<2>: Handles are well-formed *)
inductive hs_spec hs ch =
  | INV_hs of (huniq hs)
            & (hs.[0] = Some (c0,Known))
            & (forall cf h, hs.[h] = Some cf => h < ch).

(* Useless stuff *)
inductive inv_spec (m:('a,'b) fmap) mi =
  | INV_inv of (forall x y, m.[x] = Some y <=> mi.[y] = Some x).

(* Invariant: maybe we should split relational and non-relational parts? *)
inductive INV_CF_G1 (hs : handles) ch (Pm Pmi Gm Gmi : smap)
                    (mh mhi : hsmap) (ro : (block list,block) fmap) pi =
  | HCF_G1 of (hs_spec hs ch)
            & (inv_spec mh mhi)
            & (m_mh hs Pm mh)
            & (m_mh hs Pmi mhi)
            & (incl Gm Pm)
            & (incl Gmi Pmi)
            & (mh_spec hs Gm mh ro)
            & (pi_spec hs mh pi).

(** Structural Projections **)
lemma m_mh_of_INV (ch : handle)
                  (mi1 m2 mi2 : smap) (mhi2 : hsmap)
                  (ro : (block list, block) fmap)
                  (pi : (capacity, block list * block) fmap)
                  hs m1 mh2:
  INV_CF_G1 hs ch m1 mi1 m2 mi2 mh2 mhi2 ro pi =>
  m_mh hs m1 mh2.
proof. by case. qed.

lemma mi_mhi_of_INV (ch : handle)
                    (m1 m2 mi2 : smap) (mh2 : hsmap)
                    (ro : (block list, block) fmap)
                    (pi : (capacity, block list * block) fmap)
                    hs mi1 mhi2:
  INV_CF_G1 hs ch m1 mi1 m2 mi2 mh2 mhi2 ro pi =>
  m_mh hs mi1 mhi2.
proof. by case. qed.

lemma incl_of_INV (hs : handles) (ch : handle)
                  (mi1 mi2 : smap) (mh2 mhi2: hsmap)
                  (ro : (block list, block) fmap)
                  (pi : (capacity, block list * block) fmap)
                  m1 m2:
  INV_CF_G1 hs ch m1 mi1 m2 mi2 mh2 mhi2 ro pi =>
  incl m2 m1.
proof. by case. qed.

lemma incli_of_INV (hs : handles) (ch : handle)
                   (m1 m2 : smap) (mh2 mhi2: hsmap)
                   (ro : (block list, block) fmap)
                   (pi : (capacity, block list * block) fmap)
                   mi1 mi2:
  INV_CF_G1 hs ch m1 mi1 m2 mi2 mh2 mhi2 ro pi =>
  incl mi2 mi1.
proof. by case. qed.

lemma mh_of_INV (ch : handle)
                (m1 mi1 mi2 : smap) (mhi2 : hsmap)
                (pi : (capacity, block list * block) fmap)
                hs m2 mh2 ro:
  INV_CF_G1 hs ch m1 mi1 m2 mi2 mh2 mhi2 ro pi =>
  mh_spec hs m2 mh2 ro.
proof. by case. qed.

lemma pi_of_INV (ch : handle)
                (m1 m2 mi1 mi2: smap) (mhi2: hsmap)
                (ro : (block list, block) fmap)
                hs mh2 pi:
  INV_CF_G1 hs ch m1 mi1 m2 mi2 mh2 mhi2 ro pi =>
  pi_spec hs mh2 pi.
proof. by case. qed.

lemma hs_of_INV (m1 m2 mi1 mi2 : smap) (mh2 mhi2 : hsmap)
                (ro : (block list, block) fmap)
                (pi : (capacity, block list * block) fmap)
                hs ch:
  INV_CF_G1 hs ch m1 mi1 m2 mi2 mh2 mhi2 ro pi =>
  hs_spec hs ch.
proof. by case. qed.

lemma inv_of_INV hs ch m1 mi1 m2 mi2 ro pi
                      mh2 mhi2:
  INV_CF_G1 hs ch m1 mi1 m2 mi2 mh2 mhi2 ro pi =>
  inv_spec mh2 mhi2.
proof. by case. qed.

(** Useful Lemmas **)
lemma ch_gt0 hs ch : hs_spec hs ch => 0 < ch.
proof. by case=> _ + Hlt -/Hlt. qed.

lemma ch_neq0 hs ch : hs_spec hs ch => 0 <> ch.
proof. by move=> /ch_gt0/ltr_eqF. qed.

lemma ch_notin_dom_hs hs ch: hs_spec hs ch => hs.[ch] = None.
proof.
by move=> [] _ _ dom_hs; case: {-1}(hs.[ch]) (eq_refl hs.[ch])=> [//|cf/dom_hs].
qed.

lemma Sch_notin_dom_hs hs ch: hs_spec hs ch => hs.[ch + 1] = None.
proof.
by move=> [] _ _ dom_hs; case: {-1}(hs.[ch + 1]) (eq_refl hs.[ch + 1])=> [//|cg/dom_hs/#].
qed.

lemma ch_notin_dom2_mh hs m mh xa ch:
     m_mh hs m mh
  => hs_spec hs ch
  => mh.[(xa,ch)] = None.
proof.
move=> [] Hm_mh Hmh_m [] _ _ dom_hs.
case: {-1}(mh.[(xa,ch)]) (eq_refl mh.[(xa,ch)])=> [//=|[ya hy] /Hmh_m].
by move=> [xc0 fx0 yc fy] [#] /dom_hs.
qed.

lemma Sch_notin_dom2_mh hs m mh xa ch:
     m_mh hs m mh
  => hs_spec hs ch
  => mh.[(xa,ch + 1)] = None.
proof.
move=> [] Hm_mh Hmh_m [] _ _ dom_hs.
case: {-1}(mh.[(xa,ch + 1)]) (eq_refl mh.[(xa,ch + 1)])=> [//=|[ya hy] /Hmh_m].
by move=> [xc0 fx0 yc fy] [#] /dom_hs /#.
qed.

lemma dom_hs_neq_ch hs ch hx xc fx:
     hs_spec hs ch
  => hs.[hx] = Some (xc,fx)
  => hx <> ch.
proof. by move=> [] _ _ dom_hs /dom_hs /#. qed.

lemma dom_hs_neq_Sch hs ch hx xc fx:
     hs_spec hs ch
  => hs.[hx] = Some(xc,fx)
  => hx <> ch + 1.
proof. by move=> [] _ _ dom_hs /dom_hs /#. qed.

lemma notin_m_notin_mh hs m mh xa xc hx fx:
     m_mh hs m mh
  => m.[(xa,xc)] = None
  => hs.[hx] = Some (xc,fx)
  => mh.[(xa,hx)] = None.
proof.
move=> [] _ Hmh_m m_xaxc hs_hx; case: {-1}(mh.[(xa,hx)]) (eq_refl mh.[(xa,hx)])=> [//|].
by move=> [ya hy] /Hmh_m [xc0 fx0 yc0 fy0] [#]; rewrite hs_hx=> [#] <*>; rewrite m_xaxc.
qed.

lemma notin_m_notin_Gm (m Gm : ('a,'b) fmap) x:
     incl Gm m
  => m.[x] = None
  => Gm.[x] = None.
proof. by move=> Gm_leq_m; apply/contraLR=> ^ /Gm_leq_m ->. qed.

lemma notin_hs_notin_dom2_mh hs m mh xa hx:
     m_mh hs m mh
  => hs.[hx] = None
  => mh.[(xa,hx)] = None.
proof.
move=> [] _ Hmh_m hs_hx; case: {-1}(mh.[(xa,hx)]) (eq_refl mh.[(xa,hx)])=> [//|].
by move=> [ya hy] /Hmh_m [xc fx yc fy] [#]; rewrite hs_hx.
qed.

(** Preservation of m_mh **)
lemma m_mh_addh hs ch m mh xc fx:
     hs_spec hs ch
  => m_mh hs m mh
  => m_mh hs.[ch <- (xc, fx)] m mh.
proof.
move=> ^Hhs [] Hhuniq hs_0 dom_hs [] Hm_mh Hmh_m; split.
+ move=> xa0 xc0 ya yc /Hm_mh [hx0 fx0 hy fy] [#] hs_hx0 hs_hy mh_xaxc0.
  exists hx0 fx0 hy fy; rewrite !getP mh_xaxc0 hs_hx0 hs_hy /=.
  move: hs_hx0=> /dom_hs/ltr_eqF -> /=.
  by move: hs_hy=> /dom_hs/ltr_eqF -> /=.
move=> xa hx ya hy /Hmh_m [xc0 fx0 yc fy] [#] hs_hx hs_hy m_xaxc0.
exists xc0 fx0 yc fy; rewrite !getP m_xaxc0 hs_hx hs_hy.
move: hs_hx=> /dom_hs/ltr_eqF -> /=.
by move: hs_hy=> /dom_hs/ltr_eqF -> /=.
qed.

lemma m_mh_updh fy0 hs m mh yc hy fy:
     m_mh hs m mh
  => hs.[hy] = Some (yc,fy0)
  => m_mh hs.[hy <- (yc,fy)] m mh.
proof.
move=> Im_mh hs_hy; split.
+ move=> xa' xc' ya' yc'; have [] H _ /H {H}:= Im_mh.
  move=> [hx' fx' hy' fy'] [#] hs_hx' hs_hy' mh_xahx'.
  case: (hx' = hy); case: (hy' = hy)=> //= <*> => [|Hhy'|Hhx'|Hhx' Hhy'].
  + by exists hy fy hy fy; rewrite !getP /= /#.
  + by exists hy fy hy' fy'; rewrite !getP Hhy' /#.
  + by exists hx' fx' hy fy; rewrite !getP Hhx' /#.
  by exists hx' fx' hy' fy'; rewrite !getP Hhx' Hhy'.
move=> xa' hx' ya' hy'; have [] _ H /H {H}:= Im_mh.
move=> [xc' fx' yc' fy'] [#] hs_hx' hs_hy' m_xaxc'.
case: (hx' = hy); case: (hy' = hy)=> //= <*> => [|Hhy'|Hhx'|Hhx' Hhy'].
+ by exists yc fy yc fy; rewrite !getP /= /#.
+ by exists yc fy yc' fy'; rewrite !getP Hhy' /#.
+ by exists xc' fx' yc fy; rewrite !getP Hhx' /#.
by exists xc' fx' yc' fy'; rewrite !getP Hhx' Hhy'.
qed.

lemma m_mh_addh_addm hs Pm mh hx xa xc hy ya yc f:
  m_mh hs Pm mh =>
  huniq hs =>
  hs.[hx] = Some (xc, f) =>
  hs.[hy] = None =>
  m_mh hs.[hy <- (yc,Known)] Pm.[(xa,xc) <- (ya,yc)] mh.[(xa,hx) <- (ya,hy)].
proof.
move=> [] Hm_mh Hmh_m Hhuniq hs_hx hs_hy.
split=> [xa0 xc0 ya0 yc0|xa0 hx0 ya0 hy0]; rewrite getP.
+ case: ((xa0,xc0) = (xa,xc))=> [[#] <<*> [#] <<*>|] /=.
  + by exists hx f hy Known; rewrite !getP /= /#.
  move=> xaxc0_neq_xaxc /Hm_mh [hx0 fx0 hy0 fy0] [#] hs_hx0 hs_hy0 mh_xahx0.
  by exists hx0 fx0 hy0 fy0; rewrite !getP /#.
case: ((xa0,hx0) = (xa,hx))=> [[#] <*>> [#] <<*>|] /=.
+ by exists xc f yc Known; rewrite !getP /= /#.
rewrite anda_and=> /negb_and xahx0_neq_xahx /Hmh_m [xc0 fx0 yc0 fy0] [#] hs_hx0 hs_hy0 Pm_xaxc0.
exists xc0 fx0 yc0 fy0; rewrite !getP; do !split=> [/#|/#|/=].
move: xahx0_neq_xahx; case: (xa0 = xa)=> [/= <*>>|//=]; case: (xc0 = xc)=> [<*>>|//=].
by move: hs_hx=> /(Hhuniq _ _ _ _ hs_hx0).
qed.

lemma mi_mhi_addh_addmi (hs : handles) mi mhi hx xa xc hy ya yc fx:
  m_mh hs mi mhi =>
  (forall f h, hs.[h] <> Some (yc,f)) =>
  hs.[hx] = Some (xc,fx) =>
  hs.[hy]  = None =>
  m_mh hs.[hy <- (yc,Known)] mi.[(ya,yc) <- (xa,xc)] mhi.[(ya,hy) <- (xa,hx)].
proof.
move=> [] Hm_mh Hmh_m yc_notin_rng1_hs hs_hx hs_hy; split.
+ move=> ya0 yc0 xa0 xc0; rewrite getP; case: ((ya0,yc0) = (ya,yc))=> [[#] <*>> [#] <*>>|].
  + by exists hy Known hx fx; rewrite !getP /= /#.
  move=> yayc0_neq_yayc /Hm_mh [hy0 fy0 hx0 fx0] [#] hs_hy0 hs_hx0 mhi_yayc0.
  by exists hy0 fy0 hx0 fx0; rewrite !getP /#.
move=> ya0 hy0 xa0 hx0; rewrite getP; case: ((ya0,hy0) = (ya,hy))=> [[#] <*>> [#] <<*>|].
+ by exists yc Known xc fx; rewrite !getP //= /#.
rewrite /= anda_and=> /negb_and yahy0_neq_yahy /Hmh_m [yc0 fy0 xc0 fx0] [#] hs_hy0 hs_hx0 mi_yayc0.
exists yc0 fy0 xc0 fx0; rewrite !getP; do !split=> [/#|/#|].
move: yahy0_neq_yahy; case: (ya0 = ya)=> [<<*> //=|/#]; case: (yc0 = yc)=> [<*>> /=|//=].
by move: hs_hy0; rewrite yc_notin_rng1_hs.
qed.

(** Preservation of hs_spec **)
lemma hs_addh hs ch xc fx:
     hs_spec hs ch
  => (forall f h, hs.[h] <> Some (xc,f))
  => hs_spec hs.[ch <- (xc,fx)] (ch + 1).
proof.
move=> ^Hhs [] Hhuniq hs_0 dom_hs xc_notin_rng1_hs; split.
+ move=> h1 h2 [c1 f1] [c2 f2]; rewrite !getP /=.  
  case: (h1 = ch); case: (h2 = ch)=> //= [+ + [#]|+ + + [#]|]=> <*>;
    first 2 by rewrite xc_notin_rng1_hs.
  by move=> _ _ hs_h1 /(Hhuniq _ _ _ _ hs_h1).
+ by rewrite getP (ch_neq0 _ Hhs).
+ move=> [c f] h; rewrite !getP; case: (h = ch)=> [<*> /#|_].
by   move=> /dom_hs /#.
qed.

lemma hs_updh hs ch fx hx xc fx':
     hs_spec hs ch
  => 0 <> hx
  => hs.[hx] = Some (xc,fx)
  => hs_spec hs.[hx <- (xc,fx')] ch.
proof.
move=> ^Hhs [] Hhuniq hs_0 dom_hs hx_neq0 hs_hx; split.
+ by move=> h1 h2 [c1 f1] [c2 f2]; rewrite !getP /= /#.
+ by rewrite getP hx_neq0.
move=> cf h; rewrite getP; case: (h = hx)=> [<*> _|_ /dom_hs //].
by move: hs_hx=> /dom_hs.
qed.

(** Preservation of mh_spec **)
lemma mh_addh hs ch Gm mh ro xc fx:
     hs_spec hs ch
  => mh_spec hs Gm mh ro
  => mh_spec hs.[ch <- (xc,fx)] Gm mh ro.
proof.
move=> [] _ _ dom_hs [] Hmh ? ?; split=> //.
move=> xa hx ya hy /Hmh [xc0 fx0 yc0 fy0] [#] hs_hx hs_hy Hite.
exists xc0 fx0 yc0 fy0; rewrite !getP Hite hs_hx hs_hy /=.
rewrite ltr_eqF /=; 1:by apply/(dom_hs _ hs_hx).
by rewrite ltr_eqF /=; 1:by apply/(dom_hs _ hs_hy).
qed.

(** Preservation of inv_spec **)
lemma inv_addm (m : ('a,'b) fmap) mi x y:
     inv_spec m mi
  => m.[x]  = None
  => mi.[y] = None
  => inv_spec m.[x <- y] mi.[y <- x].
proof.
move=> [] Hinv m_x mi_y; split=> x' y'; rewrite !getP; split.
+ case: (x' = x)=> /= [[#] <*> //=|_ /Hinv ^ + ->].
  by move: mi_y; case: (y' = y)=> [[#] <*> ->|].
case: (y' = y)=> /= [[#] <*> //=|_ /Hinv ^ + ->].
by move: m_x; case: (x' = x)=> [[#] <*> ->|].
qed.

(** Preservation of incl **)
lemma incl_addm (m m' : ('a,'b) fmap) x y:
     incl m m'
  => incl m.[x <- y] m'.[x <- y].
proof. by move=> m_leq_m' x'; rewrite !getP; case: (x' = x)=> [|_ /m_leq_m']. qed.

(** getflag: retrieve the flag of a capacity **)
op getflag (hs : handles) xc =
  omap snd (obind ("_.[_]" hs) (hinv hs xc)).

lemma getflagP_none hs xc:
  (getflag hs xc = None <=> forall f h, hs.[h] <> Some (xc,f)).
proof. by rewrite /getflag; case: (hinvP hs xc)=> [->|] //= /#. qed.

lemma getflagP_some hs xc f:
     huniq hs
  => (getflag hs xc = Some f <=> mem (rng hs) (xc,f)).
proof.
move=> huniq_hs; split.
+ rewrite /getflag; case: (hinvP hs xc)=> [-> //|].
  rewrite in_rng; case: (hinv hs xc)=> //= h [f'].
  rewrite oget_some=> ^ hs_h -> @/snd /= ->>.
  by exists h.
rewrite in_rng=> -[h] hs_h.
move: (hinvP hs xc)=> [_ /(_ h f) //|].
rewrite /getflag; case: (hinv hs xc)=> // h' _ [f']; rewrite oget_some.
move=> /(huniq_hs _ h _ (xc,f)) /(_ hs_h) /= ->>.
by rewrite hs_h.
qed.

(** Stuff about paths **)
lemma build_hpath_prefix mh p b v h:
      build_hpath mh (rcons p b) = Some (v,h)
  <=> (exists v' h', build_hpath mh p = Some (v',h') /\ mh.[(v' +^ b,h')] = Some (v,h)).
proof.
rewrite build_hpathP; split=> [[/#|p' b' v' h' [#] + Hhpath Hmh]|[v' h'] [] Hhpath Hmh].
+ by move=> ^/rconsIs <<- {b'} /rconssI <<- {p'}; exists v' h'.
exact/(Extend _ _ _ _ _ Hhpath Hmh).
qed.

lemma build_hpath_up mh xa hx ya hy p za hz:
     build_hpath mh p = Some (za,hz)
  => mh.[(xa,hx)] = None
  => build_hpath mh.[(xa,hx) <- (ya,hy)] p = Some (za,hz).
proof.
move=> + mh_xahx; elim/last_ind: p za hz=> [za hz|p b ih za hz].
+ by rewrite /build_hpath.
move=> /build_hpath_prefix [b' h'] [#] /ih Hpath Hmh.
apply/build_hpathP/(@Extend _ _ _ _ p b b' h' _ Hpath _)=> //.
by rewrite getP /#.
qed.

lemma build_hpath_down mh xa hx ya hy p v h:
     (forall p v, build_hpath mh p <> Some (v,hx))
  => build_hpath mh.[(xa,hx) <- (ya,hy)] p = Some (v,h)
  => build_hpath mh p = Some (v,h).
proof.
move=> no_path_to_hx.
elim/last_ind: p v h=> [v h /build_hpathP [<*>|/#] //=|p b ih].
move=> v h /build_hpathP [/#|p' b' + + ^/rconsIs <<- /rconssI <<-].
move=> v' h' /ih; rewrite getP.
case: ((v' +^ b,h') = (xa,hx))=> [/#|_ Hpath Hextend].
exact/build_hpathP/(Extend _ _ _ _ _ Hpath Hextend).
qed.

lemma known_path_uniq hs mh pi xc hx p xa p' xa':
     pi_spec hs mh pi
  => hs.[hx] = Some (xc,Known)
  => build_hpath mh p  = Some (xa, hx)
  => build_hpath mh p' = Some (xa',hx)
  => p = p' /\ xa = xa'.
proof.
move=> [] Ipi hs_hy path_p path_p'.
have /iffRL /(_ _):= Ipi xc p xa; first by exists hx.
have /iffRL /(_ _):= Ipi xc p' xa'; first by exists hx.
by move=> ->.
qed.

(* Useful? Not sure... *)
lemma path_split hs ch m mh xc hx p xa:
     hs_spec hs ch
  => m_mh hs m mh
  => hs.[hx] = Some (xc,Unknown)
  => build_hpath mh p = Some (xa,hx)
  => exists pk ya yc hy b za zc hz pu,
          p = (rcons pk b) ++ pu
       /\ build_hpath mh pk = Some (ya,hy)
       /\ hs.[hy] = Some (yc,Known)
       /\ mh.[(ya +^ b,hy)] = Some (za,hz)
       /\ hs.[hz] = Some (zc,Unknown). 
proof.
move=> Ihs [] _ Imh_m.
elim/last_ind: p hx xa xc=> [hx xa xc + /build_hpathP [_ <*>|/#]|].
+ by have [] _ -> _ [#]:= Ihs.
move=> p b ih hx xa xc hs_hx /build_hpath_prefix.
move=> [ya hy] [#] path_p_hy ^mh_yabh' /Imh_m [yc fy ? ?] [#] hs_hy.
rewrite hs_hx=> /= [#] <<*> _; case: fy hs_hy.
+ move=> /ih /(_ ya _) // [pk ya' yc' hy' b' za zc hz pu] [#] <*>.
  move=> Hpath hs_hy' mh_tahy' hs_hz.
  by exists pk ya' yc' hy' b' za zc hz (rcons pu b); rewrite rcons_cat.
by move=> hs_hy; exists p ya yc hy b xa xc hx []; rewrite cats0.
qed.

(** Path-specific lemmas **)
lemma lemma1 hs ch Pm Pmi Gm Gmi mh mhi ro pi x1 x2 y1 y2:
     INV_CF_G1 hs ch Pm Pmi Gm Gmi mh mhi ro pi
  => x2 <> y2
  => Pm.[(x1,x2)] = None
  => Gm.[(x1,x2)] = None
  => pi.[x2] = None
  => (forall f h, hs.[h] <> Some (x2,f))
  => (forall f h, hs.[h] <> Some (y2,f))
  => INV_CF_G1
       hs.[ch <- (x2,Known)].[ch + 1 <- (y2,Known)] (ch + 2)
       Pm.[(x1,x2) <- (y1,y2)] Pmi.[(y1,y2) <- (x1,x2)]
       Gm.[(x1,x2) <- (y1,y2)] Gmi.[(y1,y2) <- (x1,x2)]
       mh.[(x1,ch) <- (y1,ch + 1)] mhi.[(y1,ch + 1) <- (x1,ch)]
       ro pi.
proof.
move=> HINV x2_neq_y2 Pm_x Gm_x pi_x2 x2_notin_rng1_hs y2_notin_rng1_hs; split.
+ rewrite (@addzA ch 1 1); apply/hs_addh.
  + by move: HINV=> /hs_of_INV/hs_addh=> ->.
  by move=> f h; rewrite getP; case: (h = ch)=> [/#|_]; exact/y2_notin_rng1_hs.
+ apply/inv_addm; 1:by case: HINV.
  + have ^ /m_mh_of_INV Hm_mh /hs_of_INV Hhs := HINV.
    by apply/(ch_notin_dom2_mh _ _ Hm_mh Hhs).
  have ^ /mi_mhi_of_INV Hmi_mhi /hs_of_INV Hhs := HINV.
  by apply/(Sch_notin_dom2_mh _ _ Hmi_mhi Hhs).
+ apply/(@m_mh_addh_addm hs.[ch <- (x2,Known)] Pm mh ch x1 x2 (ch + 1) y1 y2 Known).
  + by move: HINV=> ^/hs_of_INV Hhs /m_mh_of_INV; exact/(m_mh_addh Hhs).
  + by move: HINV => /hs_of_INV /hs_addh /(_ x2 Known _) // [].
  + by rewrite getP.
  by rewrite getP gtr_eqF 1:/# /=; apply/Sch_notin_dom_hs; case: HINV.
+ apply/(@mi_mhi_addh_addmi hs.[ch <- (x2,Known)] Pmi mhi ch x1 x2 (ch + 1) y1 y2 Known).
  + by move: HINV=> ^/hs_of_INV Hhs /mi_mhi_of_INV; exact/(m_mh_addh Hhs).
  + move=> f h; rewrite getP; case: (h = ch)=> [_ //=|_ //=]; first by rewrite x2_neq_y2.
    by rewrite y2_notin_rng1_hs.
  + by rewrite getP.
  by rewrite getP gtr_eqF 1:/# /=; apply/Sch_notin_dom_hs; case: HINV.
+ by apply/incl_addm; case: HINV.
+ by apply/incl_addm; case: HINV.
+ split.
  + move=> xa hx ya hy; rewrite getP; case: ((xa,hx) = (x1,ch))=> [|].
    + by move=> [#] <*> [#] <*>; exists x2 Known y2 Known; rewrite !getP /#.
    move=> xahx_neq_x1ch; have ^ /hs_of_INV Hhs /mh_of_INV [] Hmh _ _ /Hmh {Hmh} := HINV.
    move=> [xc fx yc fy] [#] hs_hx hs_hy Hite.
    exists xc fx yc fy; do 2?split; first 2 by smt (dom_hs_neq_ch dom_hs_neq_Sch getP).
    case: fy Hite hs_hy=> /= [[p v] [Hro Hpath] hs_hy|[#] Gm_xaxc <*> hs_hy] /=; last first.
    + by rewrite getP; case: ((xa,xc) = (x1,x2))=> [/#|].
    exists p v; rewrite Hro /=; apply/build_hpath_up=> //.
    have /m_mh_of_INV /notin_hs_notin_dom2_mh H:= HINV.
    exact/H/ch_notin_dom_hs/Hhs.
  + move=> p xa b; have /mh_of_INV [] _ -> _ := HINV.
    apply/exists_iff=> v /=; apply/exists_iff=> hx /=; apply/exists_iff=> hy /=.
    have mh_x1ch: mh.[(x1,ch)] = None.
    + by apply/(notin_hs_notin_dom2_mh hs Pm)/ch_notin_dom_hs; case: HINV.
    have ch_notin_rng2_mh: forall a h a', mh.[(a,h)] <> Some (a',ch).
    + move=> a h a'; rewrite -negP; have /m_mh_of_INV [] _ Hmh_m /Hmh_m {Hmh_m} := HINV.
      by move=> [xc fx yc fy] [#] _; rewrite ch_notin_dom_hs; case: HINV.
    split=> -[#].
    + move=> Hpath mh_vxahx; rewrite getP; case: ((v +^ xa,hx) = (x1,ch))=> [/#|_].
      by rewrite mh_vxahx //=; apply/build_hpath_up=> //=; rewrite mh_x1ch.
    have H /H {H}:= build_hpath_down mh x1 ch y1 (ch + 1) p v hx _.
    + move=> p0 v0; rewrite -negP=> /build_hpathP [<*>|].
      + by have /hs_of_INV [] _ + H - /H {H} := HINV.
      by move=> p' b' v' h' <*>; rewrite ch_notin_rng2_mh.
    move=> ^ /build_hpathP + -> /=; rewrite getP.
    by case=> [<*>|/#]; move: HINV=> /hs_of_INV [] _ + H - /H {H} /#.
  move=> p v p' v' hx.
  have: (forall p v, build_hpath mh p <> Some (v,ch)).
  + move=> p0 v0; rewrite -negP=> /build_hpathP [<*>|].
    + by have /hs_of_INV [] _ + H - /H {H} := HINV.
    move=> p'0 b'0 v'0 h'0 <*> _; have /m_mh_of_INV [] _ H /H {H} := HINV.
    by move=> [xc fx yc fy] [#] _; have /hs_of_INV [] _ _ H /H {H}:= HINV.
  move=> ^ + /build_hpath_down H /H {H} - /build_hpath_down H + /H {H}.
  by have /mh_of_INV [] _ _ /(_ p v p' v' hx) := HINV.
split=> c p v; have ^/hs_of_INV [] _ _ dom_hs /pi_of_INV [] -> := HINV.
apply/exists_iff=> h /=; split=> [#].
+ move=> /(build_hpath_up mh x1 ch y1 (ch + 1) p v h) /(_ _).
  + by apply/(notin_hs_notin_dom2_mh hs Pm)/ch_notin_dom_hs; case: HINV.
  by move=> -> /= ^ /dom_hs; rewrite !getP /#.
have ch_notin_rng2_mh: forall a h a', mh.[(a,h)] <> Some (a',ch).
+ move=> a h' a'; rewrite -negP; have /m_mh_of_INV [] _ Hmh_m /Hmh_m {Hmh_m} := HINV.
  by move=> [xc fx yc fy] [#] _; rewrite ch_notin_dom_hs; case: HINV.
have Sch_notin_rng2_mh: forall a h a', mh.[(a,h)] <> Some (a',ch + 1).
+ move=> a h' a'; rewrite -negP; have /m_mh_of_INV [] _ Hmh_m /Hmh_m {Hmh_m} := HINV.
  by move=> [xc fx yc fy] [#] _; rewrite Sch_notin_dom_hs; case: HINV.
have H /H {H}:= build_hpath_down mh x1 ch y1 (ch + 1) p v h _.
+ move=> p0 v0; rewrite -negP=> /build_hpathP [<*>|].
  + by have /hs_of_INV [] _ + H - /H {H} := HINV.
  by move=> p' b' v' h' <*>; rewrite ch_notin_rng2_mh.
move=> ^ /build_hpathP + -> /=; rewrite !getP.
by case=> [<*>|/#]; move: HINV=> /hs_of_INV [] _ + H - /H {H} /#.
qed.

lemma lemma2 hs ch PFm PFmi G1m G1mi G1mh G1mhi ro pi x1 x2 y1 y2 hx:
     INV_CF_G1 hs ch PFm PFmi G1m G1mi G1mh G1mhi ro pi
  => PFm.[(x1,x2)] = None
  => G1m.[(x1,x2)] = None
  => pi.[x2] = None
  => hs.[hx] = Some (x2,Known)
  => (forall f h, hs.[h] <> Some (y2,f))
  => INV_CF_G1 hs.[ch <- (y2,Known)] (ch + 1)
               PFm.[(x1,x2) <- (y1,y2)] PFmi.[(y1,y2) <- (x1,x2)]
               G1m.[(x1,x2) <- (y1,y2)] G1mi.[(y1,y2) <- (x1,x2)]
               G1mh.[(x1,hx) <- (y1,ch)] G1mhi.[(y1,ch) <- (x1,hx)]
               ro pi.
proof.
move=> HINV PFm_x1x2 G1m_x1x2 pi_x2 hs_hx y2_notin_rng1_hs.
split.
+ by apply/hs_addh=> //=; case: HINV.
+ apply/inv_addm; 1:by case: HINV.
  + have ^ /m_mh_of_INV Hm_mh /hs_of_INV Hhs := HINV.
    by apply/(notin_m_notin_mh _ _ _ _ Hm_mh PFm_x1x2 hs_hx).
  have ^ /mi_mhi_of_INV Hmi_mhi /hs_of_INV Hhs := HINV.
  by apply/(ch_notin_dom2_mh _ _ Hmi_mhi Hhs).
+ have ^ /hs_of_INV ^ Hhs [] Hhuniq _ _ /m_mh_of_INV := HINV.
  move=> /m_mh_addh_addm /(_ hx x1 x2 ch y1 y2 Known Hhuniq hs_hx _) //.
  exact/ch_notin_dom_hs.
+ have ^ /hs_of_INV ^ Hhs [] Hhuniq _ _ /mi_mhi_of_INV := HINV.
  move=> /mi_mhi_addh_addmi /(_ hx x1 x2 ch y1 y2 Known _ hs_hx _) //.
  exact/ch_notin_dom_hs.
+ by have /incl_of_INV/incl_addm ->:= HINV.
+ by have /incli_of_INV/incl_addm ->:= HINV.
+ split.
  + move=> xa' hx' ya' hy'; rewrite getP; case: ((xa',hx') = (x1,hx))=> [[#] <*>> [#] <<*> /=|].
    + exists x2 Known y2 Known=> //=; rewrite !getP /=.
      by have /hs_of_INV [] _ _ dom_hs /#:= HINV.
    move=> xahx'_neq_x1hx; have /mh_of_INV [] Hmh _ _ /Hmh {Hmh} := HINV.
    move=> [xc fx yc] [] /= [#] hs_hx' hs_hy'=> [[p v] [Hro Hpath]|<*> Gm_xa'xc].
    + exists xc fx yc Unknown=> /=; rewrite !getP hs_hx' hs_hy'.
      rewrite (dom_hs_neq_ch hs xc fx _ hs_hx') /=; 1:by case: HINV.
      rewrite (dom_hs_neq_ch hs yc Unknown _ hs_hy')/= ; 1:by case: HINV.
      exists p v; rewrite Hro /=; apply/build_hpath_up/(notin_m_notin_mh _ _ _ _ _ PFm_x1x2 hs_hx).
      + done.
      by case: HINV.
    exists xc Known yc Known=> //=; rewrite !getP; case: ((xa',xc) = (x1,x2))=> [/#|].
    rewrite Gm_xa'xc /= (dom_hs_neq_ch hs xc Known _ hs_hx') /=; 1:by case: HINV.
    by rewrite (dom_hs_neq_ch hs yc Known _ hs_hy')/= ; 1:by case: HINV.
  + move=> p xa b; have /mh_of_INV [] _ -> _ := HINV; split.
    + move=> [v hi hf] [#] Hpath mh_vxahi; exists v hi hf.
      rewrite getP; case: ((v +^ xa,hi) = (x1,hx))=> [[#] <*>|_].
      + move: mh_vxahi; have /m_mh_of_INV [] _ H /H {H}:= HINV.
        by move=> [xc fx yc fy] [#]; rewrite hs_hx=> [#] <*>; rewrite PFm_x1x2.
      rewrite mh_vxahi /=; apply/build_hpath_up=> //.
      by apply/(notin_m_notin_mh _ _ _ _ _ PFm_x1x2 hs_hx); case: HINV.
    move=> [v hi hf] [#].
    have no_path_to_hx: forall p0 v0, build_hpath G1mh p0 <> Some (v0,hx).
    + have /pi_of_INV [] /(_ x2):= HINV; rewrite pi_x2 /=.
      by move=> + p0 v0 - /(_ p0 v0) /negb_exists /(_ hx) /=; rewrite hs_hx.
    have H /H {H} := build_hpath_down G1mh x1 hx y1 ch p v hi no_path_to_hx.
    rewrite getP. case: ((v +^ xa,hi) = (x1,hx))=> [[#] <*>|_ Hpath Hextend].
    + by rewrite no_path_to_hx.
    by exists v hi hf.
  move=> p v p' v' h0.
  have: forall p0 v0, build_hpath G1mh p0 <> Some (v0,hx).
  + have /pi_of_INV [] /(_ x2):= HINV; rewrite pi_x2 /=.
    by move=> + p0 v0 - /(_ p0 v0) /negb_exists /(_ hx) /=; rewrite hs_hx.
  move=> ^ + /build_hpath_down H /H {H} - /build_hpath_down H + /H {H}.
  by have /mh_of_INV [] _ _ /(_ p v p' v' h0):= HINV.
split=> c p v; have /pi_of_INV [] -> := HINV.
apply/exists_iff=> h /=; split=> [#].
+ move=> /build_hpath_up /(_ x1 hx y1 ch _).
  + by apply/(notin_m_notin_mh hs PFm x2 Known); case:HINV.
  move=> -> /=; rewrite getP.
  by have /hs_of_INV [] _ _ dom_hs ^ + /dom_hs /#:= HINV.
have no_path_to_hx: forall p0 v0, build_hpath G1mh p0 <> Some (v0,hx).
+ have /pi_of_INV [] /(_ x2):= HINV; rewrite pi_x2 /=.
  by move=> + p0 v0 - /(_ p0 v0) /negb_exists /(_ hx) /=; rewrite hs_hx.
have H /H {H} := build_hpath_down G1mh x1 hx y1 ch p v h no_path_to_hx.
move=> ^ Hpath -> /=; rewrite getP; case: (h = ch)=> [<*> /= [#] <*>|//=].
move: Hpath=> /build_hpathP [<*>|].
+ by have /hs_of_INV [] _ + H - /H {H}:= HINV.
move=> p' b' v' h' <*> _; have /m_mh_of_INV [] _ H /H {H}:= HINV.
by move=> [xc fx yc fy] [#] _; have /hs_of_INV [] _ _ H /H {H}:= HINV.
qed.

lemma lemma3 hs ch Pm Pmi Gm Gmi mh mhi ro pi xa xc hx ya yc hy p b:
     INV_CF_G1 hs ch Pm Pmi Gm Gmi mh mhi ro pi
  => Pm.[(xa,xc)] = Some (ya,yc)
  => Gm.[(xa,xc)] = None
  => mh.[(xa,hx)] = Some (ya,hy)
  => hs.[hx] = Some (xc,Known)
  => hs.[hy] = Some (yc,Unknown)
  => pi.[xc] = Some (p,b)
  => INV_CF_G1 hs.[hy <- (yc,Known)] ch
               Pm Pmi
               Gm.[(xa,xc) <- (ya,yc)] Gmi.[(ya,yc) <- (xa,xc)]
               mh mhi
               ro pi.[yc <- (rcons p (b +^ xa),ya)].
proof.
move=> HINV Pm_xaxc Gm_xaxc mh_xahx hs_hx hs_hy pi_xc.
split.
+ have /hs_of_INV /hs_updh /(_ Unknown) H := HINV; apply/H=> {H} //.
  by rewrite -negP=> <*>; move: hs_hy; have /hs_of_INV [] _ -> := HINV.
+ by case: HINV.
+ by apply/(m_mh_updh Unknown)=> //; case: HINV.
+ by apply/(m_mh_updh Unknown)=> //; case: HINV.
+ move=> [za zc]; rewrite getP; case: ((za,zc) = (xa,xc))=> // _.
  by have /incl_of_INV H /H {H}:= HINV.
+ move: mh_xahx; have /inv_of_INV [] H /H {H}:= HINV.
  have /mi_mhi_of_INV [] _ H /H {H} [xct fxt yct fyt] [#] := HINV.
  rewrite hs_hx hs_hy=> /= [#] 2!<<- {xct fxt} [#] 2!<<- {yct fyt} Pmi_yayc.
  move=> [za zc]; rewrite getP; case: ((za,zc) = (ya,yc))=> // _.
  by have /incli_of_INV H /H {H}:= HINV.
+ split; last 2 by have /mh_of_INV [] _:= HINV.
  move=> xa' hx' ya' hy'; case: ((xa',hx') = (xa,hx))=> [[#] <*>|].
  + rewrite mh_xahx=> /= [#] <<*>; rewrite !getP /=.
    case: (hx = hy)=> [<*>|_]; first by move: hs_hx; rewrite hs_hy.
    by exists xc Known yc Known; rewrite getP.
  move=> Hxahx' mh_xahx'.
  have ^path_to_hy: build_hpath mh (rcons p (b +^ xa)) = Some (ya,hy).
  + apply/build_hpath_prefix; exists b hx.
    rewrite xorwA xorwK xorwC xorw0 mh_xahx /=.
    move: pi_xc; have /pi_of_INV [] -> [h] [#] := HINV.
    by have /hs_of_INV [] H _ _ + /H {H} /(_ _ _ hs_hx _) := HINV.
  have /mh_of_INV [] /(_ _ _ _ _ mh_xahx') + ro_def H /H {H} unique_path_to_hy := HINV.
  move=> [xc' fx' yc' fy'] /= [#].
  case: (hy' = hy)=> [<*> hs_hx'|Hhy'].
  + rewrite hs_hy=> /= [#] <<*> /= [p' b'] [#] ro_pbxa' path_hx'.
    have:= unique_path_to_hy (rcons p' (b' +^ xa')) ya' _.
    + by apply/build_hpath_prefix; exists b' hx'; rewrite xorwA xorwK xorwC xorw0.
    move=> [#] ^/rconsIs + /rconssI - <<*>.
    by move: mh_xahx' Hxahx' mh_xahx; have /inv_of_INV [] ^ + -> - -> -> /= -> := HINV.
  rewrite (@getP _ _ _ hy') Hhy'=> /= hs_hx' ^ hs_hy' -> Hite.
  exists xc' (if hx' = hy then Known else fx') yc' fy'.
  rewrite (@getP Gm) (_: (xa',xc') <> (xa,xc)) /=.
  + move: Hxahx'=> /=; case: (xa' = xa)=> [<*> /=|//].
    by apply/contra=> <*>; have /hs_of_INV [] + _ _ - /(_ _ _ _ _ hs_hx' hs_hx _) := HINV.
  rewrite getP; case: (hx' = hy)=> /= [<*>|//].
  move: hs_hx'; rewrite hs_hy=> /= [#] <<*> /=.
  by move: Hite=> /= [#]; case: fy' hs_hy'=> //= _ ->.
split=> c p' b'; rewrite !getP; case: (yc = c)=> [<<*> /=|yc_neq_c]; last first.
+ rewrite (@eq_sym c) yc_neq_c /=; have /pi_of_INV [] -> := HINV.
  apply/exists_iff=> h /=; rewrite getP; case: (h = hy)=> [<*> /=|//=].
  by rewrite yc_neq_c hs_hy /=.
split=> [[#] <<*>|].
+ exists hy; rewrite getP /=; apply/build_hpath_prefix.
  exists b hx; rewrite xorwA xorwK xorwC xorw0 mh_xahx /=.
  move: pi_xc; have /pi_of_INV [] -> [h] [#] + hs_h:= HINV.
  by have /hs_of_INV [] + _ _ - /(_ _ _ _ _ hs_hx hs_h _) := HINV.
move=> [h]; rewrite getP; case: (h = hy)=> [<*> /=|]; last first.
+ by have /hs_of_INV [] H _ _ + [#] _ /H {H} /(_ _ _ hs_hy _) // <*> := HINV.
have /mh_of_INV [] _ _ /(_ p' b') H /H {H} /(_ (rcons p (b +^ xa)) ya _) //:= HINV.
apply/build_hpath_prefix; exists b hx; rewrite xorwA xorwK xorwC xorw0 mh_xahx /=.
move: pi_xc; have /pi_of_INV [] -> [h] [#] + hs_h:= HINV.
by have /hs_of_INV [] + _ _ - /(_ _ _ _ _ hs_hx hs_h _) := HINV.
qed.

clone export ConcreteF as ConcreteF1.

section AUX.

  declare module D : DISTINGUISHER {PF, RO, G1}.

  axiom D_ll (F <: DFUNCTIONALITY{D}) (P <: DPRIMITIVE{D}):
    islossless P.f => islossless P.fi => islossless F.f => 
    islossless D(F, P).distinguish.

  equiv CF_G1 : CF(D).main ~ G1(D).main: 
                 ={glob D} ==> !(G1.bcol \/ G1.bext){2} => ={res}.
  proof.               
  proc.
  call (_: G1.bcol \/ G1.bext,
           INV_CF_G1 FRO.m{2} G1.chandle{2} PF.m{1} PF.mi{1}
                     G1.m{2} G1.mi{2} G1.mh{2} G1.mhi{2} F.RO.m{2} G1.paths{2}).
  (* lossless D *)
  + exact/D_ll.
  (** proofs for G1.S.f *)
  (* equivalence up to bad of PF.f and G1.S.f *)
  + conseq (_:    !G1.bcol{2}
               /\ !G1.bext{2}
               /\ ={x}
               /\ INV_CF_G1 FRO.m{2} G1.chandle{2}
                            PF.m{1} PF.mi{1}
                            G1.m{2} G1.mi{2} G1.mh{2} G1.mhi{2}
                            F.RO.m{2} G1.paths{2}
           ==>    !G1.bcol{2}
               => !G1.bext{2}
               => ={res}
               /\ INV_CF_G1 FRO.m{2} G1.chandle{2}
                            PF.m{1} PF.mi{1}
                            G1.m{2} G1.mi{2} G1.mh{2} G1.mhi{2}
                            F.RO.m{2} G1.paths{2}).
    + by move=> &1 &2; rewrite negb_or.
    + by move=> &1 &2 _ ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? [#]; rewrite negb_or.
    (* For now, everything is completely directed by the syntax of
    programs, so we can *try* to identify general principles of that
    weird data structure and of its invariant. I'm not sure we'll ever
    be able to do that, though. *)
    (* We want to name everything for now, to make it easier to manage complexity *)
    exists * FRO.m{2}, G1.chandle{2},
             PF.m{1}, PF.mi{1},
             G1.m{2}, G1.mi{2}, G1.mh{2}, G1.mhi{2},
             F.RO.m{2}, G1.paths{2},
             x{2}.
    elim * => hs0 ch0 PFm PFmi G1m G1mi G1mh G1mhi ro0 pi0 [] x1 x2.
    (* poor man's extraction of a fact from a precondition *)
    case @[ambient]: {-1}(INV_CF_G1 hs0 ch0 PFm PFmi G1m G1mi G1mh G1mhi ro0 pi0)
                     (eq_refl (INV_CF_G1 hs0 ch0 PFm PFmi G1m G1mi G1mh G1mhi ro0 pi0)); last first.
    + by move=> h; exfalso=> &1 &2 [#] <*>; rewrite h.
    move=> /eqT inv0; proc; case @[ambient] {-1}(PFm.[(x1,x2)]) (eq_refl (PFm.[(x1,x2)])).
    + move=> PFm_x1x2.
      have /incl_of_INV /(notin_m_notin_Gm _ _ (x1,x2)) /(_ _) // Gm_x1x2 := inv0.
      rcondt{1} 1; 1:by move=> //= &1; skip=> &2 [#] <*>; rewrite in_dom PFm_x1x2.
      rcondt{2} 1; 1:by move=> //= &1; skip=> &2 [#] <*>; rewrite in_dom Gm_x1x2.
      case @[ambient]: {-1}(pi0.[x2]) (eq_refl (pi0.[x2])).
      + move=> x2_in_pi; rcondf{2} 1.
        + by move=> //= &1; skip=> &2 [#] <*>; rewrite in_dom x2_in_pi.
        rcondf{2} 8.
        + by move=> //= &1; auto=> &2 [#] !<<-; rewrite !in_dom x2_in_pi.
        seq  2  2: (   hs0 = FRO.m{2}
                    /\ ch0 = G1.chandle{2}
                    /\ PFm = PF.m{1}
                    /\ PFmi = PF.mi{1}
                    /\ G1m = G1.m{2}
                    /\ G1mi = G1.mi{2}
                    /\ G1mh = G1.mh{2}
                    /\ G1mhi = G1.mhi{2}
                    /\ ro0 = F.RO.m{2}
                    /\ pi0 = G1.paths{2}
                    /\ (x1,x2) = x{2}
                    /\ !G1.bcol{2}
                    /\ !G1.bext{2}
                    /\ ={x, y1, y2}
                    /\ INV_CF_G1 hs0 ch0 PFm PFmi G1m G1mi G1mh G1mhi ro0 pi0).
        + by auto.
        case @[ambient]: {-1}(getflag hs0 x2) (eq_refl (getflag hs0 x2)).
        + rewrite getflagP_none => x2f_notin_rng_hs0; rcondt{2} 3.
          + move=> &1; auto=> &2 /> _ _ _; rewrite in_rng negb_exists /=.
            exact/(@x2f_notin_rng_hs0 Known).
          rcondf{2} 6.
          + move=> &1; auto=> &2 />.
            have ->: hinvK FRO.m{2}.[G1.chandle{2} <- (x2,Known)] x2 = Some G1.chandle{2}.
            + rewrite (@huniq_hinvK_h G1.chandle{2} FRO.m{2}.[G1.chandle{2} <- (x2,Known)] x2) //.
              + move=> hx hy [] xc xf [] yc yf /=.
                rewrite !getP; case: (hx = G1.chandle{2}); case: (hy = G1.chandle{2})=> //=.
                + by move=> _ + [#] - <*>; have:= (x2f_notin_rng_hs0 yf hy).
                + by move=> + _ + [#] - <*>; have:= (x2f_notin_rng_hs0 xf hx).
                by move=> _ _; have /hs_of_INV [] + _ _ - /(_ hx hy (xc,xf) (yc,yf)) := inv0.
              by rewrite !getP.
            rewrite oget_some=> _ _ _.
            have -> //: !mem (dom G1.mh{2}) (x1,G1.chandle{2}).
            rewrite in_dom /=; case: {-1}(G1.mh.[(x1,G1.chandle)]{2}) (eq_refl (G1.mh.[(x1,G1.chandle)]{2}))=> //= -[xa xh]; rewrite -negP.
            have ^/m_mh_of_INV [] _ + /hs_of_INV [] _ _ h_handles := inv0.
            by move=> /(_ x1 G1.chandle{2} xa xh) h /h [] xc xf yc yf [#] /h_handles.
          case: (x2 <> y2{2} /\ (forall f h, hs0.[h] <> Some (y2{2},f))).
          + auto=> &1 &2 [#] !<<- -> -> !->> {&1} /= _ x2_neq_y2 y2_notin_hs _ _.
            rewrite getP /= oget_some /= -addzA /=.
            rewrite (@huniq_hinvK_h ch0 hs0.[ch0 <- (x2,Known)] x2); 2:by rewrite getP.
            + move=> @/huniq h1 h2 [c1 f1] [c2 f2]; rewrite !getP /=.
              case: (h1 = ch0); case: (h2 = ch0)=> //=.
              + by move=> _ + [#] - <*>; move: (x2f_notin_rng_hs0 f2 h2).
              + by move=> + _ + [#] <*> - <*>; move: (x2f_notin_rng_hs0 f1 h1).
              have /hs_of_INV [] + _ _ _ _ - h := inv0.
              by apply/h; rewrite getP.
            by rewrite oget_some; exact/lemma1.
          conseq (_: _ ==> G1.bcol{2})=> //=.
          auto=> &1 &2 [#] !<<- -> _ ->> !<<- _ /=.
          case: (hinvP hs0.[ch0 <- (x2,Known)] y2{1})=> //= -> /=.
          move=> hs0_spec; split=> [|f].
          + by have:= hs0_spec ch0 Known; rewrite getP.
          move=> h; have:= hs0_spec h f; rewrite getP; case: (h = ch0)=> [<*>|//=].
          by move=> _; rewrite -negP; have /hs_of_INV [] _ _ H /H {H}:= inv0.
        case; rewrite getflagP_some; 1,3:by have /hs_of_INV []:= inv0.
        + by move=> x2_is_U; conseq (_: G1.bext{2})=> //=; auto=> &1 &2 />; rewrite x2_is_U.
        move=> x2_is_K; rcondf{2} 3; 1:by move=> &1; auto.
        have:= x2_is_K; rewrite in_rng=> - [hx] hs0_hx.
        seq  0  3: (   hs0 = FRO.m{2}
                    /\ ch0 = G1.chandle{2}
                    /\ PFm = PF.m{1}
                    /\ PFmi = PF.mi{1}
                    /\ G1m = G1.m{2}
                    /\ G1mi = G1.mi{2}
                    /\ G1mh = G1.mh{2}
                    /\ G1mhi = G1.mhi{2}
                    /\ ro0 = F.RO.m{2}
                    /\ pi0 = G1.paths{2}
                    /\ (x1,x2) = x{2}
                    /\ !G1.bcol{2}
                    /\ !G1.bext{2}
                    /\ ={x,y1,y2}
                    /\ y{2} = (y1,y2){2}
                    /\ hx2{2} = hx
                    /\ INV_CF_G1 hs0 ch0 PFm PFmi G1m G1mi G1mh G1mhi ro0 pi0).
        + auto=> &1 &2 /> _ -> /= _; split.
          + move: x2_is_K; rewrite in_rng /= => -[hx2] hs_hx2.
            rewrite in_rng negb_exists /==> h; rewrite -negP=> hs_h.
            have /hs_of_INV [] Hhuniq _ _ := inv0.
            by move: (Hhuniq _ _ _ _ hs_hx2 hs_h)=> ht; move: ht hs_h=> /= <*>; rewrite hs_hx2.
          rewrite (@huniq_hinvK_h hx FRO.m{2} x2) //.
          by have /hs_of_INV [] := inv0.
        have x1hx_notin_G1m: !mem (dom G1mh) (x1,hx).
        + rewrite in_dom; case: {-1}(G1mh.[(x1,hx)]) (eq_refl G1mh.[(x1,hx)])=> //=.
          move=> [mhx1 mhx2]; rewrite -negP=> h.
          have /m_mh_of_INV [] _ hg := inv0.
          have [xa xh ya yh] := hg _ _ _ _ h.
          by rewrite hs0_hx=> [#] <*>; rewrite PFm_x1x2.
        rcondf{2} 1.
        + by move=> &m; auto=> //= &hr [#] <*>; rewrite x1hx_notin_G1m.
        auto=> &1 &2 [#] !<<- -> -> !->> _ /= hinv_y2_none.
        rewrite getP /= oget_some /=; apply/lemma2=> //.
        + by case: (hinvP hs0 y2{2})=> [_ + f h|//=] - ->.
      move=> [p0 v0] ^ pi_x2. have /pi_of_INV [] -> [hx2] [#] Hpath hs_hx2:= inv0.
      rcondt{2} 1. by move=> &m; auto=> &hr [#] !<<- _ _ ->> /= _; rewrite in_dom pi_x2.
      rcondf{2} 6.
      + auto; inline *; auto=> &hr [#] !<<- _ _ !->> _ /= _ _ _ _ /=.
        by rewrite in_rng; exists hx2.
      rcondf{2} 7.
      + auto; inline *; auto=> &hr [#] !<<- _ _ !->> _ /= _ _ _ _ /=.
        rewrite negb_and; left; rewrite (@huniq_hinvK_h hx2 hs0 x2) // 2:oget_some.
        + by have /hs_of_INV []:= inv0.
        rewrite in_dom; case: {-1}(G1mh.[(x1,hx2)]) (eq_refl (G1mh.[(x1,hx2)]))=> [//=|[xa xc] G1mh_x1hx2].
        have /m_mh_of_INV [] _ /(_ _ _ _ _ G1mh_x1hx2) [xc0 xf0 yc0 yf0] := inv0.
        by move=> [#]; rewrite hs_hx2=> [#] !<<- {xc0 xf0}; rewrite PFm_x1x2.
      rcondt{2} 15.
      + auto; inline *; auto=> &hr [#] !<<- _ _ !->> _ /= _ _ _ _ /=.
        by rewrite in_dom pi_x2.
      inline F.RO.get. rcondt{2} 4.
      + auto=> &hr [#] !<<- _ _ !->> _ /= _ _; rewrite pi_x2 oget_some /=.
        rewrite in_dom; case: {-1}(ro0.[rcons p0 (v0 +^ x1)]) (eq_refl (ro0.[rcons p0 (v0 +^ x1)])).
        + done.
        move=> bo ^ro_pvx1 /=. have /mh_of_INV [] _ -> _:= inv0.
        rewrite negb_exists=> ? /=; rewrite negb_exists=> ? /=; rewrite negb_exists=> yh /=.
        rewrite Hpath /=; rewrite negb_and -implyNb /= => [#] !<<-.
        rewrite xorwA xorwK xorwC xorw0 -negP=> G1mh_x1hx2.
        have /m_mh_of_INV [] _ /(_ _ _ _ _ G1mh_x1hx2) := inv0.
        move=> [xc xf yc yf] [#]; rewrite hs_hx2=> [#] <*>.
        by rewrite PFm_x1x2.
      auto. admit. (* this is the easy case *)
    move=> [xa xc] PFm_x1x2. rcondf{1} 1; 1:by auto=> &hr [#] !<<- _ _ ->>; rewrite in_dom PFm_x1x2.
    have /m_mh_of_INV [] + _ - /(_ _ _ _ _ PFm_x1x2) := inv0.
    move=> [hx2 fx2 hy2 fy2] [#] hs_hx2 hs_hy2 G1mh_x1hx2.
    case @[ambient]: {-1}(G1m.[(x1,x2)]) (eq_refl (G1m.[(x1,x2)])); last first.
    + move=> [ya yc] G1m_x1x2; rcondf{2} 1; 1:by auto=> &hr [#] !<<- _ _ ->>; rewrite in_dom G1m_x1x2.
      auto=> &1 &2 [#] <*> -> -> -> /=; have /incl_of_INV /(_ (x1,x2)) := inv0.
      by rewrite PFm_x1x2 G1m_x1x2 /= => [#] !<<- {ya yc}.
    move=> x1x2_notin_G1m; rcondt{2} 1; 1:by auto=> &hr [#] !<<- _ _ ->>; rewrite in_dom x1x2_notin_G1m.
    have <*>: fy2 = Unknown.
    + have /mh_of_INV [] /(_ _ _ _ _ G1mh_x1hx2) + _ := inv0.
      move=> [xc0 xf0 yc0 yf0] [#]; rewrite hs_hx2 hs_hy2=> [#] !<<- [#] !<<- {xc0 xf0 yc0 yf0}.
      by case: fy2 hs_hy2 G1mh_x1hx2=> //=; rewrite x1x2_notin_G1m.
    case @[ambient]: fx2 hs_hx2=> hs_hx2.
    + swap{2} 3 -2; seq  0  1: (G1.bext{2}); last by inline*; if{2}; auto; smt (@Block @Capacity).
      by auto=> ? ? [#] !<<- _ -> ->> _ /=; rewrite in_rng; exists hx2.
    have /mh_of_INV []/(_ _ _ _ _ G1mh_x1hx2) + _ _:= inv0.
    move=> [xc0 xf0 yc0 yf0] [#]; rewrite hs_hx2 hs_hy2=> [#] !<<- [#] !<<- {xc0 xf0 yc0 yf0} /= [p0 v0] [#] Hro Hpath.
    have /pi_of_INV [] /(_ x2 p0 v0) /iffRL /(_ _) := inv0.
    + by exists hx2.
    move=> pi_x2; rcondt{2} 1; 1:by auto=> &hr [#] <*>; rewrite in_dom pi_x2.
    inline F.RO.get.
    rcondf{2} 4; first by auto=> &hr [#] !<<- _ _ ->> _ /=; rewrite pi_x2 oget_some /= in_dom Hro.
    rcondf{2} 8; first by auto=> &hr [#] !<<- _ _ ->> _ /= _ _ _ _; rewrite in_rng; exists hx2.
    rcondt{2} 9.
    + auto=> &hr [#] !<<- _ _ ->> _ /= _ _ _ _.
      rewrite (@huniq_hinvK_h hx2 hs0 x2) // 2:in_dom 2:G1mh_x1hx2 2:!oget_some /=.
      + by have /hs_of_INV []:= inv0.
      by rewrite /in_dom_with in_dom hs_hy2.
    rcondt{2} 14; first by auto=> &hr [#] !<<- _ _ ->> _ /=; rewrite in_dom pi_x2.
    auto=> &1 &2 [#] !<<- -> -> ->> _ /=; rewrite Block.DWord.bdistr_ll Capacity.DWord.cdistr_ll /=.
    move=> _ _ _ _; rewrite PFm_x1x2 pi_x2 !oget_some //=.
    rewrite (@huniq_hinvK_h hx2 hs0 x2) // ?oget_some.
    + by have /hs_of_INV []:= inv0.
    rewrite Hro G1mh_x1hx2 hs_hy2 ?oget_some //= => _.
    exact/(@lemma3 _ _ _ _ _ _ _ _ _ _ _ _ hx2 _ _ hy2).
  (* Stopped here *)
  + move=> &2 _; proc; if=> //=; wp; rnd predT; rnd predT; auto.
    smt (Block.DWord.bdistr_uf Capacity.DWord.cdistr_uf).
  (* lossless and do not reset bad G1.S.f *)
  + move=> _; proc; if; auto.
    conseq (_: _ ==> G1.bcol \/ G1.bext); 1:smt ().
    inline *; if=> //=; wp; rnd predT; wp; rnd predT; auto.
    + smt (Block.DWord.bdistr_uf Capacity.DWord.cdistr_uf).
    smt (Block.DWord.bdistr_uf Capacity.DWord.cdistr_uf).
  (** proofs for G1.S.fi *)
  (* equiv PF.P.fi G1.S.fi *)
  + admit.
  (* lossless PF.P.fi *)
  + admit.
  (* lossless and do not reset bad G1.S.fi *)
  + admit.
  (** proofs for G1.C.f *)
  (* equiv PF.C.f G1.C.f *)
  + admit.
  (* lossless PF.C.f *)
  + admit.
  (* lossless and do not reset bad G1.C.f *)
  + admit.
  (* Init ok *)
  inline *; auto=> />; split=> [|/#].
  (do !split; last 3 smt (getP map0P build_hpath_map0)); last 5 by move=> ? ? ? ?; rewrite map0P.
  + move=> h1 h2 ? ?; rewrite !getP !map0P.
    by case: (h1 = 0); case: (h2 = 0)=> //=.
  + by rewrite getP.
  + by move=> ? h; rewrite getP map0P; case: (h = 0).
  by move=> ? ?; rewrite !map0P.
qed.

end section AUX.

section.

  declare module D: DISTINGUISHER{Perm, C, PF, G1, RO}.
  
  axiom D_ll (F <: DFUNCTIONALITY{D}) (P <: DPRIMITIVE{D}):
    islossless P.f => islossless P.fi =>
    islossless F.f => islossless D(F, P).distinguish.

  lemma Real_G1 &m: 
    Pr[GReal(D).main() @ &m: res /\ C.c <= max_size] <=
    Pr[G1(DRestr(D)).main() @ &m: res] +  (max_size ^ 2)%r * mu dstate (pred1 witness) + 
    Pr[G1(DRestr(D)).main() @&m: G1.bcol] + Pr[G1(DRestr(D)).main() @&m: G1.bext].
  proof. 
    apply (@RealOrder.ler_trans _ _ _ (Real_Concrete D D_ll &m)).
    cut : Pr[CF(DRestr(D)).main() @ &m : res] <= 
          Pr[G1(DRestr(D)).main() @ &m : res] + 
          Pr[G1(DRestr(D)).main() @ &m : G1.bcol \/ G1.bext].
    + byequiv (CF_G1 (DRestr(D)) _)=>//;1:by apply (DRestr_ll D D_ll).
      smt ml=0.
    cut /# : Pr[G1(DRestr(D)).main() @ &m : G1.bcol \/ G1.bext] <= 
             Pr[G1(DRestr(D)).main() @ &m : G1.bcol] + 
             Pr[G1(DRestr(D)).main() @ &m : G1.bext].
    rewrite Pr [mu_or]; smt.
  qed.

end section.


