pragma -oldip. pragma +implicits.
require import Pred Fun Option Pair Int Real StdOrder Ring NewLogic.
require import List FSet NewFMap Utils Common SLCommon RndO.
require import DProd Dexcepted.
(*...*) import Capacity IntOrder.

require ConcreteF.

clone import GenEager as ROhandle with
  type from   <- handle,
  type to     <- capacity,
  op sampleto <- fun (_:int) => cdistr
  proof sampleto_ll by apply DWord.cdistr_ll.

module G1(D:DISTINGUISHER) = {
  var m, mi               : smap
  var mh, mhi             : hsmap
  var chandle             : int
  var paths               : (capacity, block list * block) fmap
  var bext, bcol          : bool

  module C = {

    proc f(p : block list): block = {
      var sa, sa', sc;
      var h, i <- 0; 
      sa <- b0;
      while (i < size p ) {
        if (mem (dom mh) (sa +^ nth witness p i, h)) {
          (sa, h) <- oget mh.[(sa +^ nth witness p i, h)];
        } else {
          sc                  <$ cdistr;
          bcol                <- bcol \/ hinv FRO.m sc <> None;
          sa'                 <@ F.RO.get(take (i+1) p);
          sa                  <- sa +^ nth witness p i;
          mh.[(sa,h)]         <- (sa', chandle);
          mhi.[(sa',chandle)] <- (sa, h);
          (sa,h)              <- (sa',chandle);
          FRO.m.[chandle]     <- (sc,Unknown);
          chandle             <- chandle + 1;
        }
        i        <- i + 1;
      }
      sa <- F.RO.get(p);
      return sa;
    }
  }

  module S = {

    proc f(x : state): state = {
      var p, v, y, y1, y2, hy2, hx2;

      if (!mem (dom m) x) {
        if (mem (dom paths) x.`2) {
          (p,v) <- oget paths.[x.`2]; 
          y1    <- F.RO.get (rcons p (v +^ x.`1));
          y2    <$ cdistr;
        } else {
          y1    <$ bdistr;
          y2    <$ cdistr;
        }
        y     <- (y1, y2);
        bext <- bext \/ mem (rng FRO.m) (x.`2, Unknown);   
        if (!(mem (rng FRO.m) (x.`2, Known))) {
          FRO.m.[chandle] <- (x.`2, Known);
          chandle <- chandle + 1;
        }
        hx2 <- oget (hinvK FRO.m x.`2);
        if (mem (dom mh) (x.`1, hx2) /\ in_dom_with FRO.m (oget mh.[(x.`1,hx2)]).`2 Unknown) {
          hy2               <- (oget mh.[(x.`1, hx2)]).`2;
          y                 <- (y.`1, (oget FRO.m.[hy2]).`1);
          FRO.m.[hy2]       <- (y.`2, Known);
          m.[x]             <- y;
          mi.[y]            <- x;
        } else {
          bcol              <- bcol \/ hinv FRO.m y.`2 <> None;          
          hy2               <- chandle;
          chandle           <- chandle + 1;
          FRO.m.[hy2]       <- (y.`2, Known);
          m.[x]             <- y;
          mh.[(x.`1, hx2)]  <- (y.`1, hy2);
          mi.[y]            <- x;
          mhi.[(y.`1, hy2)] <- (x.`1, hx2);
        }
        if (mem (dom paths) x.`2) {
          (p,v) <- oget paths.[x.`2]; 
          paths.[y.`2] <- (rcons p (v +^ x.`1), y.`1);
        }

      } else {   
        y <- oget m.[x];
      }
      return y;
    }

    proc fi(x : state): state = {
      var y, y1, y2, hx2, hy2;

      if (!mem (dom mi) x) {
        bext <- bext \/ mem (rng FRO.m) (x.`2, Unknown);   
        if (!(mem (rng FRO.m) (x.`2, Known))) {
          FRO.m.[chandle] <- (x.`2, Known);
          chandle <- chandle + 1;
        }
        hx2 <- oget (hinvK FRO.m x.`2);
        y1  <$ bdistr;
        y2  <$ cdistr;
        y   <- (y1,y2);
        if (mem (dom mhi) (x.`1,hx2) /\
            in_dom_with FRO.m (oget mhi.[(x.`1,hx2)]).`2 Unknown) {
          (y1,hy2)          <- oget mhi.[(x.`1, hx2)];
          y                 <- (y.`1, (oget FRO.m.[hy2]).`1);
          FRO.m.[hy2]       <- (y.`2, Known);
          mi.[x]            <- y;
          m.[y]             <- x;
        } else {
          bcol              <- bcol \/ hinv FRO.m y.`2 <> None;          
          hy2               <- chandle;
          chandle           <- chandle + 1;
          FRO.m.[hy2]       <- (y.`2, Known);
          mi.[x]            <- y;
          mhi.[(x.`1, hx2)] <- (y.`1, hy2);
          m.[y]             <- x;
          mh.[(y.`1, hy2)]  <- (x.`1, hx2);
        }
      } else {
        y <- oget mi.[x];
      }
      return y;
    }

  }

  proc main(): bool = {
    var b;

    F.RO.m   <- map0;
    m        <- map0;
    mi       <- map0;
    mh       <- map0;
    mhi      <- map0;
    bext     <- false;
    bcol     <- false;

    (* the empty path is initially known by the adversary to lead to capacity 0^c *)
    FRO.m    <- map0.[0 <- (c0, Known)];
    paths    <- map0.[c0 <- ([<:block>],b0)];
    chandle  <- 1;
    b        <@ D(C,S).distinguish();
    return b;
  }    
}.

(* -------------------------------------------------------------------------- *)
(** RELATIONAL: Map, Handle-Map and Handles are compatible **)
inductive eqm_handles (hs : handles) (m : smap) (mh : hsmap) =
  | MH of (forall xa xc ya yc,
             m.[(xa,xc)] = Some (ya,yc) =>
             exists xh xf yh yf,
                  hs.[xh]      = Some (xc,xf)
               /\ hs.[yh]      = Some (yc,yf)
               /\ mh.[(xa,xh)] = Some (ya,yh))
        & (forall xa xh ya yh,
             mh.[(xa,xh)] = Some (ya,yh) =>
             exists xc xf yc yf,
                  hs.[xh]     = Some (xc,xf)
               /\ hs.[yh]     = Some (yc,yf)
               /\ m.[(xa,xc)] = Some (ya,yc)).

(* Consequences of (xa,xc) \in (dom m) *)
lemma eqm_handles_m_some (hs : handles) (m : smap) (mh : hsmap)
                         xa xc ya yc:
     huniq hs
  => eqm_handles hs m mh
  => m.[(xa,xc)] = Some (ya,yc)
  => exists hx fx hy fy,
          hs.[hx] = Some (xc,fx)
       /\ hs.[hy] = Some (yc,fy)
       /\ mh.[(xa,hx)] = Some (ya,hy).
proof. by move=> hs_huniq [] + _ m_xaxc - /(_ _ _ _ _ m_xaxc). qed.

lemma eqm_handles_m_some_xy (hs : handles) (m : smap) (mh : hsmap)
                            xa xc ya yc hx fx hy fy:
     huniq hs
  => eqm_handles hs m mh
  => m.[(xa,xc)] = Some (ya,yc)
  => hs.[hx] = Some (xc,fx)
  => hs.[hy] = Some (yc,fy)
  => mh.[(xa,hx)] = Some (ya,hy).
proof.
move=> hs_huniq [] + _ m_xaxc hs_hx hs_hy - /(_ _ _ _ _ m_xaxc) [xh xf yh yf] [#].
by move=> /(hs_huniq _ _ _ _ hs_hx) /= <<*> /(hs_huniq _ _ _ _ hs_hy) /= <<*>.
qed.

lemma eqm_handles_m_some_x (hs : handles) (m : smap) (mh : hsmap)
                           xa xc ya yc hx fx:
     huniq hs
  => eqm_handles hs m mh
  => m.[(xa,xc)] = Some (ya,yc)
  => hs.[hx] = Some (xc,fx)
  => exists hy fy,
          hs.[hy] = Some (yc,fy)
       /\ mh.[(xa,hx)] = Some (ya,hy).
proof.
move=> hs_huniq [] + _ m_xaxc hs_hx - /(_ _ _ _ _ m_xaxc) [xh xf yh yf] [#].
by move=> /(hs_huniq _ _ _ _ hs_hx) /= <<*> hs_hy mh_xaxc; exists yh yf.
qed.

lemma eqm_handles_m_some_y (hs : handles) (m : smap) (mh : hsmap)
                           xa xc ya yc hy fy:
     huniq hs
  => eqm_handles hs m mh
  => m.[(xa,xc)] = Some (ya,yc)
  => hs.[hy] = Some (yc,fy)
  => exists hx fx,
          hs.[hx] = Some (xc,fx)
       /\ mh.[(xa,hx)] = Some (ya,hy).
proof.
move=> hs_huniq [] + _ m_xaxc hs_hy - /(_ _ _ _ _ m_xaxc) [xh xf yh yf] [#].
by move=> hs_hx /(hs_huniq _ _ _ _ hs_hy) /= <<*> mh_xaxc; exists xh xf.
qed.

(* Consequence of (xa,xc) \notin (dom m) *)
lemma eqm_handles_m_none_in_mh (hs : handles) (m : smap) (mh : hsmap)
                               xa xc ya yc hx:
     eqm_handles hs m mh
  => m.[(xa,xc)] = None
  => mh.[(xa,hx)] = Some (ya,yc)
  => (forall fx, hs.[hx] <> Some (xc,fx)).
proof. by move=> [] _ Hmh m_xaxc /Hmh [xc0 fx yc0 fy] [#] -> /#. qed.

lemma eqm_handles_m_none_in_hs (hs : handles) (m : smap) (mh : hsmap)
                               xa xc hx fx:
     eqm_handles hs m mh
  => m.[(xa,xc)] = None
  => hs.[hx] = Some (xc,fx)
  => mh.[(xa,hx)] = None.
proof.
move=> [] _ Hmh m_xaxc.
case: {-1}(mh.[(xa,hx)]) (eq_refl (mh.[(xa,hx)]))=> [//|]. (* TODO: contra *)
by move=> [ya hy] /Hmh [xc0 fx0 yc fy] [#] /#.
qed.

(* Consequence of (xa,hx) \in (dom mh) *)
lemma eqm_handles_mh_some (hs : handles) (m : smap) (mh : hsmap)
                          xa hx ya hy:
     huniq hs
  => eqm_handles hs m mh
  => mh.[(xa,hx)] = Some (ya,hy)
  => exists xc fx yc fy,
          hs.[hx] = Some (xc,fx)
       /\ hs.[hy] = Some (yc,fy)
       /\ m.[(xa,xc)] = Some (ya,yc).
proof. by move=> hs_huniq [] _ + mh_xaxc - /(_ _ _ _ _ mh_xaxc). qed.

lemma eqm_handles_mh_some_xy (hs : handles) (m : smap) (mh : hsmap)
                             xa hx ya hy xc fx yc fy:
     huniq hs
  => eqm_handles hs m mh
  => mh.[(xa,hx)] = Some (ya,hy)
  => hs.[hx] = Some (xc,fx)
  => hs.[hy] = Some (yc,fy)
  => m.[(xa,xc)] = Some (ya,yc).
proof.
move=> hs_huniq [] _ + mh_xaxc hs_hx hs_hy - /(_ _ _ _ _ mh_xaxc) [xc' xf' yc' yf'] [#].
by rewrite hs_hx hs_hy /= => [#] <<*> [#] <<*>.
qed.

lemma eqm_handles_mh_some_x (hs : handles) (m : smap) (mh : hsmap)
                            xa hx ya hy xc fx:
     huniq hs
  => eqm_handles hs m mh
  => mh.[(xa,hx)] = Some (ya,hy)
  => hs.[hx] = Some (xc,fx)
  => exists yc fy,
          hs.[hy] = Some (yc,fy)
       /\ m.[(xa,xc)] = Some (ya,yc).
proof.
move=> hs_huniq [] _ + mh_xaxc hs_hx - /(_ _ _ _ _ mh_xaxc) [xc' fx' yc fy] [#].
by rewrite hs_hx /= => [#] <<*> hs_hy m_xaxc; exists yc fy.
qed.

lemma eqm_handles_mh_some_y (hs : handles) (m : smap) (mh : hsmap)
                             xa hx ya hy yc fy:
     huniq hs
  => eqm_handles hs m mh
  => mh.[(xa,hx)] = Some (ya,hy)
  => hs.[hy] = Some (yc,fy)
  => exists xc fx,
          hs.[hx] = Some (xc,fx)
       /\ m.[(xa,xc)] = Some (ya,yc).
proof.
move=> hs_huniq [] _ + mh_xaxc hs_hy - /(_ _ _ _ _ mh_xaxc) [xc fx yc' fy'] [#] hs_hx.
by rewrite hs_hy /= => [#] <<*> m_xaxc; exists xc fx.
qed.

(* Consequences of (xa,hx) \notin (dom mh) *)
lemma eqm_handles_mh_none_in_m (hs : handles) (m : smap) (mh : hsmap)
                               xa xc ya yc hx:
     huniq hs
  => eqm_handles hs m mh
  => mh.[(xa,hx)] = None
  => m.[(xa,xc)] = Some (ya,yc)
  => (forall fx, hs.[hx] <> Some (xc,fx)).
proof. by move=> hs_huniq [] Hm _ mh_xaxc /Hm [hx0 fx hy0 fy] [#] /#. qed.

lemma eqm_handles_mh_none_in_hs (hs : handles) (m : smap) (mh : hsmap)
                                xa hx xc fx:
     huniq hs
  => eqm_handles hs m mh
  => mh.[(xa,hx)] = None
  => hs.[hx] = Some (xc,fx)
  => m.[(xa,xc)] = None.
proof.
move=> hs_huniq [] Hm _ m_xaxc.
case: {-1}(m.[(xa,xc)]) (eq_refl (m.[(xa,xc)]))=> [//|]. (* TODO: contra *)
by move=> [ya hy] /Hm [xc0 fx0 yc fy] [#] /#.
qed.

(* WELL-FORMEDNESS<2>: Handles, Map, Handle-Map and RO are compatible *)
inductive mh_spec (hs : handles) (m2 : smap) (mh : hsmap) (ro : (block list,block) fmap) =
  | H of (forall xa xh ya yh,
            mh.[(xa,xh)] = Some (ya,yh) =>
            exists xc xf yc yf,
                 hs.[xh] = Some (xc,xf)
              /\ hs.[yh] = Some (yc,yf)
              /\ if   yf = Known
                 then    m2.[(xa,xc)] = Some (ya,yc)
                      /\ xf = Known
                 else exists p v,
                      ro.[rcons p (v +^ xa)] = Some ya
                   /\ build_hpath mh p = Some (v,xh))
       & (forall p xa b,
            ro.[rcons p xa] = Some b <=>
            exists v xh yh,
                 build_hpath mh p = Some (v,xh)
              /\ mh.[(v +^ xa,xh)] = Some (b,yh)).

(* Consequences of (xa,hx) \in (dom mh) *)
lemma mh_spec_mh_some (hs : handles) (Gm : smap) (mh : hsmap) ro
                      xa hx ya hy:
     mh_spec hs Gm mh ro
  => mh.[(xa,hx)] = Some (ya,hy)
  => exists xc fx yc fy,
          hs.[hx] = Some (xc,fx)
       /\ hs.[hy] = Some (yc,fy)
       /\ if   fy = Known
          then    Gm.[(xa,xc)] = Some (ya,yc)
               /\ fx = Known
          else exists p v,
               ro.[rcons p (v +^ xa)] = Some ya
            /\ build_hpath mh p = Some (v,hx).
proof. by move=> [] + _ mh_xaxc - /(_ _ _ _ _ mh_xaxc). qed.

lemma mh_spec_mh_some_y (hs : handles) (Gm : smap) (mh : hsmap) ro
                        xa hx ya hy yc fy:
     mh_spec hs Gm mh ro
  => mh.[(xa,hx)] = Some (ya,hy)
  => hs.[hy] = Some (yc,fy)
  => exists xc fx,
          hs.[hx] = Some (xc,fx)
       /\ if   fy = Known
          then    Gm.[(xa,xc)] = Some (ya,yc)
               /\ fx = Known
          else exists p v,
               ro.[rcons p (v +^ xa)] = Some ya
            /\ build_hpath mh p = Some (v,hx).
proof.
move=> Hmh /(mh_spec_mh_some _ _ _ _ _ _ _ _ Hmh) [xc fx yc0 fy0] [#] -> ->.
by move=> + [#] <<*> - H; exists xc fx.
qed.

lemma mh_spec_mh_some_yK (hs : handles) (Gm : smap) (mh : hsmap) ro
                         xa hx ya hy yc:
     mh_spec hs Gm mh ro
  => mh.[(xa,hx)] = Some (ya,hy)
  => hs.[hy] = Some (yc,Known)
  => exists xc,
          hs.[hx] = Some (xc,Known)
       /\ Gm.[(xa,xc)] = Some (ya,yc).
proof.
move=> Hmh mh_xaxc /(mh_spec_mh_some_y _ _ _ _ _ _ _ _ _ _ Hmh mh_xaxc) [xc fx] [#] /=.
by move=> hs_hx Gm_xaxc <*>; exists xc.
qed.

lemma mh_spec_mh_some_yU (hs : handles) (Gm : smap) (mh : hsmap) ro
                         xa hx ya hy yc:
     mh_spec hs Gm mh ro
  => mh.[(xa,hx)] = Some (ya,hy)
  => hs.[hy] = Some (yc,Unknown)
  => exists xc fx p v,
          hs.[hx] = Some (xc,fx)
       /\ ro.[rcons p (v +^ xa)] = Some ya
       /\ build_hpath mh p = Some (v,hx).
proof.
move=> Hmh mh_xaxc /(mh_spec_mh_some_y _ _ _ _ _ _ _ _ _ _ Hmh mh_xaxc) [xc fx] [#] /=.
by move=> hs_hx [p v] H; exists xc fx p v.
qed.

lemma mh_spec_mh_some_x (hs : handles) (Gm : smap) (mh : hsmap) ro
                        xa hx ya hy xc fx:
     mh_spec hs Gm mh ro
  => mh.[(xa,hx)] = Some (ya,hy)
  => hs.[hx] = Some (xc,fx)
  => exists yc fy,
          hs.[hy] = Some (yc,fy)
       /\ if   fy = Known
          then    Gm.[(xa,xc)] = Some (ya,yc)
               /\ fx = Known
          else exists p v,
               ro.[rcons p (v +^ xa)] = Some ya
            /\ build_hpath mh p = Some (v,hx).
proof.
move=> Hmh /(mh_spec_mh_some _ _ _ _ _ _ _ _ Hmh) [xc0 fx0 yc fy] [#] -> ->.
by move=> + [#] <<*> - H; exists yc fy.
qed.

lemma mh_spec_mh_some_xU (hs : handles) (Gm : smap) (mh : hsmap) ro
                         xa hx ya hy xc:
     mh_spec hs Gm mh ro
  => mh.[(xa,hx)] = Some (ya,hy)
  => hs.[hx] = Some (xc,Unknown)
  => exists yc p v,
          hs.[hy] = Some (yc,Unknown)
       /\ ro.[rcons p (v +^ xa)] = Some ya
       /\ build_hpath mh p = Some (v,hx).
proof.
move=> Hmh mh_xaxc /(mh_spec_mh_some_x _ _ _ _ _ _ _ _ _ _ Hmh mh_xaxc) [yc fy] [#] ->.
by case: fy=> //= - [p v] H; exists yc p v.
qed.

inductive paths_spec (hs : handles) (mh : hsmap) (pi : (capacity,block list*block) fmap) =
  | P of (forall c p v,
            pi.[c] = Some (p,v) <=>
            exists h,
                 build_hpath mh p = Some(v,h)
              /\ hs.[h] = Some (c,Known)).

inductive handles_spec hs ch =
  | Hs of (huniq hs)
        & (hs.[0] = Some (c0,Known))
        & (forall h, mem (dom hs) h => h < ch).

inductive inverse_spec (m:('a,'b) fmap) mi =
  | Is of (forall x y, m.[x] = Some y <=> mi.[y] = Some x).

inductive INV_CF_G1 (hs : handles) ch (m1 mi1 m2 mi2 : smap)
                    (mh2 mhi2 : hsmap) (ro : (block list,block) fmap) pi =
  | HCF_G1 of (eqm_handles hs m1 mh2)
            & (eqm_handles hs mi1 mhi2)
            & (incl m2 m1)
            & (incl mi2 mi1)
            & (mh_spec hs m2 mh2 ro)
            & (paths_spec hs mh2 pi)
            & (handles_spec hs ch).

lemma eqm_of_INV (ch : handle)
                 (mi1 m2 mi2 : smap) (mhi2 : hsmap)
                 (ro : (block list, block) fmap)
                 (pi : (capacity, block list * block) fmap)
                 hs m1 mh2:
  INV_CF_G1 hs ch m1 mi1 m2 mi2 mh2 mhi2 ro pi =>
  eqm_handles hs m1 mh2.
proof. by case. qed.

lemma eqmi_of_INV (ch : handle)
                  (m1 m2 mi2 : smap) (mh2 : hsmap)
                  (ro : (block list, block) fmap)
                  (pi : (capacity, block list * block) fmap)
                  hs mi1 mhi2:
  INV_CF_G1 hs ch m1 mi1 m2 mi2 mh2 mhi2 ro pi =>
  eqm_handles hs mi1 mhi2.
proof. by case. qed.

lemma incl_of_INV (hs : handles) (ch : handle)
                  (mi1 mi2 : smap) (mh2 mhi2: hsmap)
                  (ro : (block list, block) fmap)
                  (pi : (capacity, block list * block) fmap)
                  m1 m2:
  INV_CF_G1 hs ch m1 mi1 m2 mi2 mh2 mhi2 ro pi =>
  incl m2 m1.
proof. by case. qed.

lemma incli_of_INV (hs : handles) (ch : handle)
                   (m1 m2 : smap) (mh2 mhi2: hsmap)
                   (ro : (block list, block) fmap)
                   (pi : (capacity, block list * block) fmap)
                   mi1 mi2:
  INV_CF_G1 hs ch m1 mi1 m2 mi2 mh2 mhi2 ro pi =>
  incl mi2 mi1.
proof. by case. qed.

lemma mh_of_INV (ch : handle)
                (m1 mi1 mi2 : smap) (mhi2 : hsmap)
                (pi : (capacity, block list * block) fmap)
                hs m2 mh2 ro:
  INV_CF_G1 hs ch m1 mi1 m2 mi2 mh2 mhi2 ro pi =>
  mh_spec hs m2 mh2 ro.
proof. by case. qed.

lemma paths_of_INV (ch : handle)
                   (m1 m2 mi1 mi2: smap) (mhi2: hsmap)
                   (ro : (block list, block) fmap)
                   hs mh2 pi:
  INV_CF_G1 hs ch m1 mi1 m2 mi2 mh2 mhi2 ro pi =>
  paths_spec hs mh2 pi.
proof. by case. qed.

lemma handles_of_INV (m1 m2 mi1 mi2 : smap) (mh2 mhi2 : hsmap)
                     (ro : (block list, block) fmap)
                     (pi : (capacity, block list * block) fmap)
                     hs ch:
  INV_CF_G1 hs ch m1 mi1 m2 mi2 mh2 mhi2 ro pi =>
  handles_spec hs ch.
proof. by case. qed.

(** ?? **)
lemma eqm_dom_mh_m hs m mh hx2 f (x:state):
  eqm_handles hs m mh =>
  hs.[hx2] = Some (x.`2, f) =>
  mem (dom mh) (x.`1, hx2) => mem (dom m) x.
proof.
move=>[]H1 H2 Hhx2;rewrite !in_dom.
case: (mh.[_]) (H2 x.`1 hx2) => //= -[] b' h' /(_ b' h') [c c' f1 f1'].
by rewrite Hhx2=> /= -[][]<<- _;case:(x)=> ??[]_->.
qed.

lemma chandle_ge0 hs ch : handles_spec hs ch => 0 < ch.
proof. by case=> _ Heq Hlt; apply Hlt; rewrite in_dom Heq. qed.

lemma chandle_0 hs ch : handles_spec hs ch => 0 <> ch.
proof. by move=> Hh;apply/ltr_eqF/(@chandle_ge0 _ _ Hh). qed.

(** Adding handles **)
lemma eqm_up_handles hs ch m mh x2 :
   handles_spec hs ch =>
   eqm_handles hs m mh =>
   eqm_handles hs.[ch <- (x2, Known)] m mh.
proof.
case=> Hu Hh0 Hlt [] m_some mh_some; split.
+ move=> xb xc xb' xc' /m_some [h h' f f'] [#] Hh Hh' Hmh.
  exists h h' f f'; rewrite !getP Hmh -Hh -Hh' /=.
  rewrite ltr_eqF /=; 1:by apply/Hlt; rewrite in_dom Hh.
  by rewrite ltr_eqF; 1:by apply/Hlt; rewrite in_dom Hh'.
move=> xb xh xb' xh' /mh_some [c c' f f'] [#] Hh Hh' Hm.
exists c c' f f'; rewrite !getP Hm -Hh -Hh'.
rewrite ltr_eqF /=; 1:by apply/Hlt; rewrite in_dom Hh.
by rewrite ltr_eqF; 1:by apply/Hlt; rewrite in_dom Hh'.
qed.

lemma mh_up_handles hs ch m2 mh ro cf:
   handles_spec hs ch =>
   mh_spec hs m2 mh ro =>
   mh_spec hs.[ch <- cf] m2 mh ro.
proof.
move=> + [] mh_some ?=> -[] _ _ Hlt; split=> // b h b' h' /mh_some [c c' f f'] [#] Hh Hh' Hif.
exists c c' f f'; rewrite Hif -Hh -Hh' !getP.
rewrite ltr_eqF /=; 1:by apply/Hlt; rewrite in_dom Hh.
by rewrite ltr_eqF; 1:by apply/Hlt; rewrite in_dom Hh'.
qed.

lemma paths_up_handles m2 ro hs mh pi cf ch:
  mh_spec hs m2 mh ro =>
  handles_spec hs ch =>
  paths_spec hs mh pi =>
  paths_spec hs.[ch <- cf] mh pi.
proof.
move=> Hmh Hh [] Hp; split=> c p v; rewrite Hp; apply exists_iff=> x /=.
split=>- [] ^Hbu -> /=; rewrite getP.
+ case: Hh=> _ _ Hlt x_in_handles.
  by rewrite ltr_eqF; 1:by apply/Hlt; rewrite in_dom x_in_handles.
case: (x = ch)=> //=.
move: Hbu=> /build_hpathP [[#] _ _ ->|p' b v' h' [#] _ _ Hh'].
+ by rewrite (@chandle_0 _ _ Hh).
case: Hh=> _ _ /(_ x) Hlt; rewrite ltr_eqF //.
by apply/Hlt; rewrite in_dom; case: Hmh=> /(_ _ _ _ _ Hh') [????] [#] _ ->.
qed.

lemma handles_up_handles hs ch x2 f':
  (forall (f : flag), ! mem (rng hs) (x2, f)) =>
  handles_spec hs ch =>
  handles_spec hs.[ch <- (x2, f')] (ch + 1).
proof.
move=> Hx2 ^Hh [] Hu Hh0 Hlt; split.
+ move=> h1 h2 [c1 f1] [c2 f2]; rewrite !getP /=.
  case: (h1 = ch)=> /= [-> [] ->> ->|_]; (case: (h2 = ch)=> [-> //= |_]).
  + by move=> Heq ->>; move: (Hx2 f2); rewrite in_rng negb_exists=> /= /(_ h2).
  + by move=> Heq [] ->> <<- ->>; move: (Hx2 f1);  rewrite in_rng negb_exists=> /= /(_ h1).
  by apply Hu.
+ by rewrite getP (@chandle_0 _ _ Hh).
by move=> h; rewrite dom_set !inE /#.
qed.

(* lemma INV_CF_G1_up_handles hs ch m1 mi1 m2 mi2 mh mhi ro pi x2: *)
(*    INV_CF_G1 hs ch m1 mi1 m2 mi2 mh mhi ro pi => *)
(*    (forall f, !mem (rng hs) (x2, f)) => *)
(*    INV_CF_G1 hs.[ch <- (x2, Known)] (ch + 1) m1 mi1 m2 mi2 mh mhi ro pi. *)
(* proof. *)
(* case=> Heqm Heqmi Hincl Hincli Hmh Hp Hh Hx2. *)
(* exact/(HCF_G1 (eqm_up_handles Hh Heqm) (eqm_up_handles Hh Heqmi) *)
(*               _ _ *)
(*               (:@mh_up_handles _ _ _ _ _ (x2,Known) Hh Hmh) *)
(*               (:@paths_up_handles m2 ro _ _ _ (x2,Known) _ Hmh Hh Hp) *)
(*               (:@handles_up_handles _ _ x2 Known _ Hh)). *)
(* qed. *)

(** Updating forward map **)
lemma eqm_handles_up (hs : handles) m mh (h hx:handle) (x y : state) f:
  huniq hs =>
  hs.[h]  = None =>
  hs.[hx] = Some (x.`2, f) =>
  eqm_handles hs m mh =>
  eqm_handles hs.[h <- (y.`2,Known)] m.[x <- y] mh.[(x.`1,hx) <- (y.`1,h)].
proof.
move=> uniq_h h_h h_hx @/eqm_handles [] hmmh hmhm; split.
+ move=> b c b' c'; rewrite getP; case ((b,c) = x)=> /= [<<- ->> {x y} /=|].
  * by exists hx f h Known; rewrite !getP /= [smt (in_dom)].
  move=> bc_neq_x /hmmh [] h0 f0 h0' f0' [#] h_h0 h_h0' mhi_bc.
  by exists h0 f0 h0' f0'; rewrite !getP [smt (in_dom)].
move=> xb xh b' h'; rewrite getP; case ((xb,xh) = (x.`1,hx))=> /= [[#] <*> [#] <*>|].
  * by exists x.`2 f y.`2 Known; rewrite !getP [smt (in_dom)].
rewrite anda_and negb_and=> bh_neq_x1hx /hmhm /= [] c0 f0 c0' f0' [#] h_h0 h_bh' m_bc.
exists c0 f0 c0' f0'; rewrite !getP.
split; 1:smt (in_dom).
split; 1:smt (in_dom).
case x bh_neq_x1hx h_hx=> x1 x2 /= => - [/#|h0_neq_hx h_hx].
have -> //=: c0 <> x2; move: h0_neq_hx; apply/contra.
exact/(@uniq_h _ _ _ _ h_h0 h_hx).
qed.

(** Updating backward map **)
lemma eqmi_handles_up (hs : handles) mi mhi (h hx : handle) (x y : state) f:
  (!exists f', mem (rng hs) (y.`2,f')) =>
  hs.[h]  = None =>
  hs.[hx] = Some (x.`2, f) =>
  eqm_handles hs mi mhi =>
  eqm_handles hs.[h <- (y.`2,Known)] mi.[y <- x] mhi.[(y.`1,h) <- (x.`1,hx)].
proof.
move=> y_notinr1_handles h_h h_hx @/eqm_handles [] hmmh hmhm; split.
+ move=> xb xc xb' xc'; rewrite getP; case ((xb,xc) = y)=> /= [<<- ->> {x y}|].
  * by exists h Known hx f; rewrite !getP /= [smt (in_dom)].
  move=> bc_neq_y /hmmh [] h0 f0 h0' f0' [#] h_h0 h_h0' mhi_bc.
  by exists h0 f0 h0' f0'; rewrite !getP [smt (in_dom)].
move=> xb xh xb' xh'; rewrite getP; case ((xb,xh) = (y.`1,h))=> /= [[#] <*> [#] <*>|].
  * by exists y.`2 Known x.`2 f; rewrite !getP [smt (in_dom)].
rewrite anda_and negb_and=> bh_neq_y1h /hmhm /= [] c0 f0 c0' f0' [#] h_bh h_bh' mi_bh.
exists c0 f0 c0' f0'; rewrite !getP.
split; 1:smt (in_dom).
split; 1:smt (in_dom).
case y bh_neq_y1h y_notinr1_handles=> y1 y2 /= [/#|h0_neq_h y_notinr1_handles].
have /#: c0 = y2 => false; move=> /(congr1 (fun x=> exists f', mem (rng hs) (x,f'))) /=.
rewrite y_notinr1_handles /= neqF /=; exists f0.
by rewrite in_rng; exists xh.
qed.

lemma incl_set (m m' : ('a,'b) fmap) x y:
  incl m m' =>
  incl m.[x <- y] m'.[x <- y].
proof. smt (in_dom getP). qed.

lemma hinv_notin_rng m y2:
  SLCommon.hinv m y2 = None =>
  (forall h f, m.[h] <> Some (y2,f)).
proof. by move=> hinv_none; have:= hinvP m y2; rewrite hinv_none. qed.

lemma handles_spec_notin_dom m h:
  handles_spec m h =>
  !mem (dom m) h.
proof. case; smt (in_dom). qed.

lemma neq_Known f: f <> Known <=> f = Unknown.
proof. by case f. qed.

lemma neq_Unkwown f: f <> Unknown <=> f = Known.
proof. by case f. qed.

op getflag (hs : handles) xc =
  omap snd (obind ("_.[_]" hs) (hinv hs xc)).

lemma getflagP_none hs xc:
  (getflag hs xc = None <=> forall f, !mem (rng hs) (xc,f)).
proof.
rewrite /getflag; case: (hinvP hs xc)=> [->|] //=.
+ smt (in_rng).
smt (in_rng).
qed.

lemma getflagP_some hs xc f:
  huniq hs =>
  (getflag hs xc = Some f <=> mem (rng hs) (xc,f)).
proof.
move=> huniq_hs; split.
+ rewrite /getflag; case: (hinvP hs xc)=> [-> //|].
  rewrite in_rng; case: (hinv hs xc)=> //= h [f'].
  rewrite oget_some=> ^ hs_h -> @/snd /= ->>.
  by exists h.
rewrite in_rng=> -[h] hs_h.
move: (hinvP hs xc)=> [_ /(_ h f) //|].
rewrite /getflag; case: (hinv hs xc)=> // h' _ [f']; rewrite oget_some.
move=> /(huniq_hs _ h _ (xc,f)) /(_ hs_h) /= ->>.
by rewrite hs_h.
qed.

lemma paths_prefix handles m2 mh ro paths c b p v:
  mh_spec handles m2 mh ro =>
  paths_spec handles mh paths =>
  paths.[c] = Some (rcons p b,v) =>
  (exists c' v', paths.[c'] = Some (p,v')).
proof.
move=> [] mh_some _ [] hpaths ^paths_c.
move=> /hpaths [h] [#] /build_hpathP [/#|] p' b' v' h' [#] ^/rconsIs + /rconssI- <*>.
move=> hpath + handles_h - /mh_some /= [c' c0 f' f]; rewrite handles_h /= => /> handles_h' _.
by exists c' v'; rewrite hpaths; exists h'.
qed.

lemma build_hpath_prefix mh p b v h:
  build_hpath mh (rcons p b) = Some (v,h) <=>
  (exists v' h', build_hpath mh p = Some (v',h') /\ mh.[(v' +^ b,h')] = Some (v,h)).
proof.
rewrite build_hpathP; split=> [[/#|p' b' v' h' [#] + Hhpath Hmh]|[v' h'] [] Hhpath Hmh].
+ by move=> ^/rconsIs <<- {b'} /rconssI <<- {p'}; exists v' h'.
exact/(Extend _ _ _ _ _ Hhpath Hmh).
qed.

lemma iter_step_path_from_None mh p: foldl (step_hpath mh) None p = None.
proof. by elim: p. qed.

lemma build_hpath_up mh xc xh yc yh p b h:
  !mem (dom mh) (xc,xh) =>
  build_hpath mh p = Some (b,h) =>
  build_hpath mh.[(xc,xh) <- (yc,yh)] p = Some (b,h).
proof.
move=> xch_notin_mh @/build_hpath.
have: (exists p' v h, build_hpath mh p' = Some (v +^ b0,h)).
+ by exists [] b0 0; rewrite build_hpathP Block.xorw0; exact/Empty.
pose root:= b0; elim: p root 0=> //= b1 p ih bn hn.
rewrite /(step_hpath _ (Some _)) /= oget_some /= /(step_hpath _ (Some _)) /= oget_some /= getP.
case: (mem (dom mh) (bn +^ b1,hn))=> [bnb1hn_in_mh extend_path|].
+ have -> /= : (bn +^ b1,hn) <> (xc,xh).
  + apply/contraT=> /(congr1 (mem (dom mh)) (bn +^ b1,hn) (xc,xh)).
    by rewrite xch_notin_mh bnb1hn_in_mh.
  case: {-1}(mh.[(bn +^ b1,hn)]) (eq_refl (mh.[(bn +^ b1,hn)]))=> //=.
  + smt. (* figure out *)
  move=> [] b2 h2 mh_bnb1hn.
  apply/(@ih b2 h2).
  case: extend_path=> p' v hp' build_path.
  by exists p' (v +^ bn +^ b2) hp'; rewrite build_path //= #ring.
by rewrite in_dom /= => mh_bnb1hn _; rewrite mh_bnb1hn iter_step_path_from_None.
qed.

lemma build_hpath_down mh xc xh yc yh p v h:
     xh <> 0
  => (forall c' h' xc', mh.[(c',h')] <> Some (xc',xh))
  => build_hpath mh.[(xc,xh) <- (yc,yh)] p = Some (v,h)
  => build_hpath mh p = Some (v,h).
proof.
move=> xh_neq_0 xh_notin_rng2_mh.
elim/last_ind: p v h=> [v h /build_hpathP [<*>|/#] //=|p b ih].
move=> v h /build_hpathP [/#|p' b' + + ^/rconsIs <<- /rconssI <<-].
move=> v' h' /ih; rewrite getP.
case: ((v' +^ b,h') = (xc,xh))=> [[#] <*> + [#] <*>|_ Hpath Hmh].
+ by move=> /build_hpathP [/#|] /#.
exact/build_hpathP/(Extend _ _ _ _ _ Hpath Hmh).
qed.

lemma INV_CF_G1_notin_PFm_notin_G1m hs ch PFm PFmi G1m G1mi G1mh G1mhi ro pi x:
  INV_CF_G1 hs ch PFm PFmi G1m G1mi G1mh G1mhi ro pi =>
  PFm.[x] = None =>
  G1m.[x] = None.
proof. by move=> /incl_of_INV G1m_le_PFm; apply/contraLR=> ^h; rewrite G1m_le_PFm. qed.

lemma INV_CF_G1_0 hs PFm PFmi G1m G1mi G1mh G1mhi ro pi:
  !INV_CF_G1 hs 0 PFm PFmi G1m G1mi G1mh G1mhi ro pi.
proof.
rewrite -negP=> -[] _ _ _ _ _ _ [] _ + /(_ 0) /=.
by rewrite in_dom=> ->.
qed.

(** Clean this up and tidy intermediate results, more particularly
    anything that is derived from individual components of INV_CF_G1 **)
lemma lemma1 hs ch PFm PFmi G1m G1mi G1mh G1mhi ro (pi : (capacity,block list * block) fmap) x1 x2 y1 y2:
  x2 <> y2 =>
  PFm.[(x1,x2)] = None =>
  G1m.[(x1,x2)] = None =>
  pi.[x2] = None =>
  (forall f, !mem (rng hs) (x2,f)) =>
  (forall f, !mem (rng hs) (y2,f)) =>
  INV_CF_G1 hs ch PFm PFmi G1m G1mi G1mh G1mhi ro pi =>
  INV_CF_G1 hs.[ch <- (x2,Known)].[ch + 1 <- (y2,Known)] (ch + 2)
            PFm.[(x1,x2) <- (y1,y2)] PFmi.[(y1,y2) <- (x1,x2)]
            G1m.[(x1,x2) <- (y1,y2)] G1mi.[(y1,y2) <- (x1,x2)]
            G1mh.[(x1,ch) <- (y1,ch + 1)] G1mhi.[(y1,ch + 1) <- (x1,ch)]
            ro pi.
proof.
move=> x2_neq_y2 PFm_x G1m_x pi_x2 x2_notin_hs y2_notin_hs Hinv; split.
+ apply/(@eqm_handles_up hs.[ch <- (x2,Known)] PFm G1mh (ch + 1) ch (x1,x2) (y1,y2) Known).
  + move=> @/huniq h1 h2 [c1 f1] [c2 f2]; rewrite !getP /=.
    case: (h1 = ch); case: (h2 = ch)=> //=.
    + move=> + + [#] - + <*>.
      by move: (x2_notin_hs f2); rewrite in_rng negb_exists /= => ->.
    + move=> <*> + + [#] <*>.
      by move: (x2_notin_hs f1); rewrite in_rng negb_exists /= => ->.
    case: Hinv=> _ _ _ _ _ _ [] + _ _ _ _ - h.
    exact/(@h h1 h2 (c1,f1) (c2,f2)).
  + by rewrite getP; case: Hinv=> _ _ _ _ _ _ []; smt (in_dom).
  + by rewrite getP.
  by apply/eqm_up_handles; case: Hinv.
+ apply/(@eqmi_handles_up hs.[ch <- (x2,Known)] PFmi G1mhi (ch + 1) ch (x1,x2) (y1,y2) Known).
  + rewrite negb_exists /= => f; rewrite in_rng negb_exists /= => h.
    rewrite getP; case: (h = ch)=> _; first by rewrite /= x2_neq_y2.
    by move: (y2_notin_hs f); rewrite in_rng negb_exists /= => ->.
  + by rewrite getP; case: Hinv=> _ _ _ _ _ _ []; smt (in_dom).
  + by rewrite getP.
  by apply/eqm_up_handles; case: Hinv.
+ move=> z; rewrite !getP; case: (z = (x1,x2))=> //= _.
  by case: Hinv=> _ _ + _ _ _ _ - @/incl /(_ z).
+ move=> z; rewrite !getP; case: (z = (y1,y2))=> //= _.
  by case: Hinv=> _ _ _ + - @/incl /(_ z).
+ split.
  + move=> xa xh ya yh; rewrite getP; case: ((xa,xh) = (x1,ch)).
    + move=> /= [#] <*> [#] <*>; exists x2 Known y2 Known=> //=.
      by rewrite !getP /#.
    rewrite /= anda_and negb_and=> h hG1mh. (* This one needs cleaned up in priority. These are things that should be deduced instantly. *)
    have := Hinv=>- [] _ _ _ _ [] + _ _ _ - h0.
    have [xc xf yc yf] [#] hs_xh hs_yh ite:= h0 _ _ _ _ hG1mh.
    have yh_lt_ch: xh < ch by case: Hinv=> _ _ _ _ _ _ [] _ _ -> //; rewrite in_dom hs_xh.
    have xh_lt_ch: yh < ch by case: Hinv=> _ _ _ _ _ _ [] _ _ -> //; rewrite in_dom hs_yh.
    exists xc xf yc yf.
    split; first by smt (getP).
    split; first by smt (getP).
    split=> /=.
    + by move: ite=> <*> /= [#] hG1m -> //=; rewrite getP; case: ((xa,xc) = (x1,x2))=> [<*> /#|].
    move: ite=> + hrw; move: hrw=> -> /= [p v] [#] ro_pv hpath.
    exists p v; rewrite ro_pv /=.
    apply/build_hpath_up=> //=; case: Hinv=> _ _ _ _ _ _ [] _ _ hh.
    rewrite -negP in_dom; case: {-1}(G1mh.[(x1,ch)]) (eq_refl (G1mh.[(x1,ch)]))=> [//=|[xa' xh']].
    move=> /h0 [xc0 xf0 ? ?] [] + _.
    by move: (hh ch)=> /=; rewrite in_dom /= => ->.
  (* These two are going to be painful: -> are easy. <- rely on the fact that neither x not y had an associated handle, and therefore cannot be involved in a path. This is crucial. Maybe some other permutation of the goals/invariant's conjuncts would help clarify. *)
  + move=> p xa b; have:= Hinv=>- [] _ _ _ _ [] _ -> _ _.
    apply/exists_iff=> v /=; apply/exists_iff=> xh /=; apply/exists_iff=> yh /=.
    have G1mh_x1ch: G1mh.[(x1,ch)] = None.
    + have /# : forall x1' xh', G1mh.[(x1,ch)] <> Some (x1',xh').
      move=> x1' xh'; rewrite -negP=> G1mh_xh'.
      have [] [] _ ht _ _ _ _ _ _ := Hinv.
      move: (ht _ _ _ _ G1mh_xh')=> [xc xf yc yf] [#] + _ _ {ht}.
      have [] _ _ _ _ _ _ [] _ _ /(_ ch):= Hinv.
      by rewrite in_dom=> /= ->.
    have ch_notin_G1mh: forall cx, !mem (rng G1mh) (cx,ch).
    + move=> cx; rewrite in_rng negb_exists=> - [b0 h0] /=; rewrite -negP=> G1mh_cxch.
      by case: Hinv=> - [] _ + _ _ _ _ _ [] _ _ + - /(_ _ _ _ _ G1mh_cxch) [xc xf yc yf] [#] _ hs_ch _ /(_ ch) /=; rewrite in_dom hs_ch.
    split=> -[#].
    + move=> hpath hG1mh.
      rewrite getP; case: ((v +^ xa,xh) = (x1,ch))=> [/#|_].
      rewrite hG1mh //=.
      by apply/build_hpath_up=> //=; rewrite in_dom G1mh_x1ch.
    (* The following case should be built into the lemma (build_hpath_down) *)
    rewrite getP; case: ((v +^ xa,xh) = (x1,ch))=> [[#] <*> + [#] <*>|].
    + have ht /ht {ht} /= := (build_hpath_down G1mh (v +^ xa) ch b (ch + 1) p v ch _ _).
      + by case: Hinv=> _ _ _ _ _ _ [] _ + +; smt (in_dom).
      + move=> c' h' xc'; move: (ch_notin_G1mh xc').
        by rewrite in_rng negb_exists /= => ->.
      move=> /build_hpathP [<*>|p' b' v' h' <*>]; first by rewrite INV_CF_G1_0 in Hinv; smt ().
      by move: (ch_notin_G1mh v); rewrite in_rng negb_exists /= => ->.
    move=> _.
    have ht /ht {ht} /= -> //= := build_hpath_down G1mh x1 ch y1 (ch + 1) p v xh _ _.
    + by case: Hinv=> _ _ _ _ _ _ [] _ + +; smt (in_dom).
    by move=> c' h' xc'; move: (ch_notin_G1mh xc'); rewrite in_rng negb_exists /= => ->.
+ split=> c p v; have [] _ _ _ _ _ [] -> _ := Hinv.
  apply/exists_iff=> h /=; split=> [#].
    have ht /ht {ht} -> /= := build_hpath_up G1mh x1 ch y1 (ch +1) p v h _.
    + rewrite in_dom /=; case: {-1}(G1mh.[(x1,ch)]) (eq_refl (G1mh.[(x1,ch)]))=> [|[x1' xh'] G1mh_x1'xh'] //=.
      case: Hinv=> - [] _ /(_ _ _ _ _ G1mh_x1'xh') [xc xf ct ft] [#] hs_ch _ _ _ _ _ _ _ [] _ _ /(_ ch) /=.
      by rewrite in_dom hs_ch.
    move=> hs_h; rewrite !getP hs_h.
    have /#: h < ch.
    by case: Hinv=> _ _ _ _ _ _ [] _ _ /(_ h); rewrite in_dom hs_h.
  have ch_notin_G1mh: forall cx, !mem (rng G1mh) (cx,ch).
  + move=> cx; rewrite in_rng negb_exists=> - [b0 h0] /=; rewrite -negP=> G1mh_cxch.
    by case: Hinv=> - [] _ + _ _ _ _ _ [] _ _ + - /(_ _ _ _ _ G1mh_cxch) [xc xf yc yf] [#] _ hs_ch _ /(_ ch) /=; rewrite in_dom hs_ch.
  have Sch_notin_G1mh: forall cx, !mem (rng G1mh) (cx,ch + 1).
  + move=> cx; rewrite in_rng negb_exists=> - [b0 h0] /=; rewrite -negP=> G1mh_cxch.
    by case: Hinv=> - [] _ + _ _ _ _ _ [] _ _ + - /(_ _ _ _ _ G1mh_cxch) [xc xf yc yf] [#] _ hs_ch _ /(_ (ch + 1)) /=; rewrite in_dom hs_ch /#.
  have ht /ht {ht} /= := build_hpath_down G1mh x1 ch y1 (ch + 1) p v h _ _.
  + by case: Hinv=> _ _ _ _ _ _ [] _ + +; smt (in_dom).
  + by move=> c' h' xc'; move: (ch_notin_G1mh xc'); rewrite in_rng negb_exists /= => ->.
  move=> Hpath; rewrite Hpath /=.
  have: h <> ch /\ h <> ch + 1; last by smt (getP).
  case: (h = 0)=> [<*>|].
  + by case: Hinv=> _ _ _ _ _ _ [] _ + /(_ 0) //=; rewrite in_dom=> /#.
  move=> h_neq_0; move: Hpath=> /build_hpathP [<*> /#|p' b' v' h' <*> _].
  move: (ch_notin_G1mh v); rewrite in_rng negb_exists /= => /(_ (v' +^ b',h')).
  move: (Sch_notin_G1mh v); rewrite in_rng negb_exists /= => /(_ (v' +^ b',h')).
  smt ().
have ->: ch + 2 = ch + 1 + 1 by rewrite -addzA.
apply/(@handles_up_handles hs.[ch <- (x2,Known)] (ch + 1) y2 Known).
+ move=> f; rewrite in_rng negb_exists /= => h; rewrite !getP.
  case: (h = ch)=> [<*> /=|_]; first by rewrite x2_neq_y2.
  by move: (y2_notin_hs f); rewrite in_rng negb_exists /= => ->.
by apply/handles_up_handles=> //=; case: Hinv.
qed.

lemma lemma2 hs ch PFm PFmi G1m G1mi G1mh G1mhi ro pi x1 x2 y1 y2 hx:
  INV_CF_G1 hs ch PFm PFmi G1m G1mi G1mh G1mhi ro pi =>
  PFm.[(x1,x2)] = None =>
  G1m.[(x1,x2)] = None =>
  pi.[x2] = None =>
  hs.[hx] = Some (x2,Known) =>
  hinv hs y2 = None =>
  INV_CF_G1 hs.[ch <- (y2,Known)] (ch + 1)
            PFm.[(x1,x2) <- (y1,y2)] PFmi.[(y1,y2) <- (x1,x2)]
            G1m.[(x1,x2) <- (y1,y2)] G1mi.[(y1,y2) <- (x1,x2)]
            G1mh.[(x1,hx) <- (y1,ch)] G1mhi.[(y1,ch) <- (x1,hx)]
            ro pi.
proof.
move=> Hinv x1x2_notin_PFm x1x2_notin_G1m x2_notin_pi hs_hx y2_notinrng_hs.
split.
+ apply/(@eqm_handles_up _ _ _ _ _ (x1,x2) (y1,y2) Known).
  + by case: Hinv=> _ _ _ _ _ _ [].
  + by case: Hinv=> _ _ _ _ _ _ []; smt (in_dom).
  + by rewrite hs_hx.
  + by case: Hinv.
+ apply/(@eqmi_handles_up _ _ _ _ _ (x1,x2) (y1,y2) Known).
  + move: y2_notinrng_hs=> /hinv_notin_rng y2_notinrng_hs.
    rewrite negb_exists /= => f; rewrite in_rng negb_exists /= => h.
    by rewrite y2_notinrng_hs.
  + by case: Hinv=> _ _ _ _ _ _ []; smt (in_dom).
  + by rewrite hs_hx.
  + by case: Hinv.
+ move=> [xa xc]; rewrite !getP; case: ((xa,xc) = (x1,x2))=> //= _ h.
  by case: Hinv=> _ _ ->.
+ move=> [xa xc]; rewrite !getP; case: ((xa,xc) = (y1,y2))=> //= _ h.
  by case: Hinv=> _ _ _ ->.
+ split.
  + move=> xa xh ya yh; rewrite getP; case: ((xa,xh) = (x1,hx))=> [[#] <*>> [#] <<*> /=|].
    + exists x2 Known y2 Known=> //=; rewrite !getP hs_hx /=.
      by case: Hinv=> _ _ _ _ _ _ []; smt (in_dom).
    move=> xaxh_neq_x1hx mh_xaxh.
    have [] _ _ _ _ [] + _ _ _ - /(_ _ _ _ _ mh_xaxh):= Hinv.
    move=> [xc xf yc] [] /= - [#] hs_xh hs_yh h.
    + exists xc xf yc Unknown=> /=; rewrite !getP hs_xh hs_yh.
      split; first by case: Hinv=> _ _ _ _ _ _ []; smt (in_dom).
      split; first by case: Hinv=> _ _ _ _ _ _ []; smt (in_dom).
      elim: h=> p v [#] Hro Hpath; exists p v; rewrite Hro /=.
      apply/build_hpath_up=> //=.
      rewrite in_dom -negP; case: {-1}(G1mh.[(x1,hx)]) (eq_refl G1mh.[(x1,hx)])=> [//=|[x' hx'] mh_x1hx].
      have [] [] _ /(_ _ _ _ _ mh_x1hx) + _ _ _ _ _ _:= Hinv.
      by move=> [xc0 xf0 yc0 yf0] [#] <<*>; rewrite hs_hx => [#] <<*>; rewrite x1x2_notin_PFm.
    move=> ->> {xf} /=; exists xc Known yc Known=> //=.
    rewrite !getP.
    have -> //=: (xa,xc) <> (x1,x2).
    + move: xaxh_neq_x1hx; apply/contra=> [#] <*>> /=.
      by case: Hinv=> _ _ _ _ _ _ [] /(_ xh hx _ _ hs_xh hs_hx).
    by rewrite h; case: Hinv=> _ _ _ _ _ _ []; smt (in_dom).
  move=> p xa b; have [] _ _ _ _ [] _ -> _ _ := Hinv.
  apply/exists_iff=> v /=; apply/exists_iff=> xh /=; apply/exists_iff=> yh /=.
  split=> -[#].
  + move=> hpath hG1mh; rewrite getP; case: ((v +^ xa,xh) = (x1,hx))=> [[#] <<*>|_].
    + have [] [] _ + _ _ _ _ _ _ -/(_ _ _ _ _ hG1mh):= Hinv.
      by move=> [xc xf yc yf] [#]; rewrite hs_hx /= => [#] <<*>; rewrite x1x2_notin_PFm.
    rewrite hG1mh //=.
    apply/build_hpath_up=> //=; rewrite in_dom.
    case: {-1}(G1mh.[(x1,hx)]) (eq_refl G1mh.[(x1,hx)])=> [//|[xa' xc'] G1mh_xaxc'].
    have [] [] _ /(_ _ _ _ _ G1mh_xaxc') + _ _ _ _ _ _:= Hinv.
    by move=> [xc xf yc yf] [#]; rewrite hs_hx=> [#] <<*>; rewrite x1x2_notin_PFm.
  rewrite getP; case: ((v +^ xa,xh) = (x1,hx))=> [[#] <*> + [#] <*>|].
  + move=> /build_hpathP [<*> /=|].
    + have [] _ _ _ _ _ _ [] _ + _:= Hinv.
      rewrite hs_hx => /= [#] <*>.
      have [] _ _ _ _ _ [] /(_ c0 [] b0) /iffRL + _ := Hinv.
      move=> /(_ _); 1:by exists 0=> /#.
      by rewrite x2_notin_pi.
    move=> p' b' v' h' ->> Hpath Hextend; split.
    + apply/build_hpathP/(@Extend G1mh (rcons p' b') v hx p' b' v' h')=> //.
admitted.

clone export ConcreteF as ConcreteF1.

section AUX.

  declare module D : DISTINGUISHER {PF, RO, G1}.

  axiom D_ll (F <: DFUNCTIONALITY{D}) (P <: DPRIMITIVE{D}):
    islossless P.f => islossless P.fi => islossless F.f => 
    islossless D(F, P).distinguish.

  equiv CF_G1 : CF(D).main ~ G1(D).main: 
                 ={glob D} ==> !(G1.bcol \/ G1.bext){2} => ={res}.
  proof.               
  proc.
  call (_: G1.bcol \/ G1.bext,
           INV_CF_G1 FRO.m{2} G1.chandle{2} PF.m{1} PF.mi{1}
                     G1.m{2} G1.mi{2} G1.mh{2} G1.mhi{2} F.RO.m{2} G1.paths{2}).
  (* lossless D *)
  + exact/D_ll.
  (** proofs for G1.S.f *)
  (* equivalence up to bad of PF.f and G1.S.f *)
  + conseq (_:    !G1.bcol{2}
               /\ !G1.bext{2}
               /\ ={x}
               /\ INV_CF_G1 FRO.m{2} G1.chandle{2}
                            PF.m{1} PF.mi{1}
                            G1.m{2} G1.mi{2} G1.mh{2} G1.mhi{2}
                            F.RO.m{2} G1.paths{2}
           ==>    !G1.bcol{2}
               => !G1.bext{2}
               => ={res}
               /\ INV_CF_G1 FRO.m{2} G1.chandle{2}
                            PF.m{1} PF.mi{1}
                            G1.m{2} G1.mi{2} G1.mh{2} G1.mhi{2}
                            F.RO.m{2} G1.paths{2}).
    + by move=> &1 &2; rewrite negb_or.
    + by move=> &1 &2 _ ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? [#]; rewrite negb_or.
    (* For now, everything is completely directed by the syntax of
    programs, so we can *try* to identify general principles of that
    weird data structure and of its invariant. I'm not sure we'll ever
    be able to do that, though. *)
    (* We want to name everything for now, to make it easier to manage complexity *)
    exists * FRO.m{2}, G1.chandle{2},
             PF.m{1}, PF.mi{1},
             G1.m{2}, G1.mi{2}, G1.mh{2}, G1.mhi{2},
             F.RO.m{2}, G1.paths{2},
             x{2}.
    elim * => hs0 ch0 PFm PFmi G1m G1mi G1mh G1mhi ro0 pi0 [] x1 x2.
    (* poor man's extraction of a fact from a precondition *)
    case @[ambient]: {-1}(INV_CF_G1 hs0 ch0 PFm PFmi G1m G1mi G1mh G1mhi ro0 pi0)
                     (eq_refl (INV_CF_G1 hs0 ch0 PFm PFmi G1m G1mi G1mh G1mhi ro0 pi0)); last first.
    + by move=> h; exfalso=> &1 &2 [#] <*>; rewrite h.
    move=> /eqT inv0; proc; case @[ambient] {-1}(PFm.[(x1,x2)]) (eq_refl (PFm.[(x1,x2)])).
    + move=> x1x2_notin_PFm.
      move: (INV_CF_G1_notin_PFm_notin_G1m _ _ _ _ _ _ _ _ _ _ _ inv0 x1x2_notin_PFm).
      move=> x1x2_notin_G1m.
      rcondt{1} 1; 1:by move=> //= &1; skip=> &2 [#] <*>; rewrite in_dom x1x2_notin_PFm.
      rcondt{2} 1; 1:by move=> //= &1; skip=> &2 [#] <*>; rewrite in_dom x1x2_notin_G1m.
      case @[ambient]: {-1}(pi0.[x2]) (eq_refl (pi0.[x2])).
      + move=> x2_in_pi; rcondf{2} 1.
        + by move=> //= &1; skip=> &2 [#] <*>; rewrite in_dom x2_in_pi.
        rcondf{2} 8.
        + by move=> //= &1; auto=> &2 [#] !<<-; rewrite !in_dom x2_in_pi.
        seq  2  2: (   hs0 = FRO.m{2}
                    /\ ch0 = G1.chandle{2}
                    /\ PFm = PF.m{1}
                    /\ PFmi = PF.mi{1}
                    /\ G1m = G1.m{2}
                    /\ G1mi = G1.mi{2}
                    /\ G1mh = G1.mh{2}
                    /\ G1mhi = G1.mhi{2}
                    /\ ro0 = F.RO.m{2}
                    /\ pi0 = G1.paths{2}
                    /\ (x1,x2) = x{2}
                    /\ !G1.bcol{2}
                    /\ !G1.bext{2}
                    /\ ={x, y1, y2}
                    /\ INV_CF_G1 hs0 ch0 PFm PFmi G1m G1mi G1mh G1mhi ro0 pi0).
        + by auto.
        case @[ambient]: {-1}(getflag hs0 x2) (eq_refl (getflag hs0 x2)).
        + rewrite getflagP_none => x2f_notin_rng_hs0; rcondt{2} 3.
          + by move=> &1; auto=> &2 />; rewrite x2f_notin_rng_hs0.
          rcondf{2} 6.
          + move=> &1; auto=> &2 />.
            have ->: hinvK FRO.m{2}.[G1.chandle{2} <- (x2,Known)] x2 = Some G1.chandle{2}.
            + rewrite (@huniq_hinvK_h G1.chandle{2} FRO.m{2}.[G1.chandle{2} <- (x2,Known)] x2) //.
              + move=> hx hy [] xc xf [] yc yf /=.
                rewrite !getP; case: (hx = G1.chandle{2}); case: (hy = G1.chandle{2})=> //=.
                + move=> _ + [#] - <*>.
                  by have:= (x2f_notin_rng_hs0 yf); rewrite in_rng negb_exists /= => ->.
                + move=> + _ + [#] - <*>.
                  by have:= (x2f_notin_rng_hs0 xf); rewrite in_rng negb_exists /= => ->.
                by move=> _ _; case: inv0=> _ _ _ _ _ _ [] + _ _ - /(_ hx hy (xc,xf) (yc,yf)).
              by rewrite !getP.
            rewrite oget_some=> _ _ _.
            have -> //: !mem (dom G1.mh{2}) (x1,G1.chandle{2}).
            rewrite in_dom /=; case: {-1}(G1.mh.[(x1,G1.chandle)]{2}) (eq_refl (G1.mh.[(x1,G1.chandle)]{2}))=> //= -[xa xh]; rewrite -negP.
            case: inv0=> - [] _ + _ _ _ _ _ [] _ _ h_handles.
            move=> /(_ x1 G1.chandle{2} xa xh) h /h [] xc xf yc yf.
            by have ->: FRO.m.[G1.chandle]{2} = None by smt (in_dom).
          case: (x2 <> y2{2} /\ (forall f, !mem (rng hs0) (y2{2},f))).
          + auto=> &1 &2 [#] !<<- -> -> !->> {&1} /= _ x2_neq_y2 y2_notin_hs _ _.
            rewrite getP /= oget_some /= -addzA /=.
            rewrite (@huniq_hinvK_h ch0 hs0.[ch0 <- (x2,Known)] x2); 2:by rewrite getP.
            + move=> @/huniq h1 h2 [c1 f1] [c2 f2]; rewrite !getP /=.
              case: (h1 = ch0); case: (h2 = ch0)=> //=.
              + by move=> _ + [#] - <*>; move: (x2f_notin_rng_hs0 f2); rewrite in_rng negb_exists=> /= ->.
              + by move=> + _ + [#] <*> - <*>; move: (x2f_notin_rng_hs0 f1); rewrite in_rng negb_exists=> /= ->.
              move=> _ _; case: inv0=> _ _ _ _ _ _ [] + _ _ - h.
              by apply/h; rewrite getP.
            by rewrite oget_some; exact/lemma1.
          conseq (_: _ ==> G1.bcol{2})=> //=.
          auto=> &1 &2 [#] !<<- -> _ ->> !<<- _ /=.
          case: (hinvP hs0.[ch0 <- (x2,Known)] y2{1})=> //= -> /=.
          move=> hs0_spec; split=> [|f].
          + by have:= hs0_spec ch0 Known; rewrite getP.
          rewrite in_rng negb_exists /= => h.
          have:= hs0_spec h f; rewrite getP; case: (h = ch0)=> [<*>|//=].
          by have -> //=: hs0.[ch0] = None; case: inv0=> _ _ _ _ _ _ [] _ _; smt (in_dom).
        case; rewrite getflagP_some; 1,3:by case: inv0=> _ _ _ _ _ _ [].
        + by move=> x2_is_U; conseq (_: G1.bext{2})=> //=; auto=> &1 &2 />; rewrite x2_is_U.
        move=> x2_is_K; rcondf{2} 3; 1:by move=> &1; auto.
        have:= x2_is_K; rewrite in_rng=> - [hx] hs0_hx.
        seq  0  3: (   hs0 = FRO.m{2}
                    /\ ch0 = G1.chandle{2}
                    /\ PFm = PF.m{1}
                    /\ PFmi = PF.mi{1}
                    /\ G1m = G1.m{2}
                    /\ G1mi = G1.mi{2}
                    /\ G1mh = G1.mh{2}
                    /\ G1mhi = G1.mhi{2}
                    /\ ro0 = F.RO.m{2}
                    /\ pi0 = G1.paths{2}
                    /\ (x1,x2) = x{2}
                    /\ !G1.bcol{2}
                    /\ !G1.bext{2}
                    /\ ={x,y1,y2}
                    /\ y{2} = (y1,y2){2}
                    /\ hx2{2} = hx
                    /\ INV_CF_G1 hs0 ch0 PFm PFmi G1m G1mi G1mh G1mhi ro0 pi0).
        + auto=> &1 &2 /> _ -> /= _; split.
          + move: x2_is_K; rewrite in_rng /= => -[hx2] hs_hx2.
            rewrite in_rng negb_exists /==> h; rewrite -negP=> hs_h.
            case: inv0=> _ _ _ _ _ _ [] Hhuniq _ _.
            by move: (Hhuniq _ _ _ _ hs_hx2 hs_h)=> ht; move: ht hs_h=> /= <*>; rewrite hs_hx2.
          rewrite (@huniq_hinvK_h hx FRO.m{2} x2) //.
          by case: inv0=> _ _ _ _ _ _ [].
        have x1hx_notin_G1m: !mem (dom G1mh) (x1,hx).
        + rewrite in_dom; case: {-1}(G1mh.[(x1,hx)]) (eq_refl G1mh.[(x1,hx)])=> //=.
          move=> [mhx1 mhx2]; rewrite -negP=> h.
          have:= inv0=> -[] [] _ hg _ _ _ _ _ _.
          have [xa xh ya yh] := hg _ _ _ _ h.
          by rewrite hs0_hx=> [#] <*>; rewrite x1x2_notin_PFm.
        rcondf{2} 1.
        + by move=> &m; auto=> //= &hr [#] <*>; rewrite x1hx_notin_G1m.
        auto=> &1 &2 [#] !<<- -> -> !->> _ /= hinv_y2_none.
        rewrite getP /= oget_some /=.
        exact/lemma2.
      move=> [p0 v0] ^ pi_x2. have [] _ _ _ _ _ [] -> _ [hx2] [#] Hpath hs_hx2:= inv0.
      rcondt{2} 1. by move=> &m; auto=> &hr [#] !<<- _ _ ->> /= _; rewrite in_dom pi_x2.
      rcondf{2} 6.
      + auto; inline *; auto=> &hr [#] !<<- _ _ !->> _ /= _ _ _ _ /=.
        by rewrite in_rng; exists hx2.
      rcondf{2} 7.
      + auto; inline *; auto=> &hr [#] !<<- _ _ !->> _ /= _ _ _ _ /=.
        rewrite negb_and; left; rewrite (@huniq_hinvK_h hx2 hs0 x2) // 2:oget_some.
        + by case: inv0=> _ _ _ _ _ _ [].
        rewrite in_dom; case: {-1}(G1mh.[(x1,hx2)]) (eq_refl (G1mh.[(x1,hx2)]))=> [//=|[xa xc] G1mh_x1hx2].
        have [] [] _ /(_ _ _ _ _ G1mh_x1hx2) [xc0 xf0 yc0 yf0] + _ _ _ _ _ _:= inv0.
        by move=> [#]; rewrite hs_hx2=> [#] !<<- {xc0 xf0}; rewrite x1x2_notin_PFm.
      rcondt{2} 15.
      + auto; inline *; auto=> &hr [#] !<<- _ _ !->> _ /= _ _ _ _ /=.
        by rewrite in_dom pi_x2.
      inline F.RO.get. rcondt{2} 4.
      + auto=> &hr [#] !<<- _ _ !->> _ /= _ _; rewrite pi_x2 oget_some /=.
        rewrite in_dom; case: {-1}(ro0.[rcons p0 (v0 +^ x1)]) (eq_refl (ro0.[rcons p0 (v0 +^ x1)])).
        + done.
        move=> bo ^ro_pvx1 /=. have [] _ _ _ _ [] _ -> _ _:= inv0.
        rewrite negb_exists=> ? /=; rewrite negb_exists=> ? /=; rewrite negb_exists=> yh /=.
        rewrite Hpath /=; rewrite negb_and -implyNb /= => [#] !<<-.
        rewrite xorwA xorwK xorwC xorw0 -negP=> G1mh_x1hx2.
        have [] [] _ /(_ _ _ _ _ G1mh_x1hx2) + _ _ _ _ _ _ := inv0.
        move=> [xc xf yc yf] [#]; rewrite hs_hx2=> [#] <*>.
        by rewrite x1x2_notin_PFm.
      auto. admit. (* this is the easy case *)
    move=> [xa xc] PFm_x1x2. rcondf{1} 1; 1:by auto=> &hr [#] !<<- _ _ ->>; rewrite in_dom PFm_x1x2.
    have [] [] /(_ _ _ _ _ PFm_x1x2) + _ _ _ _ _ _ _ := inv0.
    move=> [hx2 fx2 hy2 fy2] [#] hs_hx2 hs_hy2 G1mh_x1hx2.
    case @[ambient]: {-1}(G1m.[(x1,x2)]) (eq_refl (G1m.[(x1,x2)])); last first.
    + move=> [ya yc] G1m_x1x2; rcondf{2} 1; 1:by auto=> &hr [#] !<<- _ _ ->>; rewrite in_dom G1m_x1x2.
      auto=> &1 &2 [#] <*> -> -> -> /=; have [] _ _ /(_ (x1,x2)) + _ _ _ _ := inv0.
      by rewrite PFm_x1x2 G1m_x1x2 /= => [#] !<<- {ya yc}.
    move=> x1x2_notin_G1m; rcondt{2} 1; 1:by auto=> &hr [#] !<<- _ _ ->>; rewrite in_dom x1x2_notin_G1m.
    have <*>: fy2 = Unknown.
    + case: inv0=> _ _ _ _ [] /(_ _ _ _ _ G1mh_x1hx2) + _ _ _.
      move=> [xc0 xf0 yc0 yf0] [#]; rewrite hs_hx2 hs_hy2=> [#] !<<- [#] !<<- {xc0 xf0 yc0 yf0}.
      by case: fy2 hs_hy2 G1mh_x1hx2=> //=; rewrite x1x2_notin_G1m.
    case @[ambient]: fx2 hs_hx2=> hs_hx2.
    + swap{2} 3 -2; seq  0  1: (G1.bext{2}); last by inline*; if{2}; auto; smt (@Block @Capacity).
      by auto=> ? ? [#] !<<- _ -> ->> _ /=; rewrite in_rng; exists hx2.
    have [] _ _ _ _ [] /(_ _ _ _ _ G1mh_x1hx2) + _ _ _:= inv0.
    move=> [xc0 xf0 yc0 yf0] [#]; rewrite hs_hx2 hs_hy2=> [#] !<<- [#] !<<- {xc0 xf0 yc0 yf0} /= [p0 v0] [#] Hro Hpath.
    have [] _ _ _ _ _ [] /(_ x2 p0 v0) /iffRL Hpi _:= inv0.
    move: (Hpi _); first by exists hx2.
    move=> pi_x2; rcondt{2} 1; 1:by auto=> &hr [#] <*>; rewrite in_dom pi_x2.
    inline F.RO.get.
    rcondf{2} 4; first by auto=> &hr [#] !<<- _ _ ->> _ /=; rewrite pi_x2 oget_some /= in_dom Hro.
    rcondf{2} 8; first by auto=> &hr [#] !<<- _ _ ->> _ /= _ _ _ _; rewrite in_rng; exists hx2.
    rcondt{2} 9.
    + auto=> &hr [#] !<<- _ _ ->> _ /= _ _ _ _.
      rewrite (@huniq_hinvK_h hx2 hs0 x2) // 2:in_dom 2:G1mh_x1hx2 2:!oget_some /=.
      + by case: inv0=> _ _ _ _ _ _ [].
      by rewrite /in_dom_with in_dom hs_hy2.
    rcondt{2} 14; first by auto=> &hr [#] !<<- _ _ ->> _ /=; rewrite in_dom pi_x2.
    auto=> &1 &2 [#] !<<- -> -> ->> _ /=; rewrite Block.DWord.bdistr_ll Capacity.DWord.cdistr_ll /=.
    move=> _ _ _ _; rewrite PFm_x1x2 pi_x2 !oget_some //=.
    rewrite (@huniq_hinvK_h hx2 hs0 x2) // ?oget_some.
    + by case: inv0=> _ _ _ _ _ _ [].
    rewrite Hro G1mh_x1hx2 hs_hy2 ?oget_some //=.
    (* lemma 3 *) admit.
  (* Stopped here *)
  + move=> &2 _; proc; if=> //=; wp; rnd predT; rnd predT; auto.
    smt (Block.DWord.bdistr_uf Capacity.DWord.cdistr_uf).
  (* lossless and do not reset bad G1.S.f *)
  + move=> _; proc; if; auto.
    conseq (_: _ ==> G1.bcol \/ G1.bext); 1:smt ().
    inline *; if=> //=; wp; rnd predT; wp; rnd predT; auto.
    + smt (Block.DWord.bdistr_uf Capacity.DWord.cdistr_uf).
    smt (Block.DWord.bdistr_uf Capacity.DWord.cdistr_uf).
  (** proofs for G1.S.fi *)
  (* equiv PF.P.fi G1.S.fi *)
  + admit.
  (* lossless PF.P.fi *)
  + admit.
  (* lossless and do not reset bad G1.S.fi *)
  + admit.
  (** proofs for G1.C.f *)
  (* equiv PF.C.f G1.C.f *)
  + admit.
  (* lossless PF.C.f *)
  + admit.
  (* lossless and do not reset bad G1.C.f *)
  + admit.
  (* Init ok *)
  admit.
(*inline *. auto; progress=> //=.
  + smt w=map0P.
  + smt w=map0P.
  + smt w=map0P.
  + smt w=map0P.
  + smt w=map0P.
  + smt w=(map0P in_dom).
  + smt w=map0P.
  + rewrite /paths_spec=> c p v. rewrite !getP; case (c = c0)=> //=.
      rewrite anda_and=> c_c0; split=> [[] <<- <<-|].
      + by exists 0; rewrite /build_hpath /= getP /= c_c0.
      move=> [h] @/build_hpath [] h0; rewrite getP; case (h = 0).
      + by move=> /= ->> ->>; move: h0; smt.
      smt w=map0P.
    move=> c_c0; rewrite map0P /= negb_exists /= => h.
    rewrite negb_and getP; case (h = 0)=> //=; [|by rewrite map0P].
    by move=> _; right; rewrite eq_sym.
  + smt w=(map0P getP).
  + by rewrite getP.
  + move: H; rewrite in_dom getP; case (h = 0)=> //=.
    by rewrite map0P.
  + by move: H1=> /H0 [#].*)
qed.

end section AUX.

section.

  declare module D: DISTINGUISHER{Perm, C, PF, G1, RO}.
  
  axiom D_ll (F <: DFUNCTIONALITY{D}) (P <: DPRIMITIVE{D}):
    islossless P.f => islossless P.fi =>
    islossless F.f => islossless D(F, P).distinguish.

  lemma Real_G1 &m: 
    Pr[GReal(D).main() @ &m: res /\ C.c <= max_size] <=
    Pr[G1(DRestr(D)).main() @ &m: res] +  (max_size ^ 2)%r * mu dstate (pred1 witness) + 
    Pr[G1(DRestr(D)).main() @&m: G1.bcol] + Pr[G1(DRestr(D)).main() @&m: G1.bext].
  proof. 
    apply (@RealOrder.ler_trans _ _ _ (Real_Concrete D D_ll &m)).
    cut : Pr[CF(DRestr(D)).main() @ &m : res] <= 
          Pr[G1(DRestr(D)).main() @ &m : res] + 
          Pr[G1(DRestr(D)).main() @ &m : G1.bcol \/ G1.bext].
    + byequiv (CF_G1 (DRestr(D)) _)=>//;1:by apply (DRestr_ll D D_ll).
      smt ml=0.
    cut /# : Pr[G1(DRestr(D)).main() @ &m : G1.bcol \/ G1.bext] <= 
             Pr[G1(DRestr(D)).main() @ &m : G1.bcol] + 
             Pr[G1(DRestr(D)).main() @ &m : G1.bext].
    rewrite Pr [mu_or]; smt.
  qed.

end section.


