require import Option Int Real List FSet NewFMap.
require RndOrcl Indifferentiability. 

type p.

type from.

type block.
op dblock : block distr.
axiom dblock_ll: Distr.weight dblock = 1%r.

op univ : (from * int) fset.
op test : from * int -> bool.
op dfl  : block.

clone RndOrcl as ROB with
  type from <- from * int,
  type to   <- block.

clone include ROB.RestrIdeal with
  op sample <- fun (x:from*int) => dblock,
  op dfl    <- dfl,
  op univ   <- univ,
  op test   <- test
  proof sample_ll by apply dblock_ll.

(* axiom testP (x:from * int): test x <=> mem univ x. *)
axiom test_neg (x:from) (n:int): n < 0 => !test (x,n). 
axiom test_le (x:from) (n p:int) : 0 <= p <= n => test (x,n) => test (x,p).

clone import Indifferentiability as IndB with 
  type p <- p,
  type f_in  <- from * int,
  type f_out <- block.

clone import Indifferentiability as IndNB with 
  type p <- p,
  type f_in  <- from * int,
  type f_out <- block list.

module RONB (Ob:IndB.FUNCTIONALITY) = {
  proc init = Ob.init

  proc f(x:from, n:int) : block list = {
    var b, bs;
    bs <- [];
    while (size bs < n) {
      b  <@ Ob.f(x,size bs);
      bs <- rcons bs b;
    }
    return bs;
  }
}.

module DNB(D:IndNB.DISTINGUISHER, F:IndB.FUNCTIONALITY, P:IndB.PRIMITIVE) = {
  proc distinguish = D(RONB(F), P).distinguish
}.

module CNB (C: IndB.CONSTRUCTION, P:IndB.PRIMITIVE) = RONB(C(P)).

module FNB_B(F:IndNB.FUNCTIONALITY) = {
  proc init () = {}

  proc f(x:from,n:int) : block = {
    var bs;
    bs <@ F.f(x,n+1);
    return nth dfl bs n;
  }
}.

module SNB(S:IndB.SIMULATOR, F:IndNB.FUNCTIONALITY) = {

  proc init = S(FNB_B(F)).init

  proc f = S(FNB_B(F)).f
  proc fi = S(FNB_B(F)).fi
}.

section PROOF.

  declare module P:IndB.PRIMITIVE.
  declare module C:IndB.CONSTRUCTION {P}.
  declare module S:IndB.SIMULATOR {RO}.

  declare module D: IndNB.DISTINGUISHER {P, RO, S, C}.

  local equiv equivReal: IndNB.GReal(CNB(C), P, D).main ~ IndB.GReal(C, P, DNB(D)).main:
         ={glob P, glob C, glob D} ==>
         ={glob P, glob C, glob D,res}.
  proof. proc;inline *; sim. qed.

  local module DRO (O:ROB.RO) = {
    proc distinguish () : bool = {
      var b;  
      SNB(S, RONB(O)).init();                             
      b <@ D(RONB(O), SNB(S, RONB(O))).distinguish();
      return b;  
    }
  }.

  local module DNB'(O:ROB.RO) : ROB.Distinguisher(O)= {
    proc distinguish () : bool = {
      var b;
      S(O).init(); 
      b <@ DNB(D, O, S(O)).distinguish();
      return b;
    }
  }.

  local equiv feq : 
    FNB_B(RONB(ERO)).f ~ ERO.f : (x, n){1} = x{2} /\ ={RO.m} ==> ={res, RO.m}. 
  proof.
    proc;inline *;wp.
    while{1} ((0 <= n0 => size bs0 <= n0){1} /\ forall i, 0 <= i < size bs0{1} => 
                        nth dfl bs0{1} i = 
                          if test (x0{1},i) 
                          then oget RO.m{1}.[(x0{1},i)] 
                          else dfl) ((n0 - size bs0){1}).
    + move=> &m2 z;auto;progress [-split].
      rewrite size_rcons;split;2:smt ml=0;split;1:smt ml=0.
      move=> i [Hi0 Hi1];rewrite nth_rcons.
      case (i < size bs0{hr})=> Hi';first by apply H0.
      by cut -> : i = size bs0{hr} by smt ml=0.
    auto;progress;1,2: smt ml=0.
    case (n{1} < 0)=> Hn. 
    + by rewrite nth_neg // test_neg. 
    apply H1=> {H1} //;smt ml=0.
  qed.

  lemma conclusion &m: 
     `|Pr[IndNB.GReal(CNB(C), P, D).main()@ &m:res] - Pr[IndNB.GIdeal(RONB(Restr(RO)), SNB(S), D).main()@ &m:res] | = 
     `|Pr[IndB.GReal(C, P, DNB(D)).main()@ &m:res] - Pr[IndB.GIdeal(Restr(RO),S,DNB(D)).main()@ &m:res] |.
  proof. 
    cut -> : Pr[IndNB.GReal(CNB(C), P, D).main()@ &m:res] = Pr[IndB.GReal(C, P, DNB(D)).main()@ &m:res].
    + byequiv equivReal=> //.    
    cut -> : Pr[GIdeal(RONB(Restr(RO)), SNB(S), D).main() @ &m : res] = 
             Pr[ROB.IND(Restr(RO), DRO).main() @ &m : res].
    + by byequiv=> //; proc;inline *;swap{1} 1 1;sim.
    cut -> :  Pr[ROB.IND(Restr(RO), DRO).main() @ &m : res] = 
              Pr[ROB.IND(ERO,DRO).main () @ &m : res].
    + by byequiv (Eager DRO)=> //.
    do 2! congr.
    cut -> : Pr[IndB.GIdeal(Restr(RO), S, DNB(D)).main() @ &m : res] = 
             Pr[ROB.IND(Restr(RO), DNB').main() @ &m : res].
    + by byequiv=> //; proc;inline *;swap{1} 1 1;sim. 
    cut -> : Pr[ROB.IND(Restr(RO), DNB').main() @ &m : res] = 
             Pr[ROB.IND(ERO, DNB').main() @ &m : res].
    + by byequiv (Eager DNB')=> //.
    byequiv=> //;proc;inline DRO(ERO).distinguish DNB'(ERO).distinguish;wp.
    call (_: ={RO.m, glob S});1,2:by proc (={RO.m}) => //;apply feq.
    + sim.
    by conseq (_: _ ==> ={glob S, glob D, RO.m})=> //;sim.
  qed.

end section PROOF.
