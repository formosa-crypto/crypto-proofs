require import Pred Fun Option Pair Int Real StdOrder Ring.
require import List FSet NewFMap Utils Common SLCommon.
(*...*) import Dprod Dexcepted Capacity IntOrder RealOrder.



module C = {
  var c:int
  proc init () = { c <- 0; }
}.

module PC (P:PRIMITIVE) = {

  proc init () = {
    C.init();
    P.init();
  }

  proc f (x:state) = {  
    var y;
    C.c <- C.c + 1;
    y     <@ P.f(x);
    return y;
  }

  proc fi(x:state) = {
    var y;
    C.c <- C.c + 1;
    y     <@ P.fi(x);
    return y;
  } 

}.

module PRestr (P:PRIMITIVE) = {

  proc init () = {
    C.init();
    P.init();
  }

  proc f (x:state) = {  
    var y=(b0,c0);
    if (C.c + 1 <= max_size) {
      C.c <- C.c + 1;
      y     <@ P.f(x);
    }
    return y;
  }

  proc fi(x:state) = {
    var y=(b0,c0);
    if (C.c + 1 <= max_size) {
      C.c <- C.c + 1;
      y     <@ P.fi(x);
    }
    return y;
  } 

}.

module FC(F:FUNCTIONALITY) = {

  proc init = F.init

  proc f (bs:block list) = {
    var b= b0;
    C.c <- C.c + size bs;
    b <@ F.f(bs);
    return b;
  }
}.

module FRestr(F:FUNCTIONALITY) = {

  proc init = F.init

  proc f (bs:block list) = {
    var b= b0;
    if (C.c + size bs <= max_size) {
      C.c <- C.c + size bs;
      b <@ F.f(bs);
    }
    return b;
  }
}.

section COUNT.

  declare module P:PRIMITIVE{C}.
  declare module CO:CONSTRUCTION{C,P}.
  declare module D:DISTINGUISHER{C,P,CO}.

  axiom f_ll  : islossless P.f.
  axiom fi_ll : islossless P.fi.

  axiom CO_ll : islossless CO(P).f.

  axiom D_ll (F <: DFUNCTIONALITY{D}) (P <: DPRIMITIVE{D}):
    islossless P.f => islossless P.fi => islossless F.f => 
    islossless D(F, P).distinguish.

  lemma Pr_restr &m : 
    Pr[Indif(FC(CO(P)), PC(P), D).main()@ &m:res /\ C.c <= max_size] <= 
    Pr[Indif(FRestr(CO(P)), PRestr(P), D).main()@ &m:res].
  proof.
    byequiv (_: ={glob D, glob P, glob CO} ==> C.c{1} <= max_size => ={res})=>//;
      2:by move=> ??H[]?/H<-.
    symmetry;proc.
    call (_: max_size < C.c, ={glob P, glob CO, glob C}).
    + apply D_ll.
    + proc; sp 1 0;if{1};1:by call(_:true);auto. 
      by call{2} f_ll;auto=>/#. 
    + by move=> ?_;proc;sp;if;auto;call f_ll;auto.
    + by move=> _;proc;call f_ll;auto=>/#.
    + proc;sp 1 0;if{1};1:by call(_:true);auto.
      by call{2} fi_ll;auto=>/#. 
    + by move=> ?_;proc;sp;if;auto;call fi_ll;auto.
    + by move=> _;proc;call fi_ll;auto=>/#.
    + proc;sp 1 0;if{1};1:by call(_: ={glob P});auto;sim.
      by call{2} CO_ll;auto=>/#.
    + by move=> ?_;proc;sp;if;auto;call CO_ll;auto.
    + move=> _;proc;call CO_ll;auto;smt ml=0 w=size_ge0. 
    inline *;call (_:true);call(_:true);auto=>/#.
  qed.

end section COUNT.

module PF = {
  var m, mi: (state,state) fmap

  proc init(): unit = {
    m  <- map0;
    mi <- map0;
  }

  proc f(x : state): state = {
    var y;

    if (!mem (dom m) x) {
      y <$ dstate;
      m.[x]  <- y;
      mi.[y] <- x;
    }
    return oget m.[x];
  }

  proc fi(x : state): state = {
    var y;

    if (!mem (dom mi) x) {
      y <$ dstate;
      mi.[x] <- y;
      m.[y]  <- x;
    }
    return oget mi.[x];
  }

}.

op bound_concrete : real.

module GReal(D:DISTINGUISHER) = 
  Indif(FC(SqueezelessSponge(Perm)), PC(Perm), D).

module CF(D:DISTINGUISHER) = 
  Indif(FRestr(SqueezelessSponge(PF)), PRestr(PF), D).
     
section.

  declare module D : DISTINGUISHER {Perm, C, PF}.

  axiom D_ll (F <: DFUNCTIONALITY{D}) (P <: DPRIMITIVE{D}):
    islossless P.f => islossless P.fi => islossless F.f => 
    islossless D(F, P).distinguish.

  lemma Real_Concrete &m : 
    Pr[GReal(D).main()@ &m:res /\ C.c <= max_size] <=
    Pr[CF(D).main()@ &m: res] + bound_concrete.
  proof.
    cut p_ll : islossless Perm.f. 
    + admit. (* We should have the lemma *)
    cut pi_ll : islossless Perm.fi.
    + admit. (* We should have the lemma *)
    cut f_ll : islossless SqueezelessSponge(Perm).f.
    + admit. (* We should have the lemma *)
    apply (ler_trans _ _ _ 
             (Pr_restr Perm SqueezelessSponge D p_ll pi_ll f_ll D_ll &m)).
    admit. (* Francois *)
  qed.

end section.
