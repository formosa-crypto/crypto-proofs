require import Pred Fun Option Pair Int Real StdOrder Ring.
require import List FSet NewFMap Utils Common SLCommon.
(*...*) import Dprod Dexcepted Capacity IntOrder RealOrder.

module PF = {
  var m, mi: (state,state) fmap

  proc init(): unit = {
    m  <- map0;
    mi <- map0;
  }

  proc f(x : state): state = {
    var y;

    if (!mem (dom m) x) {
      y <$ dstate;
      m.[x]  <- y;
      mi.[y] <- x;
    }
    return oget m.[x];
  }

  proc fi(x : state): state = {
    var y;

    if (!mem (dom mi) x) {
      y <$ dstate;
      mi.[x] <- y;
      m.[y]  <- x;
    }
    return oget mi.[x];
  }

}.

(* Fixme *)
op bound_concrete : real.

module CF(D:DISTINGUISHER) = Indif(SqueezelessSponge(PF), PF, D).
     
section.

  declare module D : DISTINGUISHER {Perm, C, PF}.

  axiom D_ll (F <: DFUNCTIONALITY{D}) (P <: DPRIMITIVE{D}):
    islossless P.f => islossless P.fi => islossless F.f => 
    islossless D(F, P).distinguish.

  local module GReal' = Indif(FC(SqueezelessSponge(Perm)), PC(Perm), D).

  (* TODO move this *)
  lemma size_behead(l:'a list): l <> [] => size (behead l) = size l - 1.
  proof. case l=>// ??/=;ring. qed.

  lemma Real_Concrete &m : 
    Pr[GReal(D).main()@ &m: res /\ C.c <= max_size] <=
    Pr[CF(DRestr(D)).main()@ &m: res] + bound_concrete.
  proof.
    cut->:
      Pr[RealIndif(SqueezelessSponge,PC(Perm),D).main()@ &m:
         res /\ C.c <= max_size] = Pr[GReal'.main()@ &m: res/\ C.c <= max_size].
    + byequiv=>//;proc;inline *;call (_: ={C.c,glob Perm});last by auto.
      + by sim. + by sim.
      proc;inline *;sp 1 0;if{1};wp;[rcondt{2}5|rcondf{2}5];1,3:by auto.
      + while (={glob Perm,sc,sa,p} /\ (C.c + size p){1} = C.c{2});2:by auto.
        by wp;sp 1 1;if{2};[rcondt{1} 3|rcondf{1} 3];auto;
          progress;rewrite size_behead//;ring.
      by auto; smt ml=0 w=size_ge0. 
    cut p_ll : islossless Perm.f. 
    + admit. (* We should have the lemma *)
    cut pi_ll : islossless Perm.fi.
    + admit. (* We should have the lemma *)
    cut f_ll : islossless SqueezelessSponge(Perm).f.
    + admit. (* We should have the lemma *)
    apply (ler_trans _ _ _ 
             (Pr_restr Perm SqueezelessSponge D p_ll pi_ll f_ll D_ll &m)).
    admit. (* Francois *)
  qed.

end section.
