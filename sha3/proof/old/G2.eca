require import Pred Fun Option Pair Int Real StdOrder Ring.
require import List FSet NewFMap Utils Common SLCommon.
(*...*) import Dprod Dexcepted Capacity IntOrder.

require Handle.

clone import Handle as Handle0.

(* -------------------------------------------------------------------------- *)
section PROOF.
  declare module D: DISTINGUISHER{C, PF, G1}.

  axiom D_ll (F <: DFUNCTIONALITY{D}) (P <: DPRIMITIVE{D}):
    islossless P.f => islossless P.fi =>
    islossless F.f => islossless D(F, P).distinguish.

  local module Gcol = {
    
    var count : int

    proc sample_c () = {
      var c=c0;
      if (card (image fst (rng G1.handles)) <= 2*max_size) {
        c <$ cdistr;
        G1.bcol <-  G1.bcol \/ mem (image fst (rng G1.handles)) c;
        count <- count + 1;  
      }
      return c;
    }
  
    module C = {
  
      proc f(p : block list): block = {
        var sa, sa', sc;
        var h, i <- 0; 
        sa <- b0;
        if (1 <= size p /\ p <> [b0]) {
          while (i < size p ) {
            if (mem (dom G1.mh) (sa +^ nth witness p i, h)) {
              (sa, h) <- oget G1.mh.[(sa +^ nth witness p i, h)];
            } else {
              sc                  <@ sample_c();
              sa'                 <- RO.f(take (i+1) p);
              sa                  <- sa +^ nth witness p i;
              G1.mh.[(sa,h)]         <- (sa', G1.chandle);
              G1.mhi.[(sa',G1.chandle)] <- (sa, h);
              (sa,h)              <- (sa',G1.chandle);
              G1.handles.[G1.chandle]   <- (sc,I);
              G1.chandle             <- G1.chandle + 1;
            }
            i        <- i + 1;
          }
          sa <- RO.f(p);
        }
        return sa;
      }
    }
  
    module S = {
  
      proc f(x : state): state = {
        var p, v, y, y1, y2, hy2, hx2;
  
        if (!mem (dom G1.m) x) {
          if (!(mem (rng G1.handles) (x.`2, D))) {
            G1.handles.[G1.chandle] <- (x.`2, D);
            G1.chandle <- G1.chandle + 1;
          }
          hx2 <- oget (hinvD G1.handles x.`2);

          if (mem (dom G1.paths) x.`2) {
            (p,v) <- oget G1.paths.[x.`2]; 
            y1    <- RO.f (rcons p (v +^ x.`1));
            y2    <@ sample_c();
            y     <- (y1, y2);
            G1.paths.[y2] <- (rcons p (v +^ x.`1), y.`1);
          } else {
            y1 <$ bdistr;
            y2 <@ sample_c();
            y  <- (y1,y2);
          }
            (*  exists x2 h, G1.handles.[h] = Some (X2,I) *)
         
          if (mem (dom G1.mh) (x.`1, hx2) /\ 
              (oget G1.handles.[(oget G1.mh.[(x.`1,hx2)]).`2]).`2 = I) {
            hy2               <- (oget G1.mh.[(x.`1, hx2)]).`2;
            y                 <- (y.`1, (oget G1.handles.[hy2]).`1);
            G1.handles.[hy2]     <- (y.`2, D);
            (* bad               <- bad \/ mem X2 y.`2; *)
            G1.m.[x]             <- y;
            G1.mi.[y]            <- x;
          } else {
            hy2               <- G1.chandle;
            G1.chandle           <- G1.chandle + 1;
            G1.handles.[hy2]     <- (y.`2, D);
            G1.m.[x]             <- y;
            G1.mh.[(x.`1, hx2)]  <- (y.`1, hy2);
            G1.mi.[y]            <- x;
            G1.mhi.[(y.`1, hy2)] <- (x.`1, hx2);
          }
        } else {   
          y <- oget G1.m.[x];
        }
        return y;
      }
  
      proc fi(x : state): state = {
        var y, y1, y2, hx2, hy2;
  
        if (!mem (dom G1.mi) x) {
          if (!(mem (rng G1.handles) (x.`2, D))) {
            G1.handles.[G1.chandle] <- (x.`2, D);
            G1.chandle <- G1.chandle + 1;
          }
          hx2 <- oget (hinvD G1.handles x.`2);
          y1  <$ bdistr;
          y2  <@ sample_c();
          y   <- (y1,y2);
          if (mem (dom G1.mhi) (x.`1, hx2) /\ 
              (oget G1.handles.[(oget G1.mh.[(x.`1,hx2)]).`2]).`2 = I) {
            (y1,hy2)          <- oget G1.mhi.[(x.`1, hx2)];
            y                 <- (y.`1, (oget G1.handles.[hy2]).`1);
            G1.handles.[hy2]     <- (y.`2, D);
            (* bad               <- bad \/ mem X2 y.`2; *)
            G1.mi.[x]            <- y;
            G1.mhi.[(x.`1, hx2)] <- (y.`1, hy2);
            G1.m.[y]             <- x;
            G1.mh.[(y.`1, hy2)]  <- (x.`1, hx2);
          } else {
            hy2               <- G1.chandle;
            G1.chandle           <- G1.chandle + 1;
            G1.handles.[hy2]     <- (y.`2, D);
            G1.mi.[x]            <- y;
            G1.mhi.[(x.`1, hx2)] <- (y.`1, hy2);
            G1.m.[y]             <- x;
            G1.mh.[(y.`1, hy2)]  <- (x.`1, hx2);
          }
        } else {
          y <- oget G1.mi.[x];
        }
        return y;
      }
    
    }
  
    proc main(): bool = {
      var b;

      RO.m        <- map0;
      G1.m        <- map0;
      G1.mi       <- map0;
      G1.mh       <- map0;
      G1.mhi      <- map0;
      G1.bcol     <- false;
  
      G1.handles  <- map0.[0 <- (c0, D)];
      G1.paths    <- map0.[c0 <- ([<:block>],b0)];
      G1.chandle  <- 1;
      count       <- 0;
      b           <@ DRestr(D,C,S).distinguish();
      return b;
    }    
  }.

  lemma card_rng_set (m:('a,'b)fmap) x y: card(rng m.[x<-y]) <= card(rng m) + 1.
  proof. 
    rewrite rng_set fcardU fcard1. 
    cut := subset_leq_fcard (rng (rem x m)) (rng m) _;2:smt ml=0 w=fcard_ge0.
    rewrite subsetP=> z;apply rng_rem_le.
  qed.

  lemma hinv_image handles c: 
    hinv handles c <> None =>
    mem (image fst (rng handles)) c.
  proof.
    case: (hinv handles c) (hinvP handles c)=>//= h[f] Heq.
    rewrite imageP;exists (c,f)=>@/fst/=. 
    by rewrite in_rng;exists (oget (Some h)).
  qed.

  local equiv G1col : G1(DRestr(D)).main ~ Gcol.main : 
    ={glob D} ==> (G1.bcol{1} => G1.bcol{2}) /\ Gcol.count{2} <= max_size.
  proof.
    proc;inline*;wp.
    call (_: ={RO.m,G1.mi,G1.paths,G1.m,G1.mhi,G1.chandle,G1.mh,G1.handles,C.c}/\
             (G1.bcol{1} => G1.bcol{2}) /\
             (card (rng G1.handles) <= 2*C.c + 1 /\ 
              Gcol.count <= C.c <= max_size){2}).
    + proc;sp 1 1;if=>//.
      inline G1(DRestr(D)).S.f Gcol.S.f. 
      seq 2 2 : (={RO.m,G1.mi,G1.paths,G1.m,G1.mhi,G1.chandle,G1.mh,G1.handles,
                   C.c,x0} /\ 
                 (G1.bcol{1} => G1.bcol{2}) /\
                 (card(rng G1.handles) + 2 <= 2*C.c + 1/\ 
                  Gcol.count + 1 <= C.c <= max_size){2});1:by auto=>/#.
      if=>//;last by auto=>/#.
      swap{1}[2..4]-1. 
      seq 3 2:(={RO.m,G1.mi,G1.paths,G1.m,G1.mhi,G1.chandle,G1.mh,G1.handles,
                 C.c,x0,hx2} /\ 
               (G1.bcol{1} => G1.bcol{2}) /\
               (card (rng G1.handles) + 1 <= 2 * C.c + 1/\ 
                Gcol.count + 1 <= C.c <= max_size){2}).
      + auto;smt ml=0 w=card_rng_set. 
      seq 1 1: 
        (={RO.m,G1.mi,G1.paths,G1.m,G1.mhi,G1.chandle,G1.mh,G1.handles,
           C.c,x0,hx2,y0} /\ 
         ((G1.bcol\/hinv G1.handles y0.`2 <> None){1} => G1.bcol{2}) /\
         (card (rng G1.handles) + 1 <= 2 * C.c + 1 /\ 
         Gcol.count <= C.c <= max_size){2});last by auto;smt ml=0 w=card_rng_set.
      if=>//;inline Gcol.sample_c.
      + rcondt{2}4.
        + auto;conseq (_:true)=>//;progress. 
          cut /#:= fcard_image_leq fst (rng G1.handles{hr}).
        wp;conseq (_: ={p,v,RO.m,y1} /\ y2{1}=c{2})=>//;1:smt ml=0 w=hinv_image.
        by sim.
      rcondt{2}3.
      + by auto;progress;cut /#:= fcard_image_leq fst (rng G1.handles{hr}).
      swap{2}2-1;sp 0 1;wp;conseq(_:y0{1}=(y1,c){2})=>//;1:smt ml=0 w=hinv_image.
      transitivity{1} {y0 <- S.sample();} 
          (true ==> ={y0}) 
          (true ==> y0{1}=(y1,c){2})=>//;1:by inline*;auto.
      transitivity{2} {(y1,c) <- S.sample2();} 
          (true==>y0{1}=(y1,c){2})
          (true==> ={y1,c})=>//;2:by inline*;auto.
      by call sample_sample2;auto=> /=?[??]->.
   
    + proc;sp 1 1;if=>//.
      inline G1(DRestr(D)).S.fi Gcol.S.fi. 
      seq 2 2 : (={RO.m,G1.mi,G1.paths,G1.m,G1.mhi,G1.chandle,G1.mh,G1.handles,
                   C.c,x0} /\ 
                 (G1.bcol{1} => G1.bcol{2}) /\
                 (card(rng G1.handles) + 2 <= 2*C.c + 1 /\ 
                  Gcol.count + 1 <= C.c <= max_size){2});1:by auto=>/#.
      if=>//;last by auto=>/#.
      seq 3 2:(={RO.m,G1.mi,G1.paths,G1.m,G1.mhi,G1.chandle,G1.mh,G1.handles,
                 C.c,x0,hx2} /\ 
               (G1.bcol{1} => G1.bcol{2}) /\
               (card (rng G1.handles) + 1 <= 2 * C.c + 1 /\ 
                Gcol.count + 1 <= C.c <= max_size){2}).
      + auto;smt ml=0 w=card_rng_set. 
      seq 1 2: 
        (={RO.m,G1.mi,G1.paths,G1.m,G1.mhi,G1.chandle,G1.mh,G1.handles,
           C.c,x0,hx2} /\ y0{1} = (y1,y2){2} /\
         ((G1.bcol\/hinv G1.handles y0.`2 <> None){1} => G1.bcol{2}) /\
         (card (rng G1.handles) + 1 <= 2 * C.c + 1 /\ 
         Gcol.count <= C.c <= max_size){2});last by auto;smt ml=0 w=card_rng_set.
      inline Gcol.sample_c.
      rcondt{2}3.
      + by auto;progress;cut /#:= fcard_image_leq fst (rng G1.handles{hr}).
      swap{2}2-1;sp 0 1;wp;conseq(_:y0{1}=(y1,c){2})=>//;1:smt ml=0 w=hinv_image.
      transitivity{1} {y0 <- S.sample();} 
          (true ==> ={y0}) 
          (true ==> y0{1}=(y1,c){2})=>//;1:by inline*;auto.
      transitivity{2} {(y1,c) <- S.sample2();} 
          (true==>y0{1}=(y1,c){2})
          (true==> ={y1,c})=>//;2:by inline*;auto.
      by call sample_sample2;auto=> /=?[??]->.
    
    + proc;sp 1 1;if=>//.
      inline G1(DRestr(D)).C.f Gcol.C.f. 
      seq 5 5:
       (={RO.m,G1.mi,G1.paths,G1.m,G1.mhi,G1.chandle,G1.mh,G1.handles,C.c,b,
          p,h,i,sa} /\ i{1}=0 /\
        (G1.bcol{1} => G1.bcol{2}) /\
        card (rng G1.handles{2}) + 2*(size p{2}) <= 2 * C.c{2} + 1 /\
        Gcol.count{2} + size p{2} <= C.c{2} <= max_size);1:by auto=>/#.
      wp;if=>//;2:by auto;smt ml=0 w=size_ge0.
      call (_: ={RO.m});1:by sim.
      while 
       (={RO.m,G1.mi,G1.paths,G1.m,G1.mhi,G1.chandle,G1.mh,G1.handles,C.c,b,
          p,h,i,sa} /\ (i <= size p){1} /\
        (G1.bcol{1} => G1.bcol{2}) /\
        (card (rng G1.handles) + 2*(size p - i) <= 2 * C.c + 1 /\
        Gcol.count + size p - i <= C.c <= max_size){2});
        last by auto; smt ml=0 w=size_ge0.
      if=>//;auto;1:smt ml=0 w=size_ge0.
      call (_: ={RO.m});1:by sim.
      inline *;rcondt{2} 2. 
      + auto;progress;cut /#:= fcard_image_leq fst (rng G1.handles{hr}).
      auto;smt ml=0 w=(hinv_image card_rng_set).
    
    auto;progress;3:by smt ml=0.
    + by rewrite rng_set rem0 rng0 fset0U fcard1.
    by apply max_ge0. 
  qed.

