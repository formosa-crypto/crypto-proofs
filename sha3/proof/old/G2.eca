pragma -oldip.
require import Pred Fun Option Pair Int Real RealExtra StdOrder Ring StdBigop.
require import List FSet NewFMap Utils Common SLCommon RndO FelTactic Mu_mem.
(*...*) import Dprod Dexcepted Capacity IntOrder Bigreal RealOrder BRA.

require (*..*) Gcol.

clone export Gcol as Gcol0.

op bad_ext (m:smap) y = 
  mem (map snd (elems (dom m))) y \/
  mem (map snd (elems (rng m))) y.

op hinvc (m:(handle,capacity)fmap) (c:capacity) =
  find (+ pred1 c) m.

module G2(D:DISTINGUISHER,HS:FRO) = {

  module C = {
 
    proc f(p : block list): block = {
      var sa, sa';
      var h, i <- 0; 
      sa <- b0;
      if (1 <= size p /\ p <> [b0]) {
        while (i < size p ) {
          if (mem (dom G1.mh) (sa +^ nth witness p i, h)) {
            (sa, h) <- oget G1.mh.[(sa +^ nth witness p i, h)];
          } else {
            HS.sample(G1.chandle);
            sa'                 <@ F.RO.get(take (i+1) p);
            sa                  <- sa +^ nth witness p i;
            G1.mh.[(sa,h)]      <- (sa', G1.chandle);
            G1.mhi.[(sa',G1.chandle)] <- (sa, h);
            (sa,h)              <- (sa',G1.chandle);
            G1.chandle          <- G1.chandle + 1;
          }
          i        <- i + 1;
        }
        sa <- F.RO.get(p);
      }
      return sa;
    }
  }
 
  module S = {
 
    proc f(x : state): state = {
      var p, v, y, y1, y2, hy2, hx2, handles_,t;
 
      if (!mem (dom G1.m) x) {
        if (mem (dom G1.paths) x.`2) {
          (p,v) <- oget G1.paths.[x.`2]; 
          y1    <- F.RO.get (rcons p (v +^ x.`1));
          y2    <$ cdistr;
          y     <- (y1, y2);
          G1.paths.[y2] <- (rcons p (v +^ x.`1), y.`1);
        } else {
          y <$ dstate;
        }
        (* exists x h, mem (dom G1.m) x /\ handles.[h] = Some (x.2, I) *)
 
        handles_ <@ HS.restrK();
        if (!mem (rng handles_) x.`2) {
          HS.set(G1.chandle, x.`2);
          G1.chandle <- G1.chandle + 1;
        }
        handles_ <- HS.restrK();
        hx2      <- oget (hinvc handles_ x.`2);
        t        <@ HS.in_dom((oget G1.mh.[(x.`1,hx2)]).`2, Unknown);
        if (mem (dom G1.mh) (x.`1, hx2) /\ t) {
          hy2                  <- (oget G1.mh.[(x.`1, hx2)]).`2;
          y2                   <@ HS.get(hy2);
          G1.bext              <- G1.bext \/ bad_ext G1.m y2 \/ y2 = x.`2;
          y                    <- (y.`1, y2);
          G1.m.[x]             <- y;
          G1.mi.[y]            <- x;
        } else {
          hy2                  <- G1.chandle;
          G1.chandle           <- G1.chandle + 1;
          HS.set(hy2, y.`2); 
          G1.m.[x]             <- y;
          G1.mh.[(x.`1, hx2)]  <- (y.`1, hy2);
          G1.mi.[y]            <- x;
          G1.mhi.[(y.`1, hy2)] <- (x.`1, hx2);
        }
      } else {   
        y <- oget G1.m.[x];
      }
      return y;
    }
 
    proc fi(x : state): state = {
      var y, y1, y2, hx2, hy2, handles_, t;
 
      if (!mem (dom G1.mi) x) {
        handles_ <@ HS.restrK();
        if (!mem (rng handles_) x.`2) {
          HS.set(G1.chandle, x.`2);
          G1.chandle <- G1.chandle + 1;
        }
        handles_ <@ HS.restrK();
        hx2      <- oget (hinvc handles_ x.`2);
        y        <$ dstate;
        t        <@ HS.in_dom((oget G1.mhi.[(x.`1,hx2)]).`2, Unknown);
        if (mem (dom G1.mhi) (x.`1, hx2) /\ t) {
          (y1,hy2)             <- oget G1.mhi.[(x.`1, hx2)];
          y2                   <@ HS.get(hy2);
          y                    <- (y.`1, y2);
          G1.bext              <- G1.bext \/ bad_ext G1.m y2 \/ y2 = x.`2;
          G1.mi.[x]            <- y;
          G1.m.[y]             <- x;
        } else {
          hy2                  <- G1.chandle;
          G1.chandle           <- G1.chandle + 1;
          HS.set(hy2, y.`2); 
          G1.mi.[x]            <- y;
          G1.mhi.[(x.`1, hx2)] <- (y.`1, hy2);
          G1.m.[y]             <- x;
          G1.mh.[(y.`1, hy2)]  <- (x.`1, hx2);
        }
      } else {
        y <- oget G1.mi.[x];
      }
      return y;
    }
 
  }
 
  proc distinguish(): bool = {
    var b;
 
    F.RO.m     <- map0;
    G1.m     <- map0;
    G1.mi    <- map0;
    G1.mh    <- map0;
    G1.mhi   <- map0;
    G1.bext  <- false;
 
    (* the empty path is initially known by the adversary to lead to capacity 0^c *)
    HS.set(0,c0);
    G1.paths    <- map0.[c0 <- ([<:block>],b0)];
    G1.chandle  <- 1;
    b        <@ D(C,S).distinguish();
    return b;
  }    
}.

section.
  
  declare module D: DISTINGUISHER{G1, G2, FRO}.

  op inv_ext1 bext1 bext2 (G1m:smap) (FROm:handles) = 
    bext1 => (bext2 \/ exists x h, mem (dom G1m `|` rng G1m) x /\ FROm.[h] = Some (x.`2, Unknown)).

  lemma rng_restr (m : ('from, 'to * 'flag) fmap) f x:
     mem (rng (restr f m)) x <=> mem (rng m) (x,f).
  proof.
    rewrite !in_rng;split=>-[z]H;exists z;move:H;rewrite restrP; case m.[z]=>//=.
    by move=> [t f'] /=;case (f'=f).
  qed.

  equiv G1_G2 : G1(D).main ~ Eager(G2(D)).main1 : 
     ={glob D} ==> ={res} /\ inv_ext1 G1.bext{1} G1.bext{2} G1.m{2} FRO.m{2}.
  proof.
    proc;inline{2} FRO.init G2(D, FRO).distinguish;wp.
    call (_: ={F.RO.m,G1.m,G1.mi,G1.mh,G1.mhi,G1.paths,G1.chandle,FRO.m} /\
             inv_ext1 G1.bext{1} G1.bext{2} G1.m{2} FRO.m{2} /\
             (forall h, mem (dom FRO.m) h => h < G1.chandle){1}).
    + proc;if=>//;last by auto.
      seq 1 1: (={F.RO.m,G1.m,G1.mi,G1.mh,G1.mhi,G1.paths,G1.chandle,FRO.m,x,y} /\
                inv_ext1 G1.bext{1} G1.bext{2} G1.m{2} FRO.m{2} /\
                (forall h, mem (dom FRO.m) h => h < G1.chandle){1} /\
                ! mem (dom G1.m{1}) x{1}).
      + by if=>//;auto;call (_: ={F.RO.m});[sim |auto].
      seq 3 5: 
        (={F.RO.m,G1.m,G1.mi,G1.mh,G1.mhi,G1.paths,G1.chandle,FRO.m,hx2,x,y,hx2} /\
         t{2} = (in_dom_with FRO.m (oget G1.mh.[(x.`1, hx2)]).`2 Unknown){1} /\
         (G1.bext{1} => (G1.bext{2} \/ (mem (rng FRO.m) (x.`2, Unknown)){2} \/
                         exists x h, mem (dom G1.m{2} `|` rng G1.m{2}) x /\ 
                           FRO.m{2}.[h] = Some (x.`2, Unknown))) /\
        (forall h, mem (dom FRO.m) h => h < G1.chandle){1} /\
        ! mem (dom G1.m{1}) x{1}).
      + inline *;auto=> &ml&mr[*]10!-> Hi Hhand -> /=.
        rewrite -dom_restr rng_restr /=;progress; 3:by smt ml=0.
        + rewrite rng_set !inE rem_id 1:/#;move:H0=>[/Hi[->|[x' h][]H1 H2]|->]//.
          right;right;exists x', h;rewrite getP. 
          by cut ->//:(h<> G1.chandle{mr});move:(Hhand h);rewrite in_dom H2 /#.
        by move:H0;rewrite dom_set !inE /#.
      if=>//.
      + inline *;rcondt{2} 4.
        + by move=> &m;auto;rewrite /in_dom_with.
        auto;progress. 
        + by apply  DWord.cdistr_ll.
        + rewrite /inv_ext1=>/H{H}[->//|[/in_rng[h]Hh|[[x1 x2] h [Hx Hh]]]].
          + case (h = (oget G1.mh{2}.[(x{2}.`1, hx2{2})]).`2)=> [->>|Hneq].
            + by left;rewrite Hh oget_some.
            by right;exists x{2}, h;rewrite dom_set getP Hneq !inE.
          case (h = (oget G1.mh{2}.[(x{2}.`1, hx2{2})]).`2)=> [->>|Hneq].                           + rewrite Hh /bad_ext oget_some /= !mem_map_snd. 
            by left;right;left <@ Hx;rewrite !inE=>-[|]Hx;[left|right];exists x1;
             rewrite -memE.
          right;exists (x1,x2), h;rewrite dom_set rng_set getP Hneq rem_id //=.
          by move:Hx;rewrite !inE Hh=>-[]->.
        by move:H6 H2;rewrite /in_dom_with dom_set !inE /#.
      inline *;auto;progress;last by move:H3;rewrite dom_set !inE /#.
      rewrite /inv_ext1=> /H [->//|[/in_rng[h]Hh|[x' h [Hx Hh]]]].
      + right;exists x{2}, h;rewrite getP dom_set !inE /=. 
        by move:(H0 h);rewrite in_dom Hh /#.
      right;exists x', h;rewrite getP dom_set !inE. 
      move:(H0 h) Hx;rewrite in_dom rng_set Hh !inE rem_id //= /#.

    + proc;if=>//;last by auto.
      seq 4 6: 
        (={F.RO.m,G1.m,G1.mi,G1.mh,G1.mhi,G1.paths,G1.chandle,FRO.m,hx2,x,y,hx2} /\
         t{2} = (in_dom_with FRO.m (oget G1.mhi.[(x.`1, hx2)]).`2 Unknown){1} /\
         (G1.bext{1} => (G1.bext{2} \/ (mem (rng FRO.m) (x.`2, Unknown)){2} \/
                         exists x h, mem (dom G1.m{2}  `|` rng G1.m{2}) x /\ 
                           FRO.m{2}.[h] = Some (x.`2, Unknown))) /\
        (forall h, mem (dom FRO.m) h => h < G1.chandle){1} /\
        ! mem (dom G1.mi{1}) x{1}).
      + inline *;auto=> &ml&mr[*]9!-> Hi Hhand -> /=.
        rewrite -dom_restr rng_restr /=;progress; 3:by smt ml=0.
        + rewrite rng_set !inE rem_id 1:/#;move:H2=>[/Hi[->|[x' h][]HH1 HH2]|->]//.
          right;right;exists x', h;rewrite getP. 
          by cut ->//:(h<> G1.chandle{mr});move:(Hhand h);rewrite in_dom HH2 /#.
        by move:H2;rewrite dom_set !inE /#.
      if=>//.
      + inline *;rcondt{2} 4.
        + by move=> &m;auto;rewrite /in_dom_with.
        auto;progress. 
        + by apply  DWord.cdistr_ll.
        + rewrite /inv_ext1=>/H{H}[->//|[/in_rng[h]Hh|[[x1 x2] h [Hx Hh]]]].
          + case (h = (oget G1.mhi{2}.[(x{2}.`1, hx2{2})]).`2)=> [->>|Hneq /=].
            + by left;rewrite Hh oget_some.
            by right;exists x{2}, h;rewrite rng_set getP Hneq !inE.
          case (h = (oget G1.mhi{2}.[(x{2}.`1, hx2{2})]).`2)=> [->>|Hneq].                          + rewrite Hh /bad_ext oget_some /= !mem_map_snd.
            by left;right;left <@ Hx;rewrite !inE=>-[|]?;[left|right];
               exists x1;rewrite -memE.
          right;exists (x1,x2), h;rewrite dom_set rng_set getP Hneq !inE Hh /= rng_rem.
          move:Hx;rewrite !inE in_rng.      


search mem rng. 
print rngP.

          case ((x1,x2) = 
            (y{2}.`1, (oget FRO.m{2}.[(oget G1.mhi{2}.[(x{2}.`1, hx2{2})]).`2]).`1))=>
          [/=->//|Hneq'].
          right;left;exists (x1,x2);rewrite Hneq'.
          move:Hx;rewrite inE in_rng=>-[->//|[[a1 a2]]] /#.
search mem rng.
search rng rem.
 Hh.
 Hx.
        by move:H6 H2;rewrite /in_dom_with dom_set !inE /#.
      inline *;auto;progress;last by move:H3;rewrite dom_set !inE /#.
      rewrite /inv_ext1=> /H [->//|[/in_rng[h]Hh|[x' h [Hx Hh]]]].
      + right;exists x{2}, h;rewrite getP dom_set !inE /=. 
        by move:(H0 h);rewrite in_dom Hh /#.
      right;exists x', h;rewrite getP dom_set !inE. 
      by move:(H0 h);rewrite in_dom Hh Hx /#.
 


    (************)
    inline*;auto.
  
      auto=> //.
sim.        
    admit.
  qed.

  equiv Eager_1_2: Eager(G2(D)).main1 ~ Eager(G2(D)).main2 : 
    ={glob G2(D)} ==> ={G1.m,FRO.m,G1.bext}.
  proof. by conseq (Eager_1_2 (G2(D))). qed.

end section.

section EXT.

  declare module D: DISTINGUISHER{C, PF, G1, G2 }.

  local module ReSample = {
    var count:int  
    proc f (x:handle) = {
      var c;
      c <$ cdistr;
      if (card (dom G1.m) < max_size /\ count < max_size) {
        G1.bext              <- G1.bext \/ bad_ext G1.m c;
        FRO.m.[x] <- (c,Unknown);
      }
    }
  }.

  local module Gext = {

    proc resample () = {
      Iter(ReSample).iter (elems (dom (restr Unknown FRO.m)));
    }
  
    module C = {
   
      proc f(p : block list): block = {
        var sa, sa';
        var h, i <- 0; 
        sa <- b0;
        if (1 <= size p /\ p <> [b0]) {
          while (i < size p ) {
            if (mem (dom G1.mh) (sa +^ nth witness p i, h)) {
              (sa, h) <- oget G1.mh.[(sa +^ nth witness p i, h)];
            } else {
              RRO.sample(G1.chandle);
              sa'                 <@ F.RO.get(take (i+1) p);
              sa                  <- sa +^ nth witness p i;
              G1.mh.[(sa,h)]      <- (sa', G1.chandle);
              G1.mhi.[(sa',G1.chandle)] <- (sa, h);
              (sa,h)              <- (sa',G1.chandle);
              G1.chandle          <- G1.chandle + 1;
            }
            i        <- i + 1;
          }
          sa <- F.RO.get(p);
        }
        return sa;
      }
    }
   
    module S = {
   
      proc f(x : state): state = {
        var p, v, y, y1, y2, hy2, hx2, handles_,t;
   
        if (!mem (dom G1.m) x) {
          if (mem (dom G1.paths) x.`2) {
            (p,v) <- oget G1.paths.[x.`2]; 
            y1    <- F.RO.get (rcons p (v +^ x.`1));
            y2    <$ cdistr;
            y     <- (y1, y2);
            G1.paths.[y2] <- (rcons p (v +^ x.`1), y.`1);
          } else {
            y <$ dstate;
          }
          (* exists x h, mem (dom G1.m) x /\ handles.[h] = Some (x.2, I) *)
   
          handles_ <@ RRO.restrK();
          if (!mem (rng handles_) x.`2) {
            RRO.set(G1.chandle, x.`2);
            G1.chandle <- G1.chandle + 1;
          }
          handles_ <- RRO.restrK();
          hx2      <- oget (hinvc handles_ x.`2);
          t        <@ RRO.in_dom((oget G1.mh.[(x.`1,hx2)]).`2, Unknown);
          if (mem (dom G1.mh) (x.`1, hx2) /\ t) {
            hy2                  <- (oget G1.mh.[(x.`1, hx2)]).`2;
            ReSample.f(hy2);
            y2                   <@ RRO.get(hy2);
            y                    <- (y.`1, y2);
            G1.m.[x]             <- y;
            G1.mi.[y]            <- x;
          } else {
            hy2                  <- G1.chandle;
            G1.chandle           <- G1.chandle + 1;
            RRO.set(hy2, y.`2); 
            G1.m.[x]             <- y;
            G1.mh.[(x.`1, hx2)]  <- (y.`1, hy2);
            G1.mi.[y]            <- x;
            G1.mhi.[(y.`1, hy2)] <- (x.`1, hx2);
          }
        } else {   
          y <- oget G1.m.[x];
        }
        return y;
      }
   
      proc fi(x : state): state = {
        var y, y1, y2, hx2, hy2, handles_, t;
   
        if (!mem (dom G1.mi) x) {
          handles_ <@ RRO.restrK();
          if (!mem (rng handles_) x.`2) {
            RRO.set(G1.chandle, x.`2);
            G1.chandle <- G1.chandle + 1;
          }
          handles_ <@ RRO.restrK();
          hx2      <- oget (hinvc handles_ x.`2);
          y        <$ dstate;
          t        <@ RRO.in_dom((oget G1.mh.[(x.`1,hx2)]).`2, Unknown);
          if (mem (dom G1.mhi) (x.`1, hx2) /\ t) {
            (y1,hy2)             <- oget G1.mhi.[(x.`1, hx2)];
            ReSample.f(hy2);
            y2                   <@ RRO.get(hy2);
            y                    <- (y.`1, y2);

            G1.mi.[x]            <- y;
            G1.m.[y]             <- x;
          } else {
            hy2                  <- G1.chandle;
            G1.chandle           <- G1.chandle + 1;
            RRO.set(hy2, y.`2); 
            G1.mi.[x]            <- y;
            G1.mhi.[(x.`1, hx2)] <- (y.`1, hy2);
            G1.m.[y]             <- x;
            G1.mh.[(y.`1, hy2)]  <- (x.`1, hx2);
          }
        } else {
          y <- oget G1.mi.[x];
        }
        return y;
      }
   
    }
   
    proc distinguish(): bool = {
      var b;
   
      F.RO.m   <- map0;
      G1.m     <- map0;
      G1.mi    <- map0;
      G1.mh    <- map0;
      G1.mhi   <- map0;
      G1.bext  <- false;
      ReSample.count <- 0;
      FRO.m    <- map0;
   
      (* the empty path is initially known by the adversary to lead to capacity 0^c *)
      RRO.set(0,c0);
      G1.paths    <- map0.[c0 <- ([<:block>],b0)];
      G1.chandle  <- 1;
      b        <@ D(C,S).distinguish();
      resample();
      return b;
    }    
  }.
  
  local equiv EG2_Gext : Eager(G2(DRestr(D))).main2 ~ Gext.distinguish: 
     ={glob D} ==> 
       (G1.bext{1} \/ 
         exists x h, mem (dom G1.m{1}) x /\ FRO.m{1}.[h] = Some (x.`2, Unknown)) =>
        G1.bext{2}.
   proof.
     admit.     
   qed.

   local lemma Pr_ext &m: 
      Pr[Gext.distinguish()@ &m : G1.bext] <= (max_size^2)%r / (2^c)%r.
   proof. 
     admit. 
   qed.


end section EXT.


    
