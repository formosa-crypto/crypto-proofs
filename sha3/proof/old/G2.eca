require import Pred Fun Option Pair Int Real RealExtra StdOrder Ring StdBigop.
require import List FSet NewFMap Utils Common SLCommon RndO FelTactic Mu_mem.
(*...*) import Dprod Dexcepted Capacity IntOrder Bigreal RealOrder BRA.

require (*..*) Gcol.

clone export Gcol as Gcol0.

op bad_ext (m:smap) y = 
  mem (map snd (elems (dom m))) y.

op hinvc (m:(handle,capacity)fmap) (c:capacity) =
  find (+ pred1 c) m.

module G2(D:DISTINGUISHER,HS:FRO) = {

  module C = {
 
    proc f(p : block list): block = {
      var sa, sa';
      var h, i <- 0; 
      sa <- b0;
      if (1 <= size p /\ p <> [b0]) {
        while (i < size p ) {
          if (mem (dom G1.mh) (sa +^ nth witness p i, h)) {
            (sa, h) <- oget G1.mh.[(sa +^ nth witness p i, h)];
          } else {
            HS.sample(G1.chandle);
            sa'                 <@ F.RO.get(take (i+1) p);
            sa                  <- sa +^ nth witness p i;
            G1.mh.[(sa,h)]      <- (sa', G1.chandle);
            G1.mhi.[(sa',G1.chandle)] <- (sa, h);
            (sa,h)              <- (sa',G1.chandle);
            G1.chandle             <- G1.chandle + 1;
          }
          i        <- i + 1;
        }
        sa <- F.RO.get(p);
      }
      return sa;
    }
  }
 
  module S = {
 
    proc f(x : state): state = {
      var p, v, y, y1, y2, hy2, hx2, handles_,t;
 
      if (!mem (dom G1.m) x) {
        if (mem (dom G1.paths) x.`2) {
          (p,v) <- oget G1.paths.[x.`2]; 
          y1    <- F.RO.get (rcons p (v +^ x.`1));
          y2    <$ cdistr;
          y     <- (y1, y2);
          G1.paths.[y2] <- (rcons p (v +^ x.`1), y.`1);
        } else {
          y <$ dstate;
        }
        (* exists x h, mem (dom G1.m) x /\ handles.[h] = Some (x.2, I) *)
 
        handles_ <@ HS.restrK();
        if (!mem (rng handles_) x.`2) {
          HS.set(G1.chandle, x.`2);
          G1.chandle <- G1.chandle + 1;
        }
        handles_ <- HS.restrK();
        hx2      <- oget (hinvc handles_ x.`2);
        t        <@ HS.in_dom((oget G1.mh.[(x.`1,hx2)]).`2, Unknown);
        if (mem (dom G1.mh) (x.`1, hx2) /\ t) {
          hy2                  <- (oget G1.mh.[(x.`1, hx2)]).`2;
          y2                   <@ HS.get(hy2);
          G1.bext              <- G1.bext \/ bad_ext G1.m y2;
          y                    <- (y.`1, y2);
          G1.m.[x]             <- y;
          G1.mi.[y]            <- x;
        } else {
          hy2                  <- G1.chandle;
          G1.chandle           <- G1.chandle + 1;
          HS.set(hy2, y.`2); 
          G1.m.[x]             <- y;
          G1.mh.[(x.`1, hx2)]  <- (y.`1, hy2);
          G1.mi.[y]            <- x;
          G1.mhi.[(y.`1, hy2)] <- (x.`1, hx2);
        }
      } else {   
        y <- oget G1.m.[x];
      }
      return y;
    }
 
    proc fi(x : state): state = {
      var y, y1, y2, hx2, hy2, handles_, t;
 
      if (!mem (dom G1.mi) x) {
        handles_ <@ HS.restrK();
        if (!mem (rng handles_) x.`2) {
          HS.set(G1.chandle, x.`2);
          G1.chandle <- G1.chandle + 1;
        }
        handles_ <@ HS.restrK();
        hx2      <- oget (hinvc handles_ x.`2);
        y        <$ dstate;
        t        <@ HS.in_dom((oget G1.mh.[(x.`1,hx2)]).`2, Unknown);
        if (mem (dom G1.mhi) (x.`1, hx2) /\ t) {
          (y1,hy2)             <- oget G1.mhi.[(x.`1, hx2)];
          y2                   <@ HS.get(hy2);
          y                    <- (y.`1, y2);
          G1.bext              <- G1.bext \/ bad_ext G1.m y2;
          G1.mi.[x]            <- y;
          G1.m.[y]             <- x;
        } else {
          hy2                  <- G1.chandle;
          G1.chandle           <- G1.chandle + 1;
          HS.set(hy2, y.`2); 
          G1.mi.[x]            <- y;
          G1.mhi.[(x.`1, hx2)] <- (y.`1, hy2);
          G1.m.[y]             <- x;
          G1.mh.[(y.`1, hy2)]  <- (x.`1, hx2);
        }
      } else {
        y <- oget G1.mi.[x];
      }
      return y;
    }
 
  }
 
  proc main(): bool = {
    var b;
 
    F.RO.m     <- map0;
    G1.m     <- map0;
    G1.mi    <- map0;
    G1.mh    <- map0;
    G1.mhi   <- map0;
    G1.bext  <- false;
 
    (* the empty path is initially known by the adversary to lead to capacity 0^c *)
    HS.init();
    HS.set(0,c0);
    G1.paths    <- map0.[c0 <- ([<:block>],b0)];
    G1.chandle  <- 1;
    b        <@ D(C,S).distinguish();
    return b;
  }    
}.

section EXT.
  
  declare module D: DISTINGUISHER{C, PF, G1, G2}.
  
  equiv G1_G2 : G1(D).main ~ G2(D,FRO).main : 
     ={glob D} ==> ={res} /\ G1.bext{1} => (G1.bext{2} \/ 
         exists x h, mem (dom G1.m{2}) x /\ FRO.m{2}.[h] = Some (x.`2, Unknown)).
  proof.
    proc.  
    admit.
  qed.

end section EXT.


    
