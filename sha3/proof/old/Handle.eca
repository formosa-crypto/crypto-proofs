require import Pred Fun Option Pair Int Real StdOrder Ring.
require import List FSet NewFMap Utils Common SLCommon.
(*...*) import Dprod Dexcepted Capacity IntOrder.

require ConcreteF.

module G1(D:DISTINGUISHER) = {
  var m, mi               : smap
  var mh, mhi             : hsmap
  var handles             : handles
  var chandle             : int
  var paths               : (capacity, block list * block) fmap
  var bext, bcol          : bool


  module C = {

    proc f(p : block list): block = {
      var sa, sa', sc;
      var h, i <- 0; 
      sa <- b0;
      if (1 <= size p /\ p <> [b0]) {
        while (i < size p ) {
          if (mem (dom mh) (sa +^ nth witness p i, h)) {
            (sa, h) <- oget mh.[(sa +^ nth witness p i, h)];
          } else {
            sc                  <$ cdistr;
            bcol                <- bcol \/ hinv handles sc <> None;
            sa'                 <- RO.f(take (i+1) p);
            sa                  <- sa +^ nth witness p i;
            mh.[(sa,h)]         <- (sa', chandle);
            mhi.[(sa',chandle)] <- (sa, h);
            (sa,h)              <- (sa',chandle);
            handles.[chandle]   <- (sc,I);
            chandle             <- chandle + 1;
          }
          i        <- i + 1;
        }
        sa <- RO.f(p);
      }
      return sa;
    }
  }

  module S = {

    proc f(x : state): state = {
      var p, v, y, y1, y2, hy2, hx2;

      if (!mem (dom m) x) {
        if (mem (dom paths) x.`2) {
          (p,v) <- oget paths.[x.`2]; 
          y1    <- RO.f (rcons p (v +^ x.`1));
          y2    <$ cdistr;
          y     <- (y1, y2);
          paths.[y2] <- (rcons p (v +^ x.`1), y.`1);
        } else {
          y <$ dstate;
        }
        bext <- bext \/ mem (rng handles) (x.`2, I);   
          (*  exists x2 h, handles.[h] = Some (X2,I) *)
        if (!(mem (rng handles) (x.`2, D))) {
          handles.[chandle] <- (x.`2, D);
          chandle <- chandle + 1;
        }
        hx2 <- oget (hinvD handles x.`2);
        if (mem (dom mh) (x.`1, hx2) /\ (oget handles.[(oget mh.[(x.`1,hx2)]).`2]).`2 = I) {
          hy2               <- (oget mh.[(x.`1, hx2)]).`2;
          y                 <- (y.`1, (oget handles.[hy2]).`1);
          handles.[hy2]     <- (y.`2, D);
          (* bad               <- bad \/ mem X2 y.`2; *)
          m.[x]             <- y;
          mi.[y]            <- x;
        } else {
          bcol              <- bcol \/ hinv handles y.`2 <> None;          
          hy2               <- chandle;
          chandle           <- chandle + 1;
          handles.[hy2]     <- (y.`2, D);
          m.[x]             <- y;
          mh.[(x.`1, hx2)]  <- (y.`1, hy2);
          mi.[y]            <- x;
          mhi.[(y.`1, hy2)] <- (x.`1, hx2);
        }
      } else {   
        y <- oget m.[x];
      }
      return y;
    }

    proc fi(x : state): state = {
      var y, y1, hx2, hy2;

      if (!mem (dom mi) x) {
        bext <- bext \/ mem (rng handles) (x.`2, I);   
          (*  exists x2 h, handles.[h] = Some (X2,I) *)
        if (!(mem (rng handles) (x.`2, D))) {
          handles.[chandle] <- (x.`2, D);
          chandle <- chandle + 1;
        }
        hx2 <- oget (hinvD handles x.`2);
        y                 <$ dstate;
        if (mem (dom mhi) (x.`1, hx2) /\ (oget handles.[(oget mh.[(x.`1,hx2)]).`2]).`2 = I) {
          (y1,hy2)          <- oget mhi.[(x.`1, hx2)];
          y                 <- (y.`1, (oget handles.[hy2]).`1);
          handles.[hy2]     <- (y.`2, D);
          (* bad               <- bad \/ mem X2 y.`2; *)
          mi.[x]            <- y;
          mhi.[(x.`1, hx2)] <- (y.`1, hy2);
          m.[y]             <- x;
          mh.[(y.`1, hy2)]  <- (x.`1, hx2);
        } else {
          bcol              <- bcol \/ hinv handles y.`2 <> None;          
          hy2               <- chandle;
          chandle           <- chandle + 1;
          handles.[hy2]     <- (y.`2, D);
          mi.[x]            <- y;
          mhi.[(x.`1, hx2)] <- (y.`1, hy2);
          m.[y]             <- x;
          mh.[(y.`1, hy2)]  <- (x.`1, hx2);
        }
      } else {
        y <- oget mi.[x];
      }
      return y;
    }

  }

  proc main(): bool = {
    var b;

    RO.m     <- map0;
    m        <- map0;
    mi       <- map0;
    mh       <- map0;
    mhi      <- map0;
    bext     <- false;
    bcol     <- false;

    (* the empty path is initially known by the adversary to lead to capacity 0^c *)
    handles  <- map0.[0 <- (c0, D)];
    paths    <- map0.[c0 <- ([<:block>],b0)];
    chandle  <- 1;
    b        <@ D(C,S).distinguish();
    return b;
  }    
}.

(* -------------------------------------------------------------------------- *)

op eqm_handles (handles:handles) (m:smap) (mh:hsmap) =
  (forall bc bc', m.[bc] = Some bc' => 
     exists h h' f f', 
       handles.[h ]    = Some(bc .`2,f ) /\ 
       handles.[h']    = Some(bc'.`2,f') /\
       mh.[(bc.`1, h)] = Some (bc'.`1,h')) /\
  (forall bh bh', mh.[bh] = Some bh' =>
     exists c c' f f', 
       handles.[bh .`2] = Some(c ,f) /\ 
       handles.[bh'.`2] = Some(c',f') /\
       m.[(bh.`1, c)]   = Some (bh'.`1,c')).

op mh_spec (handles:handles) (m2:smap) (mh:hsmap) (ro:(block list, block)fmap) = 
  (forall bh bh', mh.[bh] = Some bh' =>
    exists c f c' f', 
      handles.[bh .`2]=Some(c,f) /\
      handles.[bh'.`2]=Some(c',f') /\
      if f' = D then m2.[(bh.`1,c)] = Some(bh'.`1,c') /\ f = D
      else 
        exists p v b, 
          ro.[rcons p b] = Some bh'.`1 /\
          build_hpath mh p = Some(v,bh.`2) /\
          bh.`1 = v +^ b) /\
  (forall p b, mem (dom ro) (rcons p b) <=>
     exists v h h', 
       build_hpath mh p = Some (v,h) /\
       mh.[(v +^ b,h)] = Some (oget ro.[rcons p b], h')).

op paths_spec (handles:handles) (mh:hsmap) (paths:(capacity,block list * block)fmap) = 
  forall c p v, paths.[c] = Some(p,v) <=> 
    exists h, 
      build_hpath mh p = Some(v,h) /\ 
      handles.[h] = Some(c,D).

op handles_spec handles chandle = 
  huniq handles /\ handles.[0] = Some (c0,D) /\ forall h, mem (dom handles) h => h < chandle.

op INV_CF_G1 (handles:handles) chandle (m1 mi1 m2 mi2:smap) (mh2 mhi2:hsmap) (ro:(block list, block) fmap) paths =
   (eqm_handles handles m1 mh2 /\ eqm_handles handles mi1 mhi2) /\ 
   (incl m2 m1 /\ incl mi2 mi1) /\ 
   (mh_spec handles m2 mh2 ro /\ paths_spec handles mh2 paths /\ handles_spec handles chandle).

lemma eqm_dom_mh_m handles m mh hx2 f (x:state): 
  eqm_handles handles m mh =>
  handles.[hx2] = Some (x.`2, f) =>
  mem (dom mh) (x.`1, hx2) => mem (dom m) x.
proof.
  move=>[]H1 H2 Hhx2;rewrite !in_dom.
  case: (mh.[_]) (H2 (x.`1,hx2))=> //= bh' /(_ bh') [c c' f1 f1'].
  by rewrite Hhx2=> /= -[][]<<- _;case:(x)=> ??[]_->.
qed.

lemma chandle_ge0 handles chandle : handles_spec handles chandle => 0 < chandle.
proof. by move=>[]_[]Heq Hlt;apply Hlt;rewrite in_dom Heq. qed.

lemma chandle_0 handles chandle : handles_spec handles chandle => 0 <> chandle.
proof.  move=> Hh;apply /IntOrder.ltr_eqF/(chandle_ge0 _ _ Hh). qed.

lemma eqm_up_handles handles chandle m mh x2 : 
   handles_spec handles chandle =>
   eqm_handles handles m mh => 
   eqm_handles handles.[chandle <- (x2, D)] m mh.
proof.
  move=> []Hu[Hh0 Hlt][]H1 H2;split=>
   [bc bc'/H1 [h h' f f'][]Hh[]Hh' Hmh| bh bh'/H2 [c c' f f'][]Hh []Hh' Hm]. 
  + exists h,h',f,f';rewrite !getP Hmh/=-Hh-Hh'(_:h<>chandle)2:(_:h'<>chandle) //. 
    + by apply /IntOrder.ltr_eqF/Hlt;rewrite in_dom Hh.
    by apply /IntOrder.ltr_eqF/Hlt;rewrite in_dom Hh'.
  exists c,c',f,f';rewrite !getP Hm/=-Hh-Hh'(_:bh.`2<>chandle)2:(_:bh'.`2<>chandle) //. 
  + by apply /IntOrder.ltr_eqF/Hlt;rewrite in_dom Hh.
  by apply /IntOrder.ltr_eqF/Hlt;rewrite in_dom Hh'.
qed.

lemma mh_up_handles handles chandle m2 mh ro cf: 
   handles_spec handles chandle =>
   mh_spec handles m2 mh ro =>
   mh_spec handles.[chandle <- cf] m2 mh ro.
proof.
  move=> Hh Hmh.
  move:Hmh Hh=>[H1 ?][_[]_ Hlt];split=>// bh bh' /H1 [c f c' f'][]Hh[]Hh' Hif.
  exists c,f,c',f';rewrite Hif-Hh-Hh'!getP(_:bh.`2<>chandle)2:(_:bh'.`2<>chandle) //. 
  + by apply /IntOrder.ltr_eqF/Hlt;rewrite in_dom Hh.
  by apply /IntOrder.ltr_eqF/Hlt;rewrite in_dom Hh'.
qed.

lemma paths_up_handles m2 ro handles mh paths cf chandle:
  mh_spec handles m2 mh ro => 
  handles_spec handles chandle =>
  paths_spec handles mh paths =>
  paths_spec handles.[chandle <- cf] mh paths.
proof.
  move=> Hmh Hh Hp c p v;rewrite Hp;apply NewLogic.exists_iff=> h/=;split=> -[^Hbu->] /=;
    rewrite getP.
  + move:Hh=>[]_[]_/(_ h)Hlt Hh;rewrite (_:h<>chandle)//.
    by apply /IntOrder.ltr_eqF/Hlt;rewrite in_dom Hh.
  rewrite (_:h<>chandle)//.
  cut [[]_[]_->|[p' b v' h'[]_[]_ Hh']]:= build_hpathP _ _ _ _ Hbu.
  + by rewrite (chandle_0 _ _ Hh).
  move:Hh=>[]_[]_/(_ h)Hlt;apply /IntOrder.ltr_eqF/Hlt;rewrite in_dom. 
  by cut [/(_ _ _ Hh')[????][]_[]->]:= Hmh.
qed.

lemma handles_up_handles handles chandle x2 f':
  (forall (f : caller), ! mem (rng handles) (x2, f)) =>
  handles_spec handles chandle =>
  handles_spec handles.[chandle <- (x2, f')] (chandle + 1).
proof.
  move=> Hx2^Hh[]Hu[]Hh0 Hlt;split;[ | split].
  + move=> h1 h2 [c1 f1] [c2 f2];rewrite !getP.
    case (h1=chandle)=>[->/=[]->> ->|_]; (case (h2=chandle)=>[->//=|_]).
    + by move=>Heq ->>;move:(Hx2 f2);rewrite in_rng NewLogic.negb_exists=>/=/(_ h2);
       rewrite Heq. 
    + by move=>Heq[]->> <<- ->>;move:(Hx2 f1);rewrite in_rng NewLogic.negb_exists=>/=/(_ h1);
      rewrite Heq. 
    by apply Hu.
  + by rewrite getP (chandle_0 _ _ Hh).
  move=>h;rewrite dom_set !inE /#. 
qed.

lemma INV_CF_G1_up_handles handles chandle m1 mi1 m2 mi2 mh mhi ro paths x2:
   INV_CF_G1 handles chandle m1 mi1 m2 mi2 mh mhi ro paths =>
   (forall f, ! mem (rng handles) (x2, f)) => 
   INV_CF_G1 handles.[chandle <- (x2, D)](chandle+1) m1 mi1 m2 mi2 mh mhi ro paths.
proof.
  move=>[][]Heqm Heqmi[]Hincl[]Hmh[]Hp Hh Hx2;split.
  + by split;apply eqm_up_handles.
  split=>//;split;[|split].
  + by apply mh_up_handles. 
  + by apply (paths_up_handles m2 ro).
  by apply handles_up_handles.
qed.

clone export ConcreteF as ConcreteF1.

section AUX.

  declare module D : DISTINGUISHER {PF, RO, G1}.

  axiom D_ll (F <: DFUNCTIONALITY{D}) (P <: DPRIMITIVE{D}):
    islossless P.f => islossless P.fi => islossless F.f => 
    islossless D(F, P).distinguish.

  equiv CF_G1 : CF(D).main ~ G1(D).main: 
                 ={glob D} ==> !(G1.bcol \/ G1.bext){2} => ={res}.
  proof.
    proc.
    call (_:(G1.bcol \/ G1.bext), INV_CF_G1 G1.handles{2} G1.chandle{2} PF.m{1} PF.mi{1} G1.m{2} G1.mi{2} G1.mh{2} G1.mhi{2} RO.m{2} G1.paths{2}).   
    (* lossless D *)
    + apply D_ll.
    (** proofs for G1.S.f *)
    (* equiv PF.P.f G1.S.f *)
    + proc;if{1}=>/=.
      (* x is not in m{1} so forall h, (x.1,h) is not in mh{2} *)
      + rcondt{2} 1.
        + move=> &hr;skip=> &hr'[][]_[]<-[]_[][]Hincl Hincli _. 
          rewrite !in_dom/==>H; by case:(G1.m{hr'}.[x{hr}]) (Hincl x{hr})=> //=;rewrite H.
        exists* RO.m{2}, G1.paths{2};elim*=>ro0 paths0.
        seq 1 2 : (!G1.bcol{2} /\ (G1.bext = mem (rng G1.handles) (x.`2, I)){2} /\
                   ={x,y} /\
                   INV_CF_G1 G1.handles{2} G1.chandle{2} PF.m{1} PF.mi{1} G1.m{2} G1.mi{2} G1.mh{2} G1.mhi{2} ro0 paths0 /\
                  ! mem (dom PF.m{1}) x{1} /\
                  (if mem (dom paths0) x.`2 then 
                     let (p,v) = oget paths0.[x.`2] in
                     RO.m{2}  = ro0.[rcons p (v+^x.`1) <- y.`1] /\ 
                     G1.paths = paths0.[y.`2 <- (rcons p (v +^ x.`1), y.`1)]
                   else RO.m = ro0 /\ G1.paths = paths0){2}).
        + wp 1 1;conseq (_: ={y} /\
                            if mem (dom paths0) x{2}.`2 then
                              let (p0, v0) = oget paths0.[x{2}.`2] in
                              RO.m{2} = ro0.[rcons p0 (v0 +^ x{2}.`1) <- y{2}.`1] /\
                              G1.paths{2} = paths0.[y{2}.`2 <- (rcons p0 (v0 +^ x{2}.`1), y{2}.`1)]
                            else RO.m{2} = ro0 /\ G1.paths{2} = paths0);1:smt ml=0.
          if{2};2:by auto=>/#.
          inline{2} RO.f;rcondt{2} 4.
           + move=> &ml;auto=>/= &mr[][]_[][]_[]->[][][]_ Heqm _[]_[][]_ Hro[] Hpath _ HnPFm.
            rewrite in_dom;case:(G1.paths{mr}.[_]) (Hpath x{mr}.`2)=>//[[p v]]/(_ p v)/=[h][]Hbu Hh b _.
            rewrite -not_def=> /Hro [??h'];rewrite oget_some Hbu => -[][]<- <- /=.
            rewrite  Block.xorwA Block.xorwK Block.xorwC Block.xorw0 -not_def=>/Heqm [c c' f f'].
            by rewrite Hh=> -[][]<- _[]_ Hm;move:HnPFm;rewrite in_dom;case:(x{mr}) Hm=> ??->.
          swap{2} 3-2;swap{2}6-4;wp;conseq (_:y{1} =(rd,y2){2}).
          + progress [-split];rewrite getP_eq oget_some H2/=.
            by move:H2;rewrite in_dom;case:(G1.paths{2}.[_]).
          transitivity{1} {y <- S.sample();} (true ==> ={y}) (true==>y{1}=(rd,y2){2})=>//;1:by inline*;auto.
          transitivity{2} {(rd,y2) <- S.sample2();} (true==>y{1}=(rd,y2){2}) (true==> ={rd,y2})=>//;2:by inline*;auto.
          by call sample_sample2;auto=> /=?[??]->.
        case (mem (rng G1.handles{2}) (x{2}.`2, I)).
        + conseq (_:true);[by move=> ??[][]_[]->_->|auto].
        conseq (_: !G1.bcol{2} => 
               oget PF.m{1}.[x{1}] = y{2} /\ 
               INV_CF_G1 G1.handles{2} G1.chandle{2} PF.m{1} PF.mi{1} G1.m{2} G1.mi{2} G1.mh{2} G1.mhi{2} RO.m{2} G1.paths{2}).
        + by move=> ??[][]_[]->[][]-> _ _ ->. 
        seq 0 2: ((!G1.bcol{2} /\ ={x, y} /\
                  INV_CF_G1 G1.handles{2} G1.chandle{2} PF.m{1} PF.mi{1} G1.m{2} G1.mi{2}
                     G1.mh{2} G1.mhi{2} ro0 paths0 /\
                  ! mem (dom PF.m{1}) x{1} /\
                  if mem (dom paths0) x{2}.`2 then
                    let (p0, v0) = oget paths0.[x{2}.`2] in
                    RO.m{2} = ro0.[rcons p0 (v0 +^ x{2}.`1) <- y{2}.`1] /\
                    G1.paths{2} = paths0.[y{2}.`2 <- (rcons p0 (v0 +^ x{2}.`1), y{2}.`1)]
                  else RO.m{2} = ro0 /\ G1.paths{2} = paths0) /\
                 !mem (rng G1.handles{2}) (x{2}.`2, I) /\
                 (G1.handles.[hx2]=Some(x.`2,D)){2}).
        + auto=> &ml&mr[][]->[]_[][]-> ->[]Hinv []-> -> ^Hrng-> /=.   
          case (mem (rng G1.handles{mr}) (x{mr}.`2, D))=> Hmem /=.
          + by split=>//;apply /huniq_hinvD=>//;move:Hinv;rewrite /INV_CF_G1/handles_spec.
          rewrite -anda_and;split=> [ | {Hinv}Hinv].
          + by apply INV_CF_G1_up_handles=>//[[]]. 
          rewrite rng_set (huniq_hinvD_h G1.chandle{mr}) ?getP//. 
          + by move:Hinv;rewrite /INV_CF_G1/handles_spec.
          by rewrite oget_some /=!inE/=;move:Hrng;apply NewLogic.contraLR=>/=;apply rng_rem_le.
        rcondf{2} 1.
        + move=> &ml;skip=> &mr[][]_[][]-> _ []Hinv[]Hndom _[]_ Hh;rewrite -not_def in_dom=> -[].
          move:Hinv=>[][][]_ /(_ (x{mr}.`1, hx2{mr}));case (G1.mh{mr}.[_])=>// bh' /(_ bh') [c c' f f'] /=. 
          by rewrite Hh/= => -[][]<- _ []_ H;case: (x{mr}) H Hndom => [x1 x2];rewrite in_dom=>->.
        auto.
  (* Stopped here *)
        admit.
      admit.
    (* lossless PF.P.f *)
    + admit.
    (* lossless and do not reset bad G1.S.f *)
    + admit.
    (** proofs for G1.S.fi *)
    (* equiv PF.P.fi G1.S.fi *)
    + admit.
    (* lossless PF.P.fi *)
    + admit.
    (* lossless and do not reset bad G1.S.fi *)
    + admit.
    (** proofs for G1.C.f *)
    (* equiv PF.C.f G1.C.f *)
    + admit.
    (* lossless PF.C.f *)
    + admit.
    (* lossless and do not reset bad G1.C.f *)
    + admit.
    (* Init ok *)
    + admit.
  qed.

end section AUX.

section.

  declare module D: DISTINGUISHER{Perm, C, PF, G1}.
  
  axiom D_ll (F <: DFUNCTIONALITY{D}) (P <: DPRIMITIVE{D}):
    islossless P.f => islossless P.fi =>
    islossless F.f => islossless D(F, P).distinguish.

  lemma Real_G1 &m: 
    Pr[GReal(D).main() @ &m: res /\ C.c <= max_size] <=
    Pr[G1(DRestr(D)).main() @ &m: res] + bound_concrete + 
    Pr[G1(DRestr(D)).main() @&m: G1.bcol] + Pr[G1(DRestr(D)).main() @&m: G1.bext].
  proof. 
    apply (RealOrder.ler_trans _ _ _ (Real_Concrete D D_ll &m)).
    cut : Pr[CF(DRestr(D)).main() @ &m : res] <= 
          Pr[G1(DRestr(D)).main() @ &m : res] + 
          Pr[G1(DRestr(D)).main() @ &m : G1.bcol \/ G1.bext].
    + byequiv (CF_G1 (DRestr(D)) _)=>//;1:by apply (DRestr_ll D D_ll).
      smt ml=0.
    cut /# : Pr[G1(DRestr(D)).main() @ &m : G1.bcol \/ G1.bext] <= 
             Pr[G1(DRestr(D)).main() @ &m : G1.bcol] + 
             Pr[G1(DRestr(D)).main() @ &m : G1.bext].
    rewrite Pr [mu_or]; smt.
  qed.

end section.


