require import Core Int Real StdOrder Ring Distr IntExtra.
require import List FSet NewFMap Utils Common SLCommon DProd Dexcepted.

(*...*) import Capacity IntOrder RealOrder.

require (*..*) Strong_RP_RF_C.

module PF = {
  var m, mi: (state,state) fmap

  proc init(): unit = {
    m  <- map0;
    mi <- map0;
  }

  proc f(x : state): state = {
    var y1, y2;

    if (!mem (dom m) x) {
      y1           <$ bdistr;
      y2           <$ cdistr;
      if (!(y1,y2) \in dom mi) {
        mi.[(y1,y2)] <- x;
      }
      m.[x]        <- (y1,y2);
    }
    return oget m.[x];
  }

  proc fi(x : state): state = {
    var y1, y2;

    if (!mem (dom mi) x) {
      y1          <$ bdistr;
      y2          <$ cdistr;
      if (!(y1,y2) \in dom m) {
        m.[(y1,y2)] <- x;
      }
      mi.[x]      <- (y1,y2);
    }
    return oget mi.[x];
  }

}.

module CF(D:DISTINGUISHER) = Indif(SqueezelessSponge(PF), PF, D).
     
section.
  declare module D : DISTINGUISHER {Perm, C, PF}.

  axiom D_ll (F <: DFUNCTIONALITY{D}) (P <: DPRIMITIVE{D}):
    islossless P.f => islossless P.fi => islossless F.f => 
    islossless D(F, P).distinguish.

  local module GReal' = Indif(FC(SqueezelessSponge(Perm)), PC(Perm), D).

  local clone import Strong_RP_RF_C as Switching with
    type D  <- state,
      op uD <- dstate,
    type K  <- unit,
      op dK <- (MUnit.dunit<:unit> tt),
      op q  <- max_size
  proof *. 
  realize ge0_q by rewrite max_ge0.
  realize uD_uf_fu.
  split.
    case=> [x y]; rewrite supp_dprod /=.
    rewrite Block.DBlock.supp_dunifin Capacity.DCapacity.supp_dunifin/=. 
      smt(dprod1E Block.DBlock.dunifin_funi Capacity.DCapacity.dunifin_funi).
  split. 
    smt(dprod_ll  Block.DBlock.dunifin_ll Capacity.DCapacity.dunifin_ll).
  apply/dprod_fu.
    rewrite Block.DBlock.dunifin_fu.
  by rewrite Capacity.DCapacity.dunifin_fu.
  qed.
  realize dK_ll.
  by rewrite /is_lossless MUnit.dunit_ll.
  qed.

  (* TODO move this *)
  lemma size_behead (l : 'a list) : l <> [] => size (behead l) = size l - 1.
  proof. by case l=> // ?? /=; ring. qed.

  local module CP' (P' : PRPt.Oracles) = {
    proc f (x : state) = {
      var y <- (b0,c0);
      if (!x \in dom C.m) {
        y <@ P'.f(x);
        if (!y \in dom C.mi) {
          C.mi.[y] <- x;
        }
        C.m.[x]  <- y;
      } else {
        y <- oget C.m.[x];
      }
      return y;
    }
    proc fi (x : state) = {
      var y <- (b0,c0);
      if (!x \in dom C.mi) {
        y <@ P'.f(x);
        if (!y \in dom C.m) {
          C.m.[y]  <- x;
        }
        C.mi.[x] <- y;
      } else {
        y <- oget C.mi.[x];
      }
      return y;
    }
  }.

  local module (D': PRPt.Distinguisher) (P' : PRPt.Oracles) = {
    proc distinguish = DRestr(D,SqueezelessSponge(CP'(P')),P').distinguish
  }.

print DRestr.

  local lemma DoubleBounding (P <: PRPt.StrongPRP {D, C, DBounder}) &m:
    Pr[PRPt.IND(P,D').main() @ &m: res]
    = Pr[PRPt.IND(P,DBounder(D')).main() @ &m: res].
  proof.
  byequiv=> //=; proc; inline *.
  wp.
  call (_: ={glob C, glob P}
        /\ prefixe_inv C.queries{1} C.m{1}
        /\ ={m,mi}(C,DBounder.FBounder)
        /\ DBounder.FBounder.c{2} <= C.c{2}).
  + proc; sp; if;auto;if=> //=; inline *.
    rcondt{2} 3; 1: by auto=> /#.
    rcondt{2} 4;first by auto;call(:true);auto.
    by wp; call (_: true); auto;smt(prefixe_inv_set).
  + proc; sp; if; auto; if=> //=; inline *.
    rcondt{2} 3; 1: by auto=> /#.
    rcondt{2} 4;first by auto;call(:true);auto.
    wp; call (_: true); auto;progress. 
    + smt(prefixe_inv_set). 
    + rewrite/#.
    + rewrite/#.
  + proc; sp; if; auto; if=> //=; inline *.
    splitwhile{1} 4 : (sa +^ head witness p, sc) \in dom C.m.
    splitwhile{2} 4 : (sa +^ head witness p, sc) \in dom C.m.
    wp=>//=;swap 1 4;wp=>//=.
    conseq(:_==> ={sa, C.mi, C.m, glob P} /\ C.m{1} = DBounder.FBounder.m{2}
        /\ C.mi{1} = DBounder.FBounder.mi{2}
        /\ prefixe_inv C.queries{1} C.m{1}
        /\ DBounder.FBounder.c{2} <= C.c{2} + size bs{2} -
             prefixe bs{2} (get_max_prefixe bs{2} (elems (dom C.queries{2})))
        /\ (forall (i : int), 
             0 <= i < size bs{2} =>
             let bc = (blocksponge (take i bs{2}) C.m{1} s0).`2 in
             (bc.`1 +^ nth b0 bs{2} i, bc.`2) \in dom C.m{1}));
      1:smt(dom_set in_fsetU1).

    while(={sa, sc, C.mi, C.m, glob P, p, bs, C.c, C.queries}
        /\ C.m{1} = DBounder.FBounder.m{2}
        /\ C.mi{1} = DBounder.FBounder.mi{2}
        /\ (exists i, p{2} = drop i bs{2} /\ 0 <= i <= size bs{2}
             /\ blocksponge (take i bs{2}) C.m{1} s0 = ([], (sa{1},sc{1})))
        /\ prefixe_inv C.queries{1} C.m{1}
        /\ C.c{1} + size bs{1} - prefixe bs{1}
             (get_max_prefixe bs{1} (elems (dom C.queries{1}))) <= max_size
        /\ DBounder.FBounder.c{2} <= C.c{2} + size bs{2} - size p{2} -
             prefixe bs{2} (get_max_prefixe bs{2} (elems (dom C.queries{2})))
        /\ (forall (i : int), 
             0 <= i < size bs{2} - size p{2} =>
             let bc = (blocksponge (take i bs{2}) C.m{1} s0).`2 in
             (bc.`1 +^ nth b0 bs{2} i, bc.`2) \in dom C.m{1})
        /\ (forall (i : int), 
             0 <= i < size bs{2} - size p{2} =>
             (blocksponge (take i bs{2}) C.m{1} s0).`1 = [])).
    + sp;if;1,3:auto;last first;progress.
      - exists (i+1);rewrite(drop_nth witness)//=;2:split;1,2:smt(drop_oversize).
        rewrite (take_nth witness);1:smt(drop_oversize).
        move:H9;rewrite (drop_nth witness)/=;1:smt(drop_oversize).
        move=>?.
        rewrite blocksponge_rcons H1/=H9/=/#.
      - rewrite size_behead//=/#.
      - move:H11;rewrite size_behead//=.
        case(i0 < size bs{2} - size (drop i bs{2}))=>[/#|]h h1.
        cut->:i0 = size bs{2} - size (drop i bs{2}) by rewrite/#.
        rewrite size_drop//=max_ler 1:/#/=.
        cut->:(size bs{2} - (size bs{2} - i)) = i by ring.
        rewrite H1/=.
        by move:H9;rewrite (drop_nth b0)/=;1:smt(drop_oversize).
      - move:H11;rewrite size_behead//=.
        case(i0 < size bs{2} - size (drop i bs{2}))=>[/#|]h h1.
        cut->:i0 = size bs{2} - size (drop i bs{2}) by rewrite/#.
        rewrite size_drop//=max_ler 1:/#/=.
        cut->:(size bs{2} - (size bs{2} - i)) = i by ring.
        by rewrite H1/=.
        
      rcondt{2}3;1:(auto;smt(size_ge0 size_eq0)).
      rcondt{2}4;1:by auto;call(:true);auto. 
      wp;call(:true);auto;progress.
      - exists (i+1);rewrite(drop_nth witness)//=;2:split;1,2:smt(drop_oversize).
        rewrite (take_nth witness);1:smt(drop_oversize).
        move:H9;rewrite (drop_nth witness)/=;1:smt(drop_oversize).
        move=>h.
        rewrite blocksponge_rcons/=.
        cut/=:=blocksponge_set_nil (take i bs{2}) DBounder.FBounder.m{2} s0 
         (sa{2} +^ nth witness bs{2} i, sc{2}) result_R h.
        rewrite H1/=/==>->/=;rewrite dom_set in_fsetU1/=getP/=oget_some/#.
      - smt(prefixe_inv_set).
      - smt(size_ge0 size_eq0).
      - move:H12;rewrite size_behead//==>?. 
        move:H9;rewrite (drop_nth witness)/=;1:smt(drop_oversize).
        move=>h.
        case(i0 < size bs{2} - size (drop i bs{2}))=>[|]?.
        + cut//=->/=:=blocksponge_set_nil (take i0 bs{2}) DBounder.FBounder.m{2} s0 
              (sa{2} +^ nth witness bs{2} i, sc{2}) result_R h (H6 i0 _);1:rewrite/#.
          by rewrite dom_set in_fsetU1/#.
        cut hii0:i0=i by move:H9 H12;rewrite!size_drop//=max_ler /#.
        rewrite hii0.
        cut//=:=blocksponge_set_nil (take i bs{2}) DBounder.FBounder.m{2} s0 
              (sa{2} +^ nth witness bs{2} i, sc{2}) result_R h.
        rewrite H1/==>->/=;rewrite dom_set in_fsetU1//=;right;congr.
        by rewrite nth_onth (onth_nth witness)//=;smt(size_ge0 size_eq0).
      + move:H9;rewrite (drop_nth witness)/=;1:smt(drop_oversize).
        move=>h.
        case(i0 < size bs{2} - size (drop i bs{2}))=>[|]?.
        + smt(blocksponge_set_nil).
        cut hii0:i0=i by move:H12;rewrite size_behead//==>?;
          move:H9 H12;rewrite!size_drop//=max_ler /#.
        rewrite hii0;smt(blocksponge_set_nil).
      + exists (i+1);rewrite(drop_nth witness)//=;2:split;1,2:smt(drop_oversize).
        rewrite (take_nth witness);1:smt(drop_oversize).
        move:H9;rewrite (drop_nth witness)/=;1:smt(drop_oversize).
        move=>h.
        rewrite blocksponge_rcons/=.
        cut/=:=blocksponge_set_nil (take i bs{2}) DBounder.FBounder.m{2} s0 
         (sa{2} +^ nth witness bs{2} i, sc{2}) result_R h.
        rewrite H1/=/==>->/=;rewrite dom_set in_fsetU1/=getP/=oget_some/#.
      - smt(prefixe_inv_set).
      - smt(size_ge0 size_eq0).
      - move:H12;rewrite size_behead//==>?. 
        move:H9;rewrite (drop_nth witness)/=;1:smt(drop_oversize).
        move=>h.
        case(i0 < size bs{2} - size (drop i bs{2}))=>[|]?.
        + cut//=->/=:=blocksponge_set_nil (take i0 bs{2}) DBounder.FBounder.m{2} s0 
              (sa{2} +^ nth witness bs{2} i, sc{2}) result_R h (H6 i0 _);1:rewrite/#.
          by rewrite dom_set in_fsetU1/#.
        cut hii0:i0=i by move:H9 H12;rewrite!size_drop//=max_ler /#.
        rewrite hii0.
        cut//=:=blocksponge_set_nil (take i bs{2}) DBounder.FBounder.m{2} s0 
              (sa{2} +^ nth witness bs{2} i, sc{2}) result_R h.
        rewrite H1/==>->/=;rewrite dom_set in_fsetU1//=;right;congr.
        by rewrite nth_onth (onth_nth witness)//=;smt(size_ge0 size_eq0).
      + move:H9;rewrite (drop_nth witness)/=;1:smt(drop_oversize).
        move=>h.
        case(i0 < size bs{2} - size (drop i bs{2}))=>[|]?.
        + smt(blocksponge_set_nil).
        cut hii0:i0=i by move:H12;rewrite size_behead//==>?;
          move:H9 H12;rewrite!size_drop//=max_ler /#.
        rewrite hii0;smt(blocksponge_set_nil).

    conseq(:_==> ={sa, sc, C.mi, C.m, glob P, p, bs, C.c, C.queries}
        /\ C.m{1} = DBounder.FBounder.m{2}
        /\ C.mi{1} = DBounder.FBounder.mi{2}
        /\ (exists i, p{2} = drop i bs{2} /\ 0 <= i <= size bs{2}
             /\ blocksponge (take i bs{2}) C.m{1} s0 = ([], (sa{1},sc{1})))
        /\ prefixe_inv C.queries{1} C.m{1}
        /\ C.c{1} + size bs{1} - prefixe bs{1}
             (get_max_prefixe bs{1} (elems (dom C.queries{1}))) <= max_size
        /\ DBounder.FBounder.c{2} <= C.c{2} + size bs{2} - size p{2} -
             prefixe bs{2} (get_max_prefixe bs{2} (elems (dom C.queries{2})))
        /\ (forall (i : int), 
             0 <= i < size bs{2} - size p{2} =>
             let bc = (blocksponge (take i bs{2}) C.m{1} s0).`2 in
             (bc.`1 +^ nth b0 bs{2} i, bc.`2) \in dom C.m{1})
        /\ (forall (i : int), 
             0 <= i < size bs{2} - size p{2} =>
             (blocksponge (take i bs{2}) C.m{1} s0).`1 = []));1:rewrite/#. 

    alias{2} 1 k = DBounder.FBounder.c;sp 0 1.
    alias{2} 1 dm = DBounder.FBounder.m;sp 0 1.
    alias{2} 1 dmi = DBounder.FBounder.mi;sp 0 1.
    alias{2} 1 cm = C.m;sp 0 1.
    alias{2} 1 cmi = C.mi;sp 0 1.
    conseq(:_==> ={sa, sc, C.mi, C.m, glob P, p, bs, C.c}
        /\ C.m{1} = cm{2}
        /\ DBounder.FBounder.m{2} = dm{2}
        /\ C.mi{1} = cmi{2}
        /\ DBounder.FBounder.mi{2} = dmi{2}
        /\ (exists i, p{2} = drop i bs{2} /\ 0 <= i <= size bs{2}
             /\ blocksponge (take i bs{2}) C.m{1} s0 = ([], (sa{1},sc{1})))
        /\ prefixe bs{1} (get_max_prefixe bs{1} (elems (dom C.queries{1}))) <= size bs{1} - size p{1}
        /\ DBounder.FBounder.c{2} = k{2}
        /\ (forall (i : int), 
             0 <= i < size bs{2} - size p{2} =>
             let bc = (blocksponge (take i bs{2}) C.m{1} s0).`2 in
             (bc.`1 +^ nth b0 bs{2} i, bc.`2) \in dom C.m{1})
        /\ (forall (i : int), 
             0 <= i < size bs{2} - size p{2} =>
             (blocksponge (take i bs{2}) C.m{1} s0).`1 = []));progress. 
    + rewrite/#.
    + smt(size_ge0 size_drop).

    while(={sa, sc, C.mi, C.m, glob P, p, bs, C.c}
        /\ prefixe_inv C.queries{1} C.m{1}
        /\ C.m{1} = cm{2}
        /\ DBounder.FBounder.m{2} = dm{2}
        /\ C.mi{1} = cmi{2}
        /\ DBounder.FBounder.mi{2} = dmi{2}
        /\ (exists i, p{2} = drop i bs{2} /\ 0 <= i <= size bs{2}
             /\ blocksponge (take i bs{2}) C.m{1} s0 = ([], (sa{1},sc{1})))
        /\ DBounder.FBounder.c{2} = k{2}
        /\ (forall (i : int), 
             0 <= i < size bs{2} - size p{2} =>
             let bc = (blocksponge (take i bs{2}) C.m{1} s0).`2 in
             (bc.`1 +^ nth b0 bs{2} i, bc.`2) \in dom C.m{1})
        /\ (forall (i : int), 
             0 <= i < size bs{2} - size p{2} =>
             (blocksponge (take i bs{2}) C.m{1} s0).`1 = []));last first.
    + auto;progress.
         smt(drop0 size_ge0).
         smt(drop0 size_ge0).
         smt(drop0 size_ge0).
         smt(drop0 size_ge0).
         move:H4;rewrite negb_and/==>[]. 
         case(drop i bs{2} = [])=>[hdropi|hdropi]//=.
         + rewrite hdropi/=;smt(prefixe_sizel).
         rewrite size_drop//=max_ler 1:/#.
         cut->:size bs{2} - (size bs{2} - i) = i by rewrite/#.
         rewrite(drop_nth b0)//=;1:smt(size_ge0 size_eq0 size_drop). print prefixe_inv.
         apply absurd=>//=hi.
         cut->:nth b0 bs{2} i = nth b0 (get_max_prefixe bs{2} (elems (dom C.queries{2}))) i.
         + rewrite 2!nth_onth (onth_nth witness);1:smt(size_drop size_eq0).
           cut/=h:=prefixe_nth bs{2} (get_max_prefixe bs{2} (elems (dom C.queries{2}))).
           cut->:=h i _;1:smt(size_drop size_eq0).
           by rewrite (onth_nth witness)/=;1:smt(size_drop size_eq0 prefixe_sizer).
         cut:=H (get_max_prefixe bs{2} (elems (dom C.queries{2}))) _;last first. 
         + move=>h;cut:=h i _;1:smt(prefixe_sizer).
           cut:=H8;cut->/#:(take i bs{2}) = (take i (get_max_prefixe bs{2} (elems (dom C.queries{2})))).
           by apply (eq_from_nth b0 _ _ _ _);
             smt(size_take prefixe_sizer prefixe_sizel nth_take prefixe_nth nth_onth onth_nth).
         cut h:forall (l1 l2:block list) ll, max_prefixe l1 l2 ll = l2 \/ max_prefixe l1 l2 ll \in ll.
         + clear P &m &1 &2 H H0 H H1 H2 P_R sa_R sc_R H5 i H3 H6 H7 H8 H9 H10 hdropi hi.
           by move=>l1 l2 ll;move:ll l1 l2;move=>ll;elim:ll=>//=/#.
         cut h1:forall (l : block list) ll, get_max_prefixe l ll <> [] => ll <> [].
         + clear P &m &1 &2 H H0 H H1 H2 P_R sa_R sc_R H5 i H3 H6 H7 H8 H9 H10 hdropi hi.
           by move=>l ll;move:ll l=>ll;elim:ll=>//=.
         rewrite memE;smt(prefixe_sizer).
    sp;rcondf{1}1;2:rcondf{2}1;auto;progress.
    - exists (i+1);rewrite(drop_nth witness)//=;2:split;1,2:smt(drop_oversize).
      rewrite (take_nth witness);1:smt(drop_oversize).
      move:H8;rewrite (drop_nth witness)/=;1:smt(drop_oversize).
      move=>h.
      rewrite blocksponge_rcons/=H2/=h/=/#.
    - move:H10;rewrite size_behead//=.
      case(i0 < size bs{2} - size (drop i bs{2}))=>??;1:rewrite/#.
      cut hii0:i0=i by smt(size_drop).
      rewrite hii0 H2/=.
      move:H8;rewrite (drop_nth witness)/=;1:smt(drop_oversize).
      by rewrite nth_onth (onth_nth b0)/=;1:smt(size_eq0).
    - move:H10;rewrite size_behead//=.
      case(i0 < size bs{2} - size (drop i bs{2}))=>??;1:rewrite/#.
      cut hii0:i0=i by smt(size_drop).
      by rewrite hii0 H2/=.
  auto;progress;call(:true);auto;smt(dom0 in_fset0).
  qed.

  local clone import ProdSampling with
    type t1 <- block,
      op d1 <- bdistr,
    type t2 <- capacity,
      op d2 <- cdistr.

  lemma Real_Concrete &m : 
    Pr[GReal(D).main()@ &m: res /\ C.c <= max_size] <=
    Pr[CF(DRestr(D)).main()@ &m: res] + (max_size ^ 2)%r * inv 2%r * mu dstate (pred1 witness).
  proof.
    cut->:
      Pr[RealIndif(SqueezelessSponge,PC(Perm),D).main()@ &m:
         res /\ C.c <= max_size] = Pr[GReal'.main()@ &m: res/\ C.c <= max_size].
    + byequiv=>//;proc;inline *;call (_: ={glob C,glob Perm}
        /\ prefixe_inv C.queries{1} Perm.m{1} /\ inv Perm.m{1} Perm.mi{1});
        last by auto;smt(dom0 in_fset0 map0P).
      + proc;inline*;sp;if;auto;sp;if;auto;progress. 
        - smt(getP oget_some prefixe_inv_set). 
        - smt(in_dom inv_dom_rng invC getP oget_some supp_dexcepted).
        - smt(getP oget_some prefixe_inv_set).
        - smt(in_dom inv_dom_rng invC getP oget_some supp_dexcepted).
      + proc;inline*;sp;if;auto;sp;if;auto;progress. 
        - smt(getP oget_some prefixe_inv_set invC inv_dom_rng supp_dexcepted). 
        - smt(in_dom inv_dom_rng invC getP oget_some supp_dexcepted).
        - smt(getP oget_some prefixe_inv_set invC inv_dom_rng supp_dexcepted). 
        - smt(in_dom inv_dom_rng invC getP oget_some supp_dexcepted).
      proc; inline *; wp.
      sp;if{2}.
      (* TODO : reprendre ici *)
      + 
      while (={glob Perm,sc,sa,p} /\ (C.c + size p){1} = C.c{2});2:by auto.
      by sp; if=> //=; auto=> /> &2 cL /size_behead=> ->; progress; ring.
    have p_ll := P_f_ll _ _.
    + apply/dprod_ll; split.
      + exact/Block.DBlock.dunifin_ll.
      exact/Capacity.DCapacity.dunifin_ll.
    + apply/fun_ext=>- [] a b; rewrite supp_dprod.
      by rewrite/=/predT/=Block.DBlock.dunifin_fu Capacity.DCapacity.dunifin_fu. 
    have pi_ll := P_fi_ll _ _.
    + apply/dprod_ll; split.
      + exact/Block.DBlock.dunifin_ll.
      exact/Capacity.DCapacity.dunifin_ll.
    + apply/fun_ext=>- [] a b; rewrite supp_dprod.
      by rewrite/=/predT/=Block.DBlock.dunifin_fu Capacity.DCapacity.dunifin_fu. 
    have f_ll : islossless SqueezelessSponge(Perm).f.
    + proc; while true (size p)=> //=.
      * by move=> z; wp; call p_ll; skip=> /> &hr /size_behead /#.
      by auto; smt w=size_ge0.
    apply (ler_trans _ _ _ 
             (Pr_restr Perm SqueezelessSponge D p_ll pi_ll f_ll D_ll &m)).
    have ->: Pr[Indif(SqueezelessSponge(Perm), Perm, DRestr(D)).main() @ &m: res]
             = Pr[PRPt.IND(PRPi.PRPi,DBounder(D')).main() @ &m: res].
    + rewrite -(DoubleBounding PRPi.PRPi &m).
      byequiv=> //=; proc; inline *; sim (_: ={m,mi}(Perm,PRPi.PRPi) /\ ={glob C}).
      * by proc; if=> //=; auto.
      by proc; if=> //=; auto.
    have ->: Pr[CF(DRestr(D)).main() @ &m: res]
             = Pr[PRPt.IND(ARP,DBounder(D')).main() @ &m: res].
    + rewrite -(DoubleBounding ARP &m).
      byequiv=> //=; proc; inline *; sim (_: ={m,mi}(PF,ARP)).
      * proc; if=> //=; auto; conseq (_: true ==> (y1,y2){1} = x{2})=> //=.
        transitivity{1} { (y1,y2) <@ S.sample2(); }
                        (true ==> ={y1,y2})
                        (true ==> (y1,y2){1} = x{2})=> //=.
        - by inline *; auto.
        transitivity{2} { x <@ S.sample(); }
                        (true ==> (y1,y2){1} = x{2})
                        (true ==> ={x})=> //=.
        - by symmetry; call sample_sample2; skip=> /> [].
        by inline *; auto.
      proc; if=> //=; auto; conseq (_: true ==> (y1,y2){1} = y{2})=> //=.
      transitivity{1} { (y1,y2) <@ S.sample2(); }
                      (true ==> ={y1,y2})
                      (true ==> (y1,y2){1} = y{2})=> //=.
      - by inline *; auto.
      transitivity{2} { y <@ S.sample(); }
                      (true ==> (y1,y2){1} = y{2})
                      (true ==> ={y})=> //=.
      - by symmetry; call sample_sample2; skip=> /> [].
      by inline *; auto.
    have /#:= Conclusion D' &m _.
    move=> O O_f_ll O_fi_ll.
    proc; call (_: true)=> //=.
    + apply D_ll.
    + by proc; sp; if=> //=; call O_f_ll; auto.
    + by proc; sp; if=> //=; call O_fi_ll; auto.
    + proc; inline *; sp; if=> //=; auto.
      while true (size p).
      * by auto; call O_f_ll; auto=> /#.
      by auto; smt w=size_ge0.
    by inline *; auto.
  qed.

end section.
