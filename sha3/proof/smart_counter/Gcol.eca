pragma -oldip.
require import Core Int Real RealExtra StdOrder Ring StdBigop IntExtra.
require import List FSet NewFMap Utils Common SLCommon RndO FelTactic Mu_mem.
require import DProd Dexcepted.
(*...*) import Capacity IntOrder Bigreal RealOrder BRA.

require (*..*) Gcol_ext.

clone export Gcol_ext as Handle0.

(* -------------------------------------------------------------------------- *)

 (* TODO: move this *)
  lemma c_gt0r : 0%r < (2^c)%r.
  proof. by rewrite lt_fromint;apply /powPos. qed.

  lemma c_ge0r : 0%r <= (2^c)%r.
  proof. by apply /ltrW/c_gt0r. qed. 

  lemma eps_ge0 : 0%r <= (2 * max_size)%r / (2 ^ c)%r. 
  proof.
    apply divr_ge0;1:by rewrite le_fromint;smt ml=0 w=max_ge0. 
    by apply c_ge0r. 
  qed.

section PROOF.
  declare module D: DISTINGUISHER{C, PF, G1}.

  axiom D_ll (F <: DFUNCTIONALITY{D}) (P <: DPRIMITIVE{D}):
    islossless P.f => islossless P.fi =>
    islossless F.f => islossless D(F, P).distinguish.

  local module Gcol = {
    
    var count : int

    proc sample_c () = {
      var c=c0;
      if (card (image fst (rng FRO.m)) <= 2*max_size /\
          count < max_size) {
        c <$ cdistr;
        G1.bcol <-  G1.bcol \/ mem (image fst (rng FRO.m)) c;
        count <- count + 1;  
      }

      return c;
    }
  
    module C = {
  
      proc f(p : block list): block = {
        var sa, sa', sc;
        var h, i <- 0; 
        sa <- b0;
        while (i < size p ) {
          if (mem (dom G1.mh) (sa +^ nth witness p i, h)) {
            (sa, h) <- oget G1.mh.[(sa +^ nth witness p i, h)];
          } else {
            if (! G1.bcol /\ ! G1.bext) {
              sc                        <@ sample_c();
              sa'                       <- F.RO.get(take (i+1) p);
              sa                        <- sa +^ nth witness p i;
              G1.mh.[(sa,h)]            <- (sa', G1.chandle);
              G1.mhi.[(sa',G1.chandle)] <- (sa, h);
              (sa,h)                    <- (sa',G1.chandle);
              FRO.m.[G1.chandle]        <- (sc,Unknown);
              G1.chandle                <- G1.chandle + 1;
            }
          }
          i        <- i + 1;
        }
        sa <- F.RO.get(p);
        return sa;
      }
    }
  
    module S = {
  
      proc f(x : state): state = {
        var p, v, y, y1, y2, hy2, hx2;
  
        if (!mem (dom G1.m) x) {
          y <- (b0,c0);
          if (! G1.bcol /\ ! G1.bext) {
            if (!(mem (rng FRO.m) (x.`2, Known))) {
              FRO.m.[G1.chandle] <- (x.`2, Known);
              G1.chandle         <- G1.chandle + 1;
            }
            hx2 <- oget (hinvK FRO.m x.`2);
            if (mem (dom G1.paths) x.`2) {
              (p,v) <- oget G1.paths.[x.`2]; 
              y1    <- F.RO.get (rcons p (v +^ x.`1));
              y2    <@ sample_c();
            } else {
              y1 <$ bdistr;
              y2 <@ sample_c();

            }
            y  <- (y1,y2);
            if (mem (dom G1.mh) (x.`1, hx2) /\ 
                in_dom_with FRO.m (oget G1.mh.[(x.`1,hx2)]).`2 Unknown) {
              hy2                  <- (oget G1.mh.[(x.`1, hx2)]).`2;
              y                    <- (y.`1, (oget FRO.m.[hy2]).`1);
              FRO.m.[hy2]          <- (y.`2, Known);
              G1.m.[x]             <- y;
              G1.mi.[y]            <- x;
            } else {
              hy2                  <- G1.chandle;
              G1.chandle           <- G1.chandle + 1;
              FRO.m.[hy2]          <- (y.`2, Known);
              G1.m.[x]             <- y;
              G1.mh.[(x.`1, hx2)]  <- (y.`1, hy2);
              G1.mi.[y]            <- x;
              G1.mhi.[(y.`1, hy2)] <- (x.`1, hx2);
            }
            if (mem (dom G1.paths) x.`2) {
              (p,v) <- oget G1.paths.[x.`2]; 
              G1.paths.[y.`2] <- (rcons p (v +^ x.`1), y.`1);
            }
          }
        } else {   
          y <- oget G1.m.[x];
        }
        return y;
      }
  
      proc fi(x : state): state = {
        var y, y1, y2, hx2, hy2;
  
        if (!mem (dom G1.mi) x) {
          y <- (b0,c0);
          if (! G1.bcol /\ !G1.bext) {
            if (!(mem (rng FRO.m) (x.`2, Known))) {
              FRO.m.[G1.chandle] <- (x.`2, Known);
              G1.chandle <- G1.chandle + 1;
            }
            hx2 <- oget (hinvK FRO.m x.`2);
            y1  <$ bdistr;
            y2  <@ sample_c();
            y   <- (y1,y2);
            if (mem (dom G1.mhi) (x.`1, hx2) /\ 
                in_dom_with FRO.m (oget G1.mhi.[(x.`1,hx2)]).`2 Unknown) {
              (y1,hy2)             <- oget G1.mhi.[(x.`1, hx2)];
              y                    <- (y.`1, (oget FRO.m.[hy2]).`1);
              FRO.m.[hy2]          <- (y.`2, Known);
              G1.mi.[x]            <- y;
              G1.m.[y]             <- x;
            } else {
              hy2                  <- G1.chandle;
              G1.chandle           <- G1.chandle + 1;
              FRO.m.[hy2]          <- (y.`2, Known);
              G1.mi.[x]            <- y;
              G1.mhi.[(x.`1, hx2)] <- (y.`1, hy2);
              G1.m.[y]             <- x;
              G1.mh.[(y.`1, hy2)]  <- (x.`1, hx2);
            }
          }
        } else {
          y <- oget G1.mi.[x];
        }
        return y;
      }
    
    }
  
    proc main(): bool = {
      var b;

      F.RO.m      <- map0;
      G1.m        <- map0;
      G1.mi       <- map0;
      G1.mh       <- map0;
      G1.mhi      <- map0;
      G1.bcol     <- false;
  
      FRO.m       <- map0.[0 <- (c0, Known)];
      G1.paths    <- map0.[c0 <- ([<:block>],b0)];
      G1.chandle  <- 1;
      count       <- 0;
      b           <@ DRestr(D,C,S).distinguish();
      return b;
    }    
  }.

  lemma card_rng_set (m:('a,'b)fmap) x y: card(rng m.[x<-y]) <= card(rng m) + 1.
  proof. 
    rewrite rng_set fcardU fcard1. 
    cut := subset_leq_fcard (rng (rem x m)) (rng m) _;2:smt ml=0 w=fcard_ge0.
    rewrite subsetP=> z;apply rng_rem_le.
  qed.

  lemma hinv_image handles c: 
    hinv handles c <> None =>
    mem (image fst (rng handles)) c.
  proof.
    case: (hinv handles c) (hinvP handles c)=>//= h[f] Heq.
    rewrite imageP;exists (c,f)=>@/fst/=. 
    by rewrite in_rng;exists (oget (Some h)).
  qed.

  local lemma Pr_col &m : 
    Pr[Gcol.main()@&m : G1.bcol /\ Gcol.count <= max_size] <=
    max_size%r * ((2*max_size)%r / (2^c)%r).
  proof.
    fel 10 Gcol.count (fun x=> (2*max_size)%r / (2^c)%r)
      max_size G1.bcol 
      [Gcol.sample_c : (card (image fst (rng FRO.m)) <= 2*max_size /\ Gcol.count < max_size)]=>//;2:by auto.
    + rewrite /felsum Bigreal.sumr_const count_predT size_range.
      apply ler_wpmul2r;1:by apply eps_ge0.
      by rewrite le_fromint;smt ml=0 w=max_ge0. 
    + proc;sp;if;2:by hoare=>//??;apply eps_ge0.
      wp.
      rnd (mem (image fst (rng FRO.m)));skip;progress;2:smt ml=0. 
      cut->:=(Mu_mem.mu_mem (image fst (rng FRO.m{hr})) cdistr (1%r/(2^c)%r) _).
      + move=>x _; rewrite DCapacity.dunifin1E;do !congr;smt(@Capacity). 
      apply ler_wpmul2r;2:by rewrite le_fromint.
      by apply divr_ge0=>//;apply /c_ge0r. 
    + move=>ci;proc;rcondt 2;auto=>/#.
    move=> b c;proc;sp;if;auto;smt ml=0.
  qed.

  local equiv Gpr_col : Gpr(DRestr(D)).main ~ Gcol.main : 
    ={glob D} ==> (G1.bcol{1} => G1.bcol{2}) /\ Gcol.count{2} <= max_size.
  proof.
    proc;inline*;wp.
    call (_: ={F.RO.m,G1.mi,G1.paths,G1.m,G1.mhi,G1.chandle,G1.mh,FRO.m,C.c,C.queries}/\
             (G1.bcol{1} => G1.bcol{2}) /\
             ((!G1.bext /\ !G1.bcol) => mh_spec FRO.m G1.m G1.mh F.RO.m
               /\ pi_spec FRO.m G1.mh G1.paths
               /\ hs_spec FRO.m G1.chandle){1} /\ 
             (card (rng FRO.m) <= 2*C.c + 1 /\ 
              Gcol.count <= C.c <= max_size){2}).
    + proc;sp 1 1;if=>//;inline Gpr(DRestr(D)).S.f Gcol.S.f;swap -3.
      sp;if;1,3:auto=>/#;sp;wp;if;auto;progress.
      - rewrite/
      swap{1}[3..5]-2. 
      seq 3 2:(={F.RO.m,G1.mi,G1.paths,G1.m,G1.mhi,G1.chandle,G1.mh,FRO.m,
                 C.c,C.queries,x0,hx2} /\ 
               (G1.bcol{1} => G1.bcol{2}) /\
               (card (rng FRO.m) + 1 <= 2 * C.c + 1 /\ 
                Gcol.count + 1 <= C.c <= max_size){2}).
      + auto;smt ml=0 w=card_rng_set. 
      seq 2 2: 
        (={F.RO.m,G1.mi,G1.paths,G1.m,G1.mhi,G1.chandle,G1.mh,FRO.m,
           C.c,C.queries,x0,hx2,y0} /\ 
         ((G1.bcol\/hinv FRO.m y0.`2 <> None){1} => G1.bcol{2}) /\
         (card (rng FRO.m) + 1 <= 2 * C.c + 1 /\ 
         Gcol.count  <= C.c <= max_size){2});last by auto;smt ml=0 w=card_rng_set.
      wp;if=>//;inline Gcol.sample_c.
      + rcondt{2}4.
        + auto;conseq (_:true)=>//;progress;2: smt ml=0. 
          by cut /#:= fcard_image_leq fst (rng FRO.m{hr}).
        wp;conseq (_: ={p,v,F.RO.m,y1} /\ y2{1}=c{2})=>//;1:smt ml=0 w=hinv_image.
        by sim.
      rcondt{2}3.
      + by auto;progress;cut /#:= fcard_image_leq fst (rng FRO.m{hr}).
      auto;progress;smt w=hinv_image.

    + proc;sp 1 1;if=>//.
      inline Gpr(DRestr(D)).S.fi Gcol.S.fi;swap-3. 
      seq 2 2 : (={F.RO.m,G1.mi,G1.paths,G1.m,G1.mhi,G1.chandle,G1.mh,FRO.m,
                   C.c,C.queries,x0} /\ 
                 (G1.bcol{1} => G1.bcol{2}) /\
                 (card(rng FRO.m) + 2 <= 2*C.c + 1 /\ 
                  Gcol.count + 1 <= C.c <= max_size){2});1:by auto=>/#.
      if=>//;last by auto=>/#.
      seq 3 2:(={F.RO.m,G1.mi,G1.paths,G1.m,G1.mhi,G1.chandle,G1.mh,FRO.m,
                 C.c,C.queries,x0,hx2} /\ 
               (G1.bcol{1} => G1.bcol{2}) /\
               (card (rng FRO.m) + 1 <= 2 * C.c + 1 /\ 
                Gcol.count + 1 <= C.c <= max_size){2}).
      + by auto;smt ml=0 w=card_rng_set. 
      seq 3 3: 
        (={F.RO.m,G1.mi,G1.paths,G1.m,G1.mhi,G1.chandle,G1.mh,FRO.m,
           C.c,C.queries,x0,hx2,y0,y1,y2} /\ y0{1} = (y1,y2){1} /\
         ((G1.bcol\/hinv FRO.m y0.`2 <> None){1} => G1.bcol{2}) /\
         (card (rng FRO.m) + 1 <= 2 * C.c + 1 /\ 
         Gcol.count <= C.c <= max_size){2});2:by auto;smt w=card_rng_set.
      inline Gcol.sample_c.
      rcondt{2}3.
      + by auto;progress;cut /#:= fcard_image_leq fst (rng FRO.m{hr}).
(* BUG: auto=> /> ?? Himp _ _ _ ?_?_ [/Himp->// | H].  marche pas ???? *)
      auto=> /> ?? Himp _ _ _ ?_?_ [/Himp->// | X];right;apply hinv_image=> //.  

    + proc;sp 1 1;if=>//;2:auto;sp;if=>//.
      inline Gpr(DRestr(D)).C.f Gcol.C.f.  sp.
      seq 5 5:
       (={F.RO.m,G1.mi,G1.paths,G1.m,G1.mhi,G1.chandle,G1.mh,FRO.m,C.c,
         C.queries,b,p,h,i,sa} /\ i{1}=0 /\
        (G1.bcol{1} => G1.bcol{2}) /\
        card (rng FRO.m{2}) + 2*(size p{2}) <= 2 * C.c{2} + 1 /\
        Gcol.count{2} + size p{2} <= C.c{2} <= max_size);1:by auto=>/#.
      wp;call (_: ={F.RO.m});1:by sim.
      while 
       (={F.RO.m,G1.mi,G1.paths,G1.m,G1.mhi,G1.chandle,G1.mh,FRO.m,C.c,b,
          p,h,i,sa} /\ (i <= size p){1} /\
        (G1.bcol{1} => G1.bcol{2}) /\
        (card (rng FRO.m) + 2*(size p - i) <= 2 * C.c + 1 /\
        Gcol.count + size p - i <= C.c <= max_size){2});
        last by auto; smt ml=0 w=size_ge0.
      if=>//;auto;1:smt ml=0 w=size_ge0.
      call (_: ={F.RO.m});1:by sim.
      inline *;rcondt{2} 2. 
      + auto;progress;cut /#:= fcard_image_leq fst (rng FRO.m{hr}).
      auto;smt ml=0 w=(hinv_image card_rng_set).
    
    auto;progress;3:by smt ml=0.
    + by rewrite rng_set rem0 rng0 fset0U fcard1.
    by apply max_ge0. 
  qed.

  lemma Pr_G1col &m: 
    Pr[Gpr(DRestr(D)).main() @ &m : G1.bcol] <= max_size%r * ((2*max_size)%r / (2^c)%r).
  proof.
    apply (ler_trans Pr[Gcol.main()@&m : G1.bcol /\ Gcol.count <= max_size]).
    + byequiv G1col=> //#.
    apply (Pr_col &m).
  qed.

end section PROOF.


